[{"content":"《机器学习》笔记系列文章内容按照《机器学习》书本章节进行排布，节号与书中节号一一对应。\n1 绪论 1.2 基本术语    术语 英语原意 释义     数据集 data set 一组关于一个事件或对象的描述的集合   样本 / 示例 sample / instance 数据集中的每条记录   属性 / 特征 attribute / feature 反映样本在某方面的表现或性质的事项   训练数据 training data 用于训练的数据   训练样本 training sample 训练数据中的每个样本   假设 hypothesis 通过训练学得数据的某种规律   真实 ground-truth 潜在规律本身   预测 prediction 训练结果生成的模型   分类 classification 预测离散值   二分类 binary classification 只涉及两个特征的分类   多分类 multi-class classification 涉及多个特征的分类   回归 regression 预测连续纸   聚类 clustering 对训练样本进行分组   簇 cluster 聚类后的每一个组   监督学习 supervised learning 训练数据有标记信息的训练（分类与回归）   无监督学习 unsupervised learning 训练数据没有标记信息的训练（聚类）    2 模型评估与选择 2.1 经验误差与过拟合 误差 通常我们把分类错误的样本数占样本总数的比例称为“错误率”（error rate），即如果在 m 个样本中有 a 个样本分类错误，则错误率 $ E = \\frac{a}{m} $； 相应的，$ 1 - \\frac{a}{m} $ 称为“精度”（accuracy），即“精度 = 1 - 错误率”。\n更一般地，我们把学习器的实际预测输出与样本的真实输出之间的差异称为“误差”（error），学习器在训练集上的误差称为”训练误差“（training error） 或“经验误差”（empirical error）, 在新样本上的误差称为“泛化误差”（generalization errorr）。\n过拟合与欠拟合 为了达到更好的学习效果，应该从训练样本中尽可能学出适用于所有潜在样本的“普遍规律”，这样才能在遇到新样本时做出正确的判别。然而，当学习器把训练样本学得“太好”了的时候，很可能已经把训练样本自身的一些特点当作了所有潜在样本都会具有的一般性质，这样就会导致泛化性能下降。这种现象在机器学习中称为“过拟合”（overfitting）。 与“过拟合”相对的是“欠拟合”（underfitting），这是指对训练样本的一般性质尚未学好。\n下图展示了欠拟合与过拟合，蓝色点为训练数据，橙色点为测试数据，红色曲线为拟合曲线。\n最优拟合 欠拟合（underfitting） 过拟合（overfitting） 过拟合的训练误差（蓝色）与泛化误差（红色） 2.2 评估方法 2.2.1 留出法 留出法（hold-out）直接将数据集 $D$ 划分为两个互斥的集合，其中一个集合作为训练集 $S$，另一个作为测试集 $T$，即\n$$ D = S \\cup T , S \\cap T=\\varnothing $$\n需要注意的是训练/测试集的划分要尽可能保持数据分布的一致性，避免因数据划分过程引入额外的偏差而对最终结果产生影响。\n2.2.2 交叉验证法 交叉验证法（cross validation）先将数据集 $D$ 划分为 $k$ 个大小相似的互斥子集，即\n$$ D = D_1 \\cup D_2 \\cup \\dots \\cup D_k , D_i \\cap D_j = \\varnothing (i \\ne j)$$\n每个子集 $D_{i}$ 都尽可能保持数据分布的一致性，即从 $D$ 中通过分层采样得到。然后每次用 $k - 1$ 个子集的并集作为训练集，余下的那个子集作为测试集；这样就可以获得 $k$ 组训练/测试集，从而可进行 $k$ 次训练和测试，最终返回的是这 $k$ 个测试结果得得得均值。显然，交叉验证法评估结果的稳定性和保真性在很大程度上取决于 $k$ 的取值，为强调这一点，通常把交叉验证法称为 ”$k$ 折交叉验证“（$k$-fold cross validation）。$k$ 最常用的取值是 10，此时成为 10 折交叉验证。下图为 10 折交叉验证的示意图。\n2.3 性能度量 在预测任务中，给定样例集 $D = \\{ (x_1, y_1), (x_2, y_2), \\dots , (x_m, y_m) \\} $ ，其中 $y_i$ 是 $x_i$ 的真实标记。要评估学习器 $f$ 的性能，就要把学习器预测结果 $f(x)$ 与真实标记 $y$ 进行比较。\n回归任务最常用的性能度量是”均方误差“（mean squared error），即 Loss function\n$$ L(f) = E(f; D) = \\frac{1}{m} \\sum_{i=1}^{m}(f(x_i) - y_i)^2 $$\n则最优学习器 $f^*$ 可以表示为\n$$ f^* = arg \\min_f L(f) $$\n参考文献  过拟合-维基百科 分层抽样 李宏毅机器学习笔记(LeeML-Notes)  ","date":"2020-12-22T09:00:00+08:00","permalink":"https://example.com/posts/machine-learning-note-1/","title":"《机器学习》笔记（一）"},{"content":"环境搭建 本例中，所涉及的系统与软件版本列表如下。\n   名称 版本     操作系统 Windows 20H2   Anaconda Anaconda3-2020.11   python 3.6   tensorflow 1.8.0    本例代码存放于 https://github.com/sudrizzz/MachineLearning。\nAnaconda 安装 通过清华大学开源软件镜像站，我们可以直接下载最新版本的 Anaconda，本例中使用的 Anaconda 下载链接： https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-2020.11-Windows-x86_64.exe\nAnaconda 安装教程网络上已经有很多，故此处不再赘述。\n安装完成后，我们需要手动配置 Anaconda 的环境变量，在用户变量的 Path 中添加 Anaconda 的安装路径以及其子文件夹，具体内容如下。\nC:\\Users\\xvyn\\anaconda3 C:\\Users\\xvyn\\anaconda3\\Scripts C:\\Users\\xvyn\\anaconda3\\Library\\bin 上述配置请根据 Anaconda 实际安装路径进行调整，配置完成的效果如下图所示。\n完成后打开 cmd 输入下列命令，如果输出内容与下列内容类似，则表示配置正确，可继续后面的步骤。\n1conda --version 输出 conda 4.9.2  创建虚拟环境 通过如下命令进行创建一个虚拟环境。\n1conda create -n handwrittendigits -n handwrittendigits 的作用是指定虚拟环境的名称，本例中指定为 handwrittendigits。\n执行结束后，可通过下列命令查看 Anaconda 中所有的虚拟环境。\n1conda info --evns 输出如下\n(base) PS C:\\Users\\xvyn\u0026gt; conda info --envs conda environments: base * C:\\Users\\xvyn\\anaconda3 handwrittendigits C:\\Users\\xvyn\\anaconda3\\envs\\handwrittendigits  其中，标记 * 的表示目前已启用，命令行前半部分的 (base) 也表示目前启用的是哪个虚拟环境，此例中为 base 环境。\n切换虚拟环境 如果使用 PowerShell 进行 Anaconda 的一些操作，需要以 管理员 身份运行 PowerShell，然后执行下列命令。\n1set-executionpolicy remotesigned 执行完成后可通过下列命令进行切换虚拟环境。若使用其他 Shell 工具进行操作，则可直接执行下列命令。\n1conda activate handwrittendigits 如果执行时报错如下，则可以通过 https://github.com/conda/conda/issues/7980 来解决。\nCan't execute `conda activate` from batch script  详细操作为：\n 安装并打开 Git Bash 执行 source ~/anaconda3/etc/profile.d/conda.sh 执行 conda init 重启 PowerShell  切换环境操作结束后，可以注意到命令行左侧的括号内容由 (base) 变为 (handwrittendigits)，表明切换成功，后面的操作均在此虚拟环境中进行。\n实际操作过程 (base) PS C:\\Users\\xvyn\u0026gt; conda activate handwrittendigits (handwrittendigits) PS C:\\Users\\xvyn\u0026gt; 再次查看所有虚拟环境 (handwrittendigits) PS C:\\Users\\xvyn\u0026gt; conda info --envs conda environments: base C:\\Users\\xvyn\\anaconda3 handwrittendigits * C:\\Users\\xvyn\\anaconda3\\envs\\handwrittendigits  更换镜像源 由于 Anaconda 和 pip 官方镜像源访问缓慢，故需要将镜像源更换为国内镜像源，例如清华大学、中科大与阿里云镜像源。使用下列命令可以查看当前 Anaconda 镜像源。\n1conda config --show 在输出中找到 channel 部分，有如下内容。\nchannels: - defaults default_channels: - https://repo.anaconda.com/pkgs/main - https://repo.anaconda.com/pkgs/r - https://repo.anaconda.com/pkgs/msys2  更换 Anaconda 镜像源 以清华大学镜像源为例，执行下列命令即可完成更换。\n1conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ 2conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ 3conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/ 4conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/ 5conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda/ 6conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/menpo/ 7conda config --set show_channel_urls yes 恢复默认源\n1conda config --remove-key channels 除了上述命令行操作方式外，也可以直接修改 C:\\Users\u0026lt;USER\u0026gt;\\.condarc 文件来实现换源。参考 Anaconda 镜像使用帮助 修改后的文件内容如下所示。\nssl_verify: false show_channel_urls: true channels: - defaults default_channels: - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/pro - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2 custom_channels: conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  更换 pip 镜像源 以清华大学镜像源为例，执行下列命令即可完成更换。\n1pip config set global.index-url https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple 安装 tensorflow 手写数字生成例子所需要的 tensorflow 版本为 1.x，本例中我们使用的实际版本为 1.8.0。将虚拟环境切换到 handwrittendigits 后，执行以下命令开始安装。\n1conda install tensorflow-gpu=1.8.0 上述命令中 tensorflow-gpu 表示安装的 tensorflow 为 GPU 版本，=1.8.0 指定了安装的版本号。若需要安装 CPU 版 tensorflow 1.8.0，执行以下命令即可。\n1conda install tensorflow=1.8.0 安装 Python 由于需要 1.8.0 版本的 tensorflow，此版本仅兼容 3.5 到 3.7 版本的 Python，故需要先删除 conda 环境中默认安装的 Python，并安装 3.6 版本。\n1# 移除自带 Python 2conda remove python 3 4# 安装 3.6 版本 5conda install python=3.6 测试 Demo 使用 PyCharm 创建项目 在创建项目时，需要将虚拟环境（图中 Location 项）配置为前文中创建的虚拟环境所在目录，然后点击创建项目。\n由于此前作者已经创建过项目，故创建窗口下方会提示虚拟环境目录不为空，忽略即可。\n运行项目 将以下代码置于项目 main.py 中，运行。\n1import tensorflow as tf 2from tensorflow.examples.tutorials.mnist import input_data 3import numpy as np 4import matplotlib.pyplot as plt 5import matplotlib.gridspec as gridspec 6import logging 7import os 8 9if not os.path.exists(\u0026#39;./log\u0026#39;): 10 os.mkdir(\u0026#39;./log\u0026#39;) 11if not os.path.exists(\u0026#39;./out\u0026#39;): 12 os.mkdir(\u0026#39;./out\u0026#39;) 13 14 15def get_logger(filepath, level=logging.INFO): 16 logger = logging.getLogger(__name__) 17 logger.setLevel(level) 18 19 # create a file handler 20 handler = logging.FileHandler(filepath) 21 handler.setLevel(logging.INFO) 22 23 # create a logging format 24 # formatter = logging.Formatter(\u0026#39;%(asctime)s - %(name)s - %(levelname)s - %(message)s\u0026#39;) 25 # handler.setFormatter(formatter) 26 27 # add the handlers to the logger 28 logger.addHandler(handler) 29 return logger 30 31 32def plot(samples): 33 fig = plt.figure(figsize=(4, 4)) 34 gs = gridspec.GridSpec(4, 4) 35 gs.update(wspace=0.05, hspace=0.05) 36 37 for i, sample in enumerate(samples): 38 ax = plt.subplot(gs[i]) 39 plt.axis(\u0026#39;off\u0026#39;) 40 ax.set_xticklabels([]) 41 ax.set_yticklabels([]) 42 ax.set_aspect(\u0026#39;equal\u0026#39;) 43 plt.imshow(sample.reshape(28, 28), cmap=\u0026#39;Greys_r\u0026#39;) 44 45 return fig 46 47 48def random_data(row, column): 49 return np.random.uniform(-1., 1., size=[row, column]) 50 51 52def weight_variable(shape, stddev=0.1): 53 initial = tf.truncated_normal(shape, stddev=stddev) 54 return tf.Variable(initial) 55 56 57def bias_variable(shape, bais=0.1): 58 initial = tf.constant(bais, shape=shape) 59 return tf.Variable(initial) 60 61 62# 鉴别网络weights 63d_w1 = weight_variable([784, 128]) 64d_b1 = bias_variable([128]) 65 66d_w2 = weight_variable([128, 1]) 67d_b2 = bias_variable([1]) 68 69param_d = [d_w1, d_w2, d_b1, d_b2] 70 71# 生成网络weights 72g_w1 = weight_variable([100, 128]) 73g_b1 = bias_variable([128]) 74 75g_w2 = weight_variable([128, 784]) 76g_b2 = bias_variable([784]) 77 78param_g = [g_w1, g_w2, g_b1, g_b2] 79 80 81# 鉴别网络 82def d_network(x): 83 d1 = tf.nn.relu(tf.matmul(x, d_w1) + d_b1) 84 d_out = tf.matmul(d1, d_w2) + d_b2 85 return tf.nn.sigmoid(d_out) 86 87 88# 生成网络 89def g_network(x): 90 g1 = tf.nn.relu(tf.matmul(x, g_w1) + g_b1) 91 g_out = tf.matmul(g1, g_w2) + g_b2 92 return tf.nn.sigmoid(g_out) 93 94 95x = tf.placeholder(tf.float32, shape=[None, 784]) 96z = tf.placeholder(tf.float32, shape=[None, 100]) 97 98d_out_real = d_network(x) 99 100g_out = g_network(z) 101d_out_fake = d_network(g_out) 102 103d_loss = -tf.reduce_mean(tf.log(d_out_real) + tf.log(1. - d_out_fake)) 104g_loss = -tf.reduce_mean(tf.log(d_out_fake)) 105 106d_optimizer = tf.train.AdamOptimizer().minimize(d_loss, var_list=param_d) 107g_optimizer = tf.train.AdamOptimizer().minimize(g_loss, var_list=param_g) 108 109batch_size = 256 110max_step = 1000000 111mnist = input_data.read_data_sets(\u0026#39;../mnist\u0026#39;, one_hot=True) 112logger = get_logger(\u0026#34;./log/info.log\u0026#34;) 113 114with tf.Session() as sess: 115 sess.run(tf.global_variables_initializer()) 116 print(\u0026#34;training\u0026#34;) 117 i = 0 118 for step in range(max_step): 119 batch_real, _ = mnist.train.next_batch(batch_size) 120 _, d_loss_train = sess.run([d_optimizer, d_loss], feed_dict={x: batch_real, z: random_data(batch_size, 100)}) 121 _, g_loss_train = sess.run([g_optimizer, g_loss], feed_dict={z: random_data(batch_size, 100)}) 122 123 if step % 1000 == 0: 124 samples = sess.run(g_out, feed_dict={z: random_data(16, 100)}) 125 126 fig = plot(samples) 127 plt.savefig(\u0026#39;out/{}.png\u0026#39;.format(str(i).zfill(4)), bbox_inches=\u0026#39;tight\u0026#39;) 128 i += 1 129 plt.close(fig) 130 131 logger.info(\u0026#34;step %s: d_loss is %s, gan_loss is %s\u0026#34; % (step, d_loss_train, g_loss_train)) 132 print(\u0026#34;step %s: d_loss is %s, g_loss is %s\u0026#34; % (step, d_loss_train, g_loss_train)) 运行时的截图如下，可以看到已经生成了多张手写数字的图片。\n至此，GAN 网络手写数字生成环境搭建已经完成，后续将进行更加深入的学习。\n参考文章  Anaconda 源使用帮助 gan_practice Can\u0026rsquo;t execute conda activate from bash script python 安装 TensorFlow 吐血整理 conda 安装指定版本的指定包 Python pip 命令行设置国内镜像源  ","date":"2020-12-08T10:00:00+08:00","permalink":"https://example.com/posts/gan-for-hand-written-digits/","title":"GAN 网络之手写数字生成"},{"content":"写在前面 Vim 基本操作 简介 vim 共分为三种模式，分别是命令模式（Command mode），输入模式（Insert mode）和底线命令模式（Last line mode）。 详见 Linux vi/vim | 菜鸟教程。\n编辑文件 编辑文本文件可以通过 vim 文件名 实现，如果文件原本不存在，则 Vim 会自动新建该文件。例如新建或编辑名为 test.txt 的文件，可以通过下面的命令实现。\n1vim test.txt 进入编辑界面之后，按下 i 键或 Insert 键，即可进入输入模式开始编辑文件。\n常用命令    命令 操作说明     Esc 退出编辑模式   :wq 保存文件并退出 Vim   :q! 不保存文件并强制退出 Vim（慎用）   :set nu 显示行号   i / Insert 切换到输入模式   x 删除当前光标所在处的字符   d 剪切光标所在行   dd 删除光标所在行   yy 复制光标所在行   p 粘贴已复制或已剪切的数据   u 撤销上一步操作   gg 跳转到文件开头   G(shift+g) 跳转到文件末尾   /word 搜索名称为 word 的字符串   ^ 跳转到光标所在行首   $ 跳转到光标所在行尾    代码及数据 本文的代码均存放在 Github，地址 https://github.com/sudrizzz/ParallelComputing。\n本例中所设计到的输入矩阵有两个：a 矩阵与 b 矩阵，其值相同，如下：\na、b 矩阵：\n18.04\t8.47\t16.82\t17.15\t19.58\t4.24\t7.20\t16.50\t5.97\t11.90 10.25\t13.50\t7.83\t11.03\t20.45\t19.68\t13.65\t15.40\t3.04\t13.03 0.35\t5.22\t2.95\t17.27\t3.36\t8.61\t2.79\t2.34\t21.45\t4.69 11.02\t18.02\t13.16\t6.36\t13.69\t11.26\t10.60\t20.89\t6.28\t16.56 11.31\t16.53\t8.59\t19.15\t6.08\t7.57\t17.35\t19.74\t1.50\t20.39 11.30\t1.85\t4.13\t14.24\t19.12\t7.49\t1.38\t0.43\t9.83\t1.35 5.12\t20.84\t19.37\t18.27\t5.73\t11.59\t8.06\t16.33\t11.01\t14.34 11.42\t0.84\t9.40\t20.01\t19.99\t15.48\t6.11\t15.86\t13.74\t7.60 14.77\t3.56\t9.45\t18.90\t17.81\t7.09\t4.92\t19.19\t7.52\t14.75 20.54\t12.64\t14.12\t18.44\t9.44\t19.84\t8.56\t17.50\t14.69\t19.56 矩阵相加 上传文件 在命令行中使用 rz 命令开始上传文件，选中相应文件之后点击打开即可开始上传。\n编译 执行 nvcc 命令编译上述文件，生成可执行文件。\n1nvcc -o matrixaddition matrixaddition.cu 其中，-o matrixaddition 表示将可执行文件的文件名指定为 matrixaddition。若不指定，则默认为 a.out。\n执行完上述操作之后，使用 ll 命令可以查看现有的所有文件，输出如下。\n-rwxrwxr-x. 1 cuda01 cuda01 569416 11 月 24 09:50 matrixaddition -rw-r--r--. 1 cuda01 cuda01 2023 11 月 24 09:49 matrixaddition.cu 运行 上述过程中生成了 matrixaddition 可执行文件，执行下述命令即可开始运行。\n1./matrixaddition 输出结果如下：\n36.09\t16.94\t33.63\t34.29\t39.15\t8.48\t14.40\t33.00\t11.93\t23.79 20.50\t27.01\t15.67\t22.05\t40.90\t39.35\t27.30\t30.81\t6.08\t26.07 0.70\t10.43\t5.89\t34.54\t6.73\t17.22\t5.57\t4.67\t42.90\t9.37 22.03\t36.04\t26.31\t12.71\t27.38\t22.52\t21.20\t41.78\t12.56\t33.13 22.62\t33.07\t17.19\t38.29\t12.17\t15.14\t34.69\t39.47\t3.00\t40.77 22.59\t3.70\t8.26\t28.49\t38.24\t14.98\t2.76\t0.86\t19.66\t2.71 10.23\t41.69\t38.75\t36.55\t11.45\t23.18\t16.12\t32.65\t22.01\t28.68 22.83\t1.69\t18.80\t40.02\t39.98\t30.96\t12.21\t31.72\t27.49\t15.21 29.54\t7.13\t18.90\t37.80\t35.61\t14.19\t9.83\t38.37\t15.05\t29.49 41.08\t25.28\t28.23\t36.88\t18.88\t39.68\t17.11\t34.99\t29.39\t39.13 矩阵相乘 与上述过程类似，将编写好的代码上传到服务器中，准备进行编译。\n编译 执行 nvcc 命令编译代码文件，生成可执行文件。\n1nvcc -o matrixmultiplication matrixmultiplication.cu 运行 上述过程中生成了 matrixmultiplication 可执行文件，执行下述命令即可开始运行。\n1./matrixmultiplication 相乘结果：\n1434.15\t1331.02\t1349.52\t2031.20\t1607.49\t1378.23\t1109.41\t1915.59\t1198.52\t1642.11 1459.53\t1356.36\t1325.31\t2057.32\t1718.01\t1479.91\t1109.21\t1791.41\t1139.91\t1573.60 840.46\t667.29\t691.96\t1000.79\t1033.85\t727.56\t517.53\t1100.00\t572.38\t918.05 1465.92\t1237.35\t1307.85\t2113.54\t1760.48\t1593.65\t1067.92\t1812.61\t1268.27\t1554.78 1106.95\t1007.73\t1027.50\t1761.49\t1474.07\t1238.15\t1092.06\t1966.31\t1278.88\t1661.49 866.95\t809.99\t741.98\t1093.15\t931.67\t600.26\t684.60\t1144.12\t468.24\t1008.11 1394.52\t1273.50\t1259.89\t1989.42\t1802.07\t1643.34\t1025.81\t1803.05\t1353.40\t1541.02 1410.82\t1162.53\t1229.82\t1926.65\t1632.43\t1203.22\t978.71\t1790.40\t1080.38\t1510.35 1338.49\t1253.85\t1171.30\t1826.25\t1491.70\t1298.11\t1020.23\t1856.90\t1107.89\t1567.99 1901.57\t1436.10\t1636.91\t2460.80\t2242.40\t1747.59\t1161.72\t2187.99\t1521.42\t1855.17 ","date":"2020-11-24T10:00:00+08:00","permalink":"https://example.com/posts/parallel-computing/","title":"并行计算课程实践"},{"content":"FastDFS 简介 FastDFS 是一个开源的高性能分布式文件系统（Distributed File System）。它的主要功能包括：文件存储、文件同步和文件访问以及高容量和负载平衡。主要解决了海量数据存储问题，特别适合以中小文件（建议范围：4KB \u0026lt; file_size \u0026lt; 500MB）为载体的在线服务。\nFastDFS 开源地址：https://github.com/happyfish100/fastdfs\n由于网络上已有很多详细的关于 FastDFS 的介绍，故此处不再赘述。请查看参考文章中的第 1、2 条。\nFastDFS 架构图 FastDFS 上传流程 FastDFS 下载流程 安装 FastDFS 配置防火墙 本篇文章是基于 CentOS v8.2.2004 版本，以下操作均为单机环境，单机 IP 地址为 192.168.61.128。在安装 FastDFS 之前，需要先进行防火墙的设置。防火墙的相关命令如下：\n1# 暂时关闭防火墙 2systemctl stop firewalld 3 4# 永久关闭防火墙 5systemctl disable firewalld 6 7# 启用防火墙 8systemctl enable firewalld 下载安装 libfastcommon libfastcommon 是从 FastDFS 抽取出来的公共 c 函数库。\n1# 下载 2wget https://github.com/happyfish100/libfastcommon/archive/V1.0.43.tar.gz 3 4# 解压 5tar -zxvf V1.0.43.tar.gz 6cd libfastcommon-1.0.43 7 8# 编译安装 9./make.sh 10./make.sh install libfastcommon.so 安装到了 /usr/lib64/libfastcommon.so，但是 FastDFS 主程序设置的 lib 目录是 /usr/local/lib，所以需要创建软链接。\n1ln -s /usr/lib64/libfastcommon.so /usr/local/lib/libfastcommon.so 2ln -s /usr/lib64/libfastcommon.so /usr/lib/libfastcommon.so 3ln -s /usr/lib64/libfdfsclient.so /usr/local/lib/libfdfsclient.so 4ln -s /usr/lib64/libfdfsclient.so /usr/lib/libfdfsclient.so 下载安装 FastDFS 1# 下载 2wget https://github.com/happyfish100/fastdfs/archive/V6.06.tar.gz 3 4# 解压 5tar -zxvf V6.06.tar.gz 6cd fastdfs-6.06 7 8# 编译安装 9./make.sh 10./make.sh install 安装完成之后，服务脚本存储在 /etc/init.d/ 中，详细文件如下：\n/etc/init.d/fdfs_storaged /etc/init.d/fdfs_tracker  默认配置文件存储在 /etc/fdfs/ 中，详细文件如下：\n/etc/fdfs/client.conf.sample /etc/fdfs/storage.conf.sample /etc/fdfs/tracker.conf.sample  命令工具存储在 /usr/bin/ 中，详细文件如下：\nfdfs_appender_test fdfs_appender_test1 fdfs_append_file fdfs_crc32 fdfs_delete_file fdfs_download_file fdfs_file_info fdfs_monitor fdfs_regenerate_filename fdfs_storaged fdfs_test fdfs_test1 fdfs_trackerd fdfs_upload_appender fdfs_upload_file stop.sh restart.sh  配置 FastDFS Tracker 服务 修改配置文件 从上文可知，配置文件在 /etc/fdfs/ 中，我们需要拷贝一份并进行一些修改。\n1cd /etc/fdfs 2cp tracker.conf.sample tracker.conf 3vim tracker.conf 需要修改的部分如下：\n# Tracker 数据和日志存储目录 base_path = /home/fastdfs/tracker # HTTP 服务端口 http.server_port = 80 根据上述配置，创建配置中的目录\n1mkdir -p /home/fastdfs/tracker 启动 Tracker 服务 初次成功启动，会在 base_path 即 /home/fastdfs/tracker 下创建 data、logs 两个目录。启动命令如下：\n1/etc/init.d/fdfs_trackerd start 2# 或 3service fdfs_trackerd start 启动后，可以通过 netstat 命令查看是都启动成功，若得到以下类似输出，22122 端口处于监听状态，则表示 Tracker 服务安装并启动成功。\n1netstat -unltp | grep fdfs # 输出内容 tcp 0 0 0.0.0.0:22122 0.0.0.0:* LISTEN 6220/fdfs_trackerd  同理，可以通过下列命令关闭 Tracker 服务或者设置 Tracker 开机自启：\n1# 关闭服务 2service fdfs_trackerd stop 3 4# 开机自启 5chkconfig fdfs_trackerd on 配置 FastDFS Storage 服务 修改配置文件 与配置 Tracker 服务类似，首先我们也需要拷贝样例配置文件并进行相应修改。\n1cd /etc/fdfs 2cp storage.conf.sample storage.conf 3vim storage.conf 需要修改的部分如下：\n# Tracker 数据和日志存储目录 base_path = /home/fastdfs/storage # 存放文件时 storage server 支持多个路径。这里配置存放文件的基路径数目，通常只配一个目录 store_path_count=1 # 逐一配置 store_path_count 个路径，索引号基于 0 # 如果不配置 store_path0，那它就和 base_path 对应的路径一样 store_path0=/home/fastdfs/file # FastDFS 存储文件时，采用了两级目录。这里配置存放文件的目录个数。 # 如果本参数为 N（默认 256），那么 storage server 在初次运行时，会在 store_path 下自动创建 N*N 个存放文件的子目录 subdir_count_per_path=256 # tracker_server 的列表 ，会主动连接 tracker_server # 有多个 tracker server 时，每个 tracker server 写一行 tracker_server=192.168.61.128:22122 # HTTP 服务端口 http.server_port = 80 根据上述配置，创建配置中的目录\n1# base_path 2mkdir -p /home/fastdfs/storage 3 4# store_path0 5mkdir -p /home/fastdfs/file 启动 Storage 服务 启动 Storage 前确保 Tracker 是启动的。初次启动成功，会在 base_path 即 /home/fastdfs/storage/ 目录下创建 data、logs 两个目录。启动命令如下：\n1/etc/init.d/fdfs_storaged start 2# 或 3service fdfs_storaged start 启动后，可以通过下列命令查看 Storage 服务是否启动成功。若输出结果与下列输出类似，23000 端口正处于监听状态，则 Storage 服务启动成功。\n1netstat -unltp | grep fdfs # 输出内容 tcp 0 0 0.0.0.0:23000 0.0.0.0:* LISTEN 6257/fdfs_storaged tcp 0 0 0.0.0.0:22122 0.0.0.0:* LISTEN 6220/fdfs_trackerd  同理，可以通过下列命令关闭 Tracker 服务或者设置 Tracker 开机自启：\n1# 关闭服务 2service fdfs_storaged stop 3 4# 开机自启 5chkconfig fdfs_storaged on 此时我们可以在 store_path0 目录下看到 Storage 服务自动创建的 N*N 个子目录\n1ls /home/fastdfs/file/data/ 2 3# 统计文件夹数量 4ls -l | grep \u0026#34;^d\u0026#34; | wc -l 5 6cd 00 7ls -l | grep \u0026#34;^d\u0026#34; | wc -l # 输出内容 00 0A 14 1E 28 32 3C 46 50 5A 64 6E 78 82 8C 96 A0 AA B4 BE C8 D2 DC E6 F0 FA 01 0B 15 1F 29 33 3D 47 51 5B 65 6F 79 83 8D 97 A1 AB B5 BF C9 D3 DD E7 F1 FB 02 0C 16 20 2A 34 3E 48 52 5C 66 70 7A 84 8E 98 A2 AC B6 C0 CA D4 DE E8 F2 FC 03 0D 17 21 2B 35 3F 49 53 5D 67 71 7B 85 8F 99 A3 AD B7 C1 CB D5 DF E9 F3 FD 04 0E 18 22 2C 36 40 4A 54 5E 68 72 7C 86 90 9A A4 AE B8 C2 CC D6 E0 EA F4 FE 05 0F 19 23 2D 37 41 4B 55 5F 69 73 7D 87 91 9B A5 AF B9 C3 CD D7 E1 EB F5 FF 06 10 1A 24 2E 38 42 4C 56 60 6A 74 7E 88 92 9C A6 B0 BA C4 CE D8 E2 EC F6 07 11 1B 25 2F 39 43 4D 57 61 6B 75 7F 89 93 9D A7 B1 BB C5 CF D9 E3 ED F7 08 12 1C 26 30 3A 44 4E 58 62 6C 76 80 8A 94 9E A8 B2 BC C6 D0 DA E4 EE F8 09 13 1D 27 31 3B 45 4F 59 63 6D 77 81 8B 95 9F A9 B3 BD C7 D1 DB E5 EF F9 256 256  文件上传测试 修改配置文件 与配置 Storage 服务类似，首先我们也需要拷贝客户端样例配置文件并进行相应修改。\n1cd /etc/fdfs 2cp client.conf.sample client.conf 3vim client.conf 需要修改的部分如下：\n# Client 的数据和日志目录 base_path=/home/fastdfs/client # Tracker端口 tracker_server=192.168.61.128:22122 上传图片测试 执行下列命令，尝试上传一张图片到 FastDFS 中：\n1fdfs_upload_file /home/Pictures/1989.jpg 上传成功后，会输出文件 ID：group1/M00/00/00/wKg9gF-f0aKAUJAlAARra4mLMhc390.jpg\n返回的文件 ID 由 group、存储目录、两级子目录、fileid、文件后缀名（由客户端指定，主要用于区分文件类型）拼接而成。\n配置 Nginx 安装 Nginx 的相关操作请查看文章 初识 Nginx，此处不再赘述。\n修改配置 经过上述操作之后，文件已经可以通过命令行的方式上传到 FastDFS 中，但还无法下载，此时我们需要使用 Nginx 来实现下载功能。修改 Nginx 配置文件，在 server 组内添加以下内容：\nserver { listen 80; server_name localhost; # 添加以下部分 location /group1/M00 { alias /home/fastdfs/file/data; } } 然后重启 Nginx，访问服务器 ip/fileid 进行测试，根据上述例子，此处访问 http://192.168.61.128/group1/M00/00/00/wKg9gF-f0aKAUJAlAARra4mLMhc390.jpg\n测试结果如下图，可以看到已经访问成功，HTTP 状态码返回 200。\n配置 fastdfs-nginx-module 模块 模块简介 fastdfs-nginx-module 可以重定向文件链接到源服务器，避免由于 Storage 服务器复制延迟导致文件无法访问而产生的错误。\n下载解压 1wget https://github.com/happyfish100/fastdfs-nginx-module/archive/V1.22.tar.gz 2tar -zxvf V1.22.tar.gz 3cd fastdfs-nginx-module 为 Nginx 添加模块 首先进入 Nginx 源目录，然后执行 ./configure 命令，具体命令如下：\n1nginx -s stop 2cd /usr/local/software/nginx-1.18.0 3./configure --prefix=/usr/local/nginx/ --add-module=$YOUR_PATH/fastdfs-nginx-module/src 4make \u0026amp;\u0026amp; make install 其中，/usr/local/software/nginx-1.18.0 为 Nginx 源目录，--prefix 参数指定新版本生成的目录，--add-module 参数表示添加模块，$YOUR_PATH 需要手动替换为 fastdfs-nginx-module 模块的文件路径，本例中为 /usr/local/software/fastdfs-nginx-module。\n安装好之后可以通过以下命令查看 Nginx 模块，如果输出与下列内容类似，则表示模块添加成功。\nnginx -V # 输出内容 nginx version: nginx/1.18.0 built by gcc 8.3.1 20191121 (Red Hat 8.3.1-5) (GCC) configure arguments: --prefix=/usr/local/nginx/ --add-module=/usr/local/software/fastdfs-nginx-module/src  修改 Nginx 配置 修改 nginx.conf，在 server 中做出如下修改：\nserver { listen 80; server_name localhost; # 删除以下部分 location /group1/M00 { alias /home/fastdfs/file/data; } # 添加以下部分 location ~/group[0-9]/ { ngx_fastdfs_module; } } 修改 fastdfs-nginx-module 配置 复制 fastdfs-nginx-module 源码中的配置文件到 /etc/fdfs 目录，兵做以下修改。\n1cd /usr/local/software/fastdfs-nginx-module/src 2cp mod_fastdfs.conf /etc/fdfs/ # Tracker Server tracker_server=192.168.61.128:22122 # Storage Server 默认端口 storage_server_port=23000 # 如果文件 ID 的 uri 中包含 /group**，则要设置为 true url_have_group_name = true # Storage 配置的 store_path0 路径，必须和 storage.conf 中的一致 store_path0=/home/fastdfs/file 复制 FastDFS 的部分配置文件到 /etc/fdfs 目录\n1cd /usr/local/software/fastdfs-5.05/conf/ 2cp anti-steal.jpg http.conf mime.types /etc/fdfs/ 测试 配置完成之后，我们先启动 Nginx 服务，并观察输出内容，如果与下列输出类似，则表示配置成功。\n1nginx # 输出内容 ngx_http_fastdfs_set pid=11648  此时我们可以在浏览器中访问前文中上传的文件，能下载文件则表示 fastdfs-nginx-module 模块安装成功。注意和和前文中直接使用 Nginx 路由访问不同的是，这里配置 fastdfs-nginx-module 模块，可以重定向文件链接到源服务器取文件。访问结果如下图所示。\n至此，FastDFS 搭建分布式文件管理系统就初步完成了，在下一篇文章中，将介绍如何在客户端上通过 Java 来实现文件的上传和下载。\n参考文章  用 FastDFS 一步步搭建文件管理系统 FastDFS 简介 FastDFS Distributed File Storage FastDFS 配置文件详解（修订版 1） 初识 Nginx fastdfs nginx module installation introduction  ","date":"2020-11-04T17:00:00+08:00","permalink":"https://example.com/posts/getting-to-know-fastdfs/","title":"FastDFS 搭建分布式文件管理系统"},{"content":"Spark 简介 Spark 是一种基于内存的、用以实现高效集群计算的平台。准确地讲，Spark 是一个大数据并行计算框架，是对广泛使用的 MapReduce 计算模型的扩展。Spark 有着自己的生态系统，但同时兼容 HDFS、Hive 等分布式存储系统，可以完美融入 Hadoop 的生态圈中，代替 MapReduce 去执行更为高效的分布式计算。两者的区别在于：基于 MapReduce 的计算引擎通常会将中间结果输出到磁盘上进行存储和容错；而 Spark 则是将中间结果尽量保存在内存中以减少底层存储系统的 I/O，以提高计算速度。\nSpark 编程模型 核心数据结构 RDD Spark 将数据抽象成弹性分布式数据集（Resilient Distributed Dataset, RDD），RDD 实际是分布在集群多个节点上数据的集合，通过操作 RDD 对象来并行化操作集群上的分布式数据。\nRDD 有两种创建方式:\n 并行化驱动程序中已有的原生集合; 引用 HDFS、HBase 等外部存储系统上的数据集。  RDD 可以缓存在内存中，每次对 RDD 操作的结果都可以放到内存中，下一次操作时可直接从内存中读取，相对于 MapReduce,它省去了大量的磁盘 I/O 操作。另外，持久化的 RDD 能够在错误中自动恢复，如果某部分 RDD 丢失，Spark 会自动重算丢失的部分。\nRDD 上的操作 从相关数据源获取初始数据形成初始 RDD 后，需要根据应用的需求对得到的初始 RDD 进行必要的处理，来获取满足需求的数据内容，从而对中间数据进行计算加工，得到最终的数据。\nRDD 支持两种操作，一种是转换（Transformation）操作，另一种是行动（Action）操作。\n转换（Transformation）操作 转换操作即将一个 RDD 转换为一个新的 RDD。值得注意的是，转换操作是惰性的，这就意味着对 RDD 调用某种转换操作时，操作并不会立即执行，而是 Spark 在内部记录下所要求执行的操作的相关信息，当在行动操作中需要用到这些转换出来的 RDD 时才会被计算，下表所示为基本的转换操作。通过转换操作，可以从已有的 RDD 生成出新的 RDD, Spark 使用谱系（Lineage）记录新旧 RDD 之间的依赖关系，一旦持久化的 RDD 丢失部分数据时，Spark 能通过谱系图重新计算丢失的数据。\n 输入数据为 {1, 2, 3, 3}\n    函数名 目的 示例 结果     map() 将数据集中的每个元素经过用户自定义的函数转换形成一个新的 RDD rdd.map(x =\u0026gt; x * 2) {2, 4, 6, 6}   flatMap() 与 map() 类似，但每个元素输入项都可以被映射到 0 个或多个的输出项，最终将结果“扁平化“后输出 rdd.flatMap(x =\u0026gt; (1 to x)) {1, 1, 2, 1, 2, 3, 1, 2, 3, 3}   filter() 对 RDD 元素进行过滤，把经过指定函数后返回值为 true 的元素组成一个新的 RDD rdd.filter(x =\u0026gt; (x != 3)) {1, 2}   distinct() 对数据进行去重，返回一个新的 RDD rdd.distinct() {1, 2, 3}   sample(withReplacement, fraction, seed) 以指定的随机种子随机抽样出数量为 fraction 的数据，withReplacement 表示是抽出的数据是否放回，true 为有放回的抽样，false 为无放回的抽样 rdd.sample(true,0.5,3) 非确定的    行动（Action）操作 行动操作会触发 Spark 提交作业，对 RDD 进行实际的计算，并将最终求得的结果返回到驱动器程序，或者写入外部存储系统中。由于行动操作会得到一个结果，所以 Spark 会强制对 RDD 的转换操作进行求值，下表所示为基本的行动操作。\n 输入数据为 {1, 2, 3, 3}\n    函数名 目的 示例 结果     collect() 返回 RDD 中的所有元素 rdd.collect() {1, 2, 3, 3}   count() 返回 RDD 中元素的个数 rdd.count() 4   countByValue() 返回 RDD 中各元素出现的次数 rdd.countByValue() {(1, 1), (2, 1), (3, 2)}   take(n) 从 RDD 中返回 n 个元素（任意位置） rdd.take(2) {2, 3}   top(n) 从 RDD 中返回前 n 个元素 rdd.top(2) {1, 2}   reduce(func) 并行整合 RDD 中的所有数据 rdd.reduce((x, y) =\u0026gt; x + y) 9   fold(zero)(func) 与 reduce() 类似，但需要提供初始值。加法的默认是 0；乘法的默认是 1 rdd.fold(1)((x, y) =\u0026gt; x + y) 10   aggregate() 与 reduce() 类似，但通常返回不同类型的函数 rdd.aggregate((0, 0))((x, y) =\u0026gt; (x._1 + y, x._2 + 1), (x, y) =\u0026gt; (x._1 + y._1, x._2 + y._2)) (9, 4)   foreach(func) 对 RDD 中的每个元素使用给定的函数 rdd.foreach(func) 无    示例 以下两个示例的数据集与源代码均可以在下述链接中进行下载 https://github.com/sudrizzz/BigDataTechnologyFoundation_SourceCodeAndDataSet/tree/main/ch08\n一、分词 WordCount（单词统计程序）是大数据领域经典的例子，与 Hadoop 实现的 WordCount 程序相比，Spark 实现的版本要显得更加简洁。\n从 MapReduce 到 Spark 在经典的计算框架 MapReduce 中，问题会被拆成两个主要阶段: map 阶段和 reduce 阶段。对单词计数来说，MapReduce 程序从 HDFS 中读取一行字符串。在 map 阶段，将字符串分割成单词，并生成 \u0026lt;word, 1\u0026gt; 这样的键值对；在 reduce 阶段，将单词对应的计数值（初始为 1）全部累加起来，最后得到单词的总出现次数。\n在 Spark 中，并没有 map/reduce 这样的划分，而是以 RDD 的转换来呈现程序的逻辑。首先，Spark 程序将从 HDFS 中按行读取的文本作为初始 RDD（即集合的每一个元素都是一行字符串）；然后，通过 flatMap 操作将每一行字符串分割成单词，并收集起来作为新的单词 RDD；接着，使用 map 操作将每一个单词映射成 \u0026lt;word, 1\u0026gt;这样的键值对，转换成新的键值对 RDD；最后，通过 reduceByKey 操作将相同单词的计数值累加起来，得到单词的总出现次数。\nJava 实现 1import org.apache.spark.SparkConf; 2import org.apache.spark.api.java.JavaPairRDD; 3import org.apache.spark.api.java.JavaRDD; 4import org.apache.spark.api.java.JavaSparkContext; 5import scala.Tuple2; 6 7import java.util.Arrays; 8import java.util.List; 9import java.util.regex.Pattern; 10 11public class SparkDemo { 12 private static final Pattern kSpace = Pattern.compile(\u0026#34; \u0026#34;); 13 14 public static void main(String[] args) { 15 SparkConf conf = new SparkConf().setAppName(\u0026#34;WordCount\u0026#34;); 16 JavaSparkContext sc = new JavaSparkContext(conf); 17 18 JavaRDD\u0026lt;String\u0026gt; lines = sc.textFile(args[0]).rdd().toJavaRDD(); 19 JavaRDD\u0026lt;String\u0026gt; words = lines.flatMap(s -\u0026gt; Arrays.asList(kSpace.split(s)).iterator()); 20 JavaPairRDD\u0026lt;String, Integer\u0026gt; ones = words.mapToPair(s -\u0026gt; new Tuple2\u0026lt;\u0026gt;(s, 1)); 21 JavaPairRDD\u0026lt;String, Integer\u0026gt; counts = ones.reduceByKey(Integer::sum); 22 List\u0026lt;Tuple2\u0026lt;String, Integer\u0026gt;\u0026gt; output = counts.collect(); 23 24 for (Tuple2\u0026lt;String, Integer\u0026gt; tuple : output) { 25 System.out.println(tuple._1() + \u0026#34; : \u0026#34; + tuple._2()); 26 } 27 sc.close(); 28 } 29} 运行过程分析  初始化 创建配置文件 SparkConf，这里仅设置应用名称；再创建 JavaSparkContext，在程序中主要通过 JavaSparkContext 来访问 Spark 集群； 处理数据  根据参数使用 Spark.read().textFile() 方法按行读取输入文件，并转换成 RDD lines； 使用 flatMap 操作将所有行按空格分割切割成词，并生成新的 RDD words； 使用 map 操作( Java 中为 mapToPair )，将词映射成 \u0026lt;word, 1\u0026gt;键值对 RDD ones，其中 1 表示出现一次； 使用 reduceByKey 操作将所有相同的 word 对应的计数累加起来，得到新的 RDD counts； 使用 collect 操作将所有结果打印出来；   关闭 JavaSparkContext。  执行 将上述代码生成 Jar 包之后，将其放到服务器中，执行下面的命令即可开始运行。\n1./bin/spark-submit --class SparkDemo ~/Documents/SparkDemo.jar ~/Documents/sample.txt 其中\n \u0026ndash;class SparkDemo 用来指定主类名 ~/Documents/SparkDemo.jar 指定 Jar 包路径 ~/Documents/sample.txt 指定测试文本路径  sample.txt 文本内容如下所示\nYour want text it even a text notes having wrong even about fake want or not even but. Language way contentwise just language contentwise recipes set start are. Recipes a words than with meeting days ?looks? even than is name story more story words generator anything gone. Having story but fairly random some adequate want it set has a kind looking having. Fantasy anything you looks just copy work text random sets even fake having. Piece some recipes repetitive adequate wrong wrong way options to repetitive working some dummy repetitive copy realistic you fake. Work or just fairly with is unrelated having language about set forever not game repetitive adequate now you looks it of even dummy now. That but design language unrelated copy you text placeholder has review those of with fake. Random to want the has gardening which business some realistic that and just work. Gardening you realistic kind and name looks about name words words way which some name. The that copy story realistic the adequate text meeting options game gone piece has options has name random. Days wrong set realistic design repetitive adequate review text your or but having start about right are story fairly fairly but to language sets adequate. But work want sets right kind some having contentwise fairly convincing language notes right name from but want realistic unrelated words. From about generator not looks or fairly copy has more. Forever from gone which or that having a with some having the work wrong generator design a fantasy way convincing. Working in dummy not now happily but to it of happily story want those kind looking right words business it generator language are. A you anything sets fake sets kind notes meeting having has in copy realistic is you. Copy or fairly set story. Wrong and days not work of want piece options unrelated way random just just recipes. Your recipes gardening start fairly. Happily start game days want from in set meeting that forever random. Support has wrong than your language are random business a even design has. Way design dummy unrelated set generator game convincing. Text contentwise copy to of set kind notes a you ?looks? gone work. Way forever result you to not. Your your meeting generator way placeholder looking than has want in repetitive more kind start has you but language a. A than notes name story and a just days some with in options looking just not are want looks. Kind some from review even. Some start random meeting recipes is a a ?looks? unrelated more the about but are dummy. Words review fake now kind of you meeting it design your. To just a about to. Not realistic name from with fake is. Work even business options fake wrong result notes want the more has dummy a notes random. Gone right repetitive fairly want now it want days review. Has notes want random name that random fantasy not unrelated in is dummy work work random game design now. Business result a and piece from working. Your some recipes copy sets are has kind story support fantasy has and some fantasy a which anything are the. Language piece that kind copy right anything dummy a of copy which fantasy placeholder which the work are convincing random. Your gone way copy you copy are that game but looking gardening result is start text the words the a anything. Want piece set set fantasy generator sets a more are happily or ?looks? just the and sets not anything. Support to just start game work looks copy that in of but words placeholder support now fairly fake even now. Text adequate words not fairly looks from game that result name realistic or you fake working want. Kind you some looking of review has sets than want the way working has. Of fantasy gardening and kind just game those adequate your from or text are you story working happily. Business set way gardening more dummy want are you business ?looks? work to placeholder are design options sets having. Working from options work right not meeting story it is of which way fake meeting. Adequate story than words want the anything. Language some gone random or just fairly gone which adequate sets having and adequate or text random from review. From unrelated those a start the ?looks? game business. With copy and which set kind game contentwise which anything the set story notes about or forever. Way anything work ?looks? a contentwise adequate and meeting. Options which realistic words it of to right game random way random your those and those anything some you notes gone gardening dummy than fake. But language just a your work with that set the. Are dummy business story not gardening start wrong fantasy fake and words having text which recipes your ?looks? wrong or. Generator fake than set looking text now forever more design ?looks? text but than has than wrong. Way than fake gardening those a now it language but piece. A is even looks just result that which realistic gone are working right fake some. Which language wrong having with that looks. 执行结果如下所示\nright : 9 Fantasy : 1 review : 5 convincing : 2 is : 8 Business : 2 even : 1 Are : 1 even : 10 start : 10 // 此处省略数行  二、统计用户的视频上传数 场景分析 接下来使用 Spark 来统计 Youtube 的测试数据集中每个用户的视频上传数量。稍加分析，会发现统计每个用户的视频数量其实与 WordCount 中统计每个单词出现的次数的逻辑几乎一致，区别在于处理 Youtube 测试数据集的格式略为复杂些。将给定的数据集按行划分，每行代表一条记录，除了视频类别这一字段中间有可能出现空格之外，其他的字段都是用空格分割。可以考虑使用正则表达式来匹配记录，并提取所需要的信息。\n在测试数据集中，假定每行所代表的视频都是唯一的，所以仅仅需要用户 ID 这一条信息。在提取到用户 ID 之后，可以像 WordCount 一样，组成 \u0026lt;ID, 1\u0026gt; 这样的用来计数的键值对，这步之后的逻辑便与 WordCount 相似了。\nJava 实现 1import org.apache.spark.SparkConf; 2import org.apache.spark.api.java.JavaPairRDD; 3import org.apache.spark.api.java.JavaRDD; 4import org.apache.spark.api.java.JavaSparkContext; 5import scala.Tuple2; 6 7import java.util.ArrayList; 8import java.util.List; 9import java.util.regex.Matcher; 10import java.util.regex.Pattern; 11 12public class SparkDemo { 13 private static final Pattern EXTRACT = Pattern.compile(\u0026#34;(\\\\S+)\\\\s+(\\\\S+)\\\\s+(\\\\d+)\\\\s+(\\\\D+[a-zA-Z])\\\\s+(\\\\d+)\\\\s+(\\\\d+)\\\\s+(\\\\d+\\\\.?\\\\d*)\\\\s+(\\\\d+)\\\\s+(\\\\d+)\\\\s+(.*)\u0026#34;); 14 15 public static void main(String[] args) { 16 SparkConf conf = new SparkConf().setAppName(\u0026#34;CountUploader\u0026#34;); 17 JavaSparkContext sc = new JavaSparkContext(conf); 18 19 JavaRDD\u0026lt;String\u0026gt; lines = sc.textFile(args[0]); 20 JavaRDD\u0026lt;String\u0026gt; filtered = lines.filter(s -\u0026gt; EXTRACT.matcher(s).matches()); 21 JavaPairRDD\u0026lt;String, String\u0026gt; records = filtered.mapToPair(s -\u0026gt; { 22 Matcher m = EXTRACT.matcher(s); 23 boolean result = m.matches(); 24 return new Tuple2\u0026lt;\u0026gt;(m.group(2), m.group(1)); 25 }); 26 JavaPairRDD\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; groups = records.groupByKey().mapToPair(t -\u0026gt; { 27 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); 28 t._2().forEach(list::add); 29 return new Tuple2\u0026lt;\u0026gt;(t._1(), list); 30 }); 31 // 手动实现 sortBy 操作 32 JavaRDD\u0026lt;Tuple2\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt;\u0026gt; tops = groups.keyBy(t -\u0026gt; t._2().size()).sortByKey(false).values(); 33 List\u0026lt;Tuple2\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt;\u0026gt; topList = tops.take(100); 34 35 for (Tuple2\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; t : topList) { 36 System.out.println(\u0026#34;User: \u0026#34; + t._1() + \u0026#34;, Number of videos: \u0026#34; + t._2().size()); 37 } 38 sc.stop(); 39 } 40} 执行 将上述代码生成 Jar 包之后，将其放到服务器中，执行下面的命令即可开始运行。\n1./bin/spark-submit --class SparkDemo ~/Documents/SparkDemo.jar ~/Documents/YoutubeDataSets.txt 执行结果如下所示\nUser: machinima, Number of videos: 21 User: hotforwords, Number of videos: 19 User: theevang1, Number of videos: 19 User: kushtv, Number of videos: 19 User: supermac18, Number of videos: 18 User: NBA, Number of videos: 18 User: somedia, Number of videos: 17 User: tokiohotelchannel, Number of videos: 17 User: AtheneWins, Number of videos: 16 User: davidisbetterthenyou, Number of videos: 16 // 此处省略数行  参考文章  RDD Operations Spark 函数详解系列之 RDD 基本转换 Spark 教程之 RDD 操作-转换和执行（示例） Spark 笔记-玩转 RDD 操作 RDD Aggregate in spark 利用开发工具 IntelliJ IDEA 编写 Spark 应用程序（Scala+Maven）  ","date":"2020-10-23T20:00:00+08:00","permalink":"https://example.com/posts/spark-distributed-programming/","title":"Spark 分布式内存计算框架"},{"content":"词频统计程序示例 假设将一个英文文本大文件作为输入，统计文件中单词出现的频数。最基本的操作是把输入文件的每一行传递给 map 函数完成对单词的拆分并输出中间结果，中间结果为 \u0026lt;word, 1\u0026gt; 的形式， 表示程序对一个单词，都对应一个计数 1。使用 reduce 函数收集 map 函数的结果作为输入值，并生成最终 \u0026lt;word, count\u0026gt; 形式的结果，完成对每个单词的词频统计。它们对应 MapReduce 处理数据流程如上图所示。\nMapReduce 程序的运行过程 如图所示，MapReduce 运行阶段数据传递经过输入文件、Map 阶段、中间文件、 Reduce 阶段、输出文件五个阶段，用户程序只与 Map 阶段和 Reduce 阶段的 Worker 直接相关，其他事情由 Hadoop 平台根据设置自行完成。\n从用户程序 User Program 开始，用户程序 User Program 链接了 MapReduce 库，实现了最基本的 map 函数和 reduce 函数。\n MapReduce 库先把 User Program 的输入文件划分为 M 份，如上图左方所示，将数据分成了分片 0~4，每一份通常为 16MB~64MB；然后使用 fork 将用户进程复制到集群内其他机器上。 User Program 的副本中有一个 Master 副本和多个 Worker 副本。Master 是负责调度的，为空闲 Worker 分配 Map 作业或者 Reduce 作业。 被分配了 Map 作业的 Worker，开始读取对应分片的输入数据, Map 作业数量与输入文件划分数 M 相同，并与分片一一对应; Map 作业将输入数据转化为键值对表示形式并传递给 map 函数，map 函数产生的中间键值对被缓存在内存中。 缓存的中间键值对会被定期写入本地磁盘，而且被分为 R 个区（R 的大小是由用户定义的），每个区会对应一个 Reduce 作业；这些中间键值对的位置会被通报给 Master, Master 负责将信息转发给 Reduce Worker。 Master 通知分配了 Reduce 作业的 Worker 负责数据分区，Reduce Worker 读取键值对数据并依据键排序，使相同键的键值对聚集在一起。同一个分区可能存在多个键的键值对，而 reduce 函数的一次调用的键值是唯一的， 所以必须进行排序处理。 Reduce Worker 遍历排序后的中间键值对，对于每个唯一的键，都将键与关联的值传递给 reduce 函数，reduce 函数产生的输出会写回到数据分区的输出文件中。 当所有的 Map 和 Reduce 作业都完成了，Master 唤醒 User Program，MapReduce 函数调用返回 User Program。  执行完毕后，MapReduce 的输出放在 R 个分区的输出文件中，即每个 Reduce 作业分别对应一个输出文件。用户可将这 R 个文件作为输入交给另一个 MapReduce 程序处理，而不需要主动合并这 R 个文件。在 MapReduce 计算过程中，输入数据来自分布式文件系统，中间数据放在本地文件系统，最终输出数据写入分布式文件系统。\n必须指出 Map 或 Reduce 作业和 map 或 reduce 函数存在以下几个区别:\n Map 或 Reduce 作业是从计算框架的角度来认识的，而 map 或 reduce 函数是需要程序员编写代码完成的，并在运行过程中被对用 Map 或 Reduce 作业调度; Map 作业处理一个输入数据的分片，可能需要多次调用 map 函数来处理输入的键值对; Reduce 作业处理一个分区的中间键值对，期间要对每个不同的键调用一次 reduce 函数，一个 Reduce 作业最终对应一个输出文件。  经典 MapReduce 任务调度模型 经典 MapReduce 任务调度模型采用主从结构（Master/Slave），包含四个组成部分：Client、JobTracker、TaskTracker、Task。支撑 MapReduce 计算框架的是 JobTracker 和 TaskTracker 两类后台进程。框架结构如下图所示。\n Client 每一个 Job 在 Ciat 端将运行 MapRecdce 程序所需要的所有 Jar 文件和类的集合，打包成一个 Jar 文件存储在 HDFS 中，并把文件路径提交到 JobTracker。 JobTracker JobTracker 主要负责资源的监控和作业调度，一个 Hadoop 集群只有一个 JobTracker，并不参与具体的计算任务。根据提交的 Job，JobTackor 会创建一系列 Task（即 MapTask、ReduceTask），分发到每个 TaskTracker 服务中去执行。常用的作业调度算法主要包括 FIFO(First In First Out) 调度器（默认）、公平调度器、容量调度器等。 TaskTracker TaskTracker 主要负责汇报心跳和执行 JobTracker 分发的任务。TaskTracker 会周期性地通过 HeartBeat 将本节点上资源的使用情况和任务的运行进度汇报给 JobTracker，JobTracker 会根据心跳信息和当前作业运行情况为 TaskTracker 下达任务，主要包括启动任务、提交任务、杀死任务和重新初始化命令等。 Task Task 分为 MapTask 和 ReduceTask 两种，均由 TaskTracker 启动，执行 JobTracker 分发的任务。MapTask 解析每条数据记录，传递给用户编写的 map 函数并执行，最后将输出结果写入 HDFS；ReduceTask 从 MapTask 的执行结果中，对数据进行排序，将数据按分组传递给用户编写的 reduce 函数执行。  TaskTracker 分布在 Map-Reduce 集群每个节点上，主要是监视所在机器的资源情况和当前机器的 tasks 运行状况。TaskTracker 通过 HeartBeat 发送给 JobTracker，JobTracker 会根据这些信息给新提交的 job 分配计算节点。经典 MapReduce 框架 MR V1 模型简单直观，但是不能满足大规模集群任务调度的需要。主要表现为以下四点:\n JobTracker 是 MapReduce 的集中处理点，存在单点故障问题； 当 MapRcduce job 非常多的时候，会造成很大的内存开销，就增加了 JobTracker 失败的风险，业界普遍认为该调度模型支持的上限为 4000 个节点; 在 TaskTracker 端，以 Map/Reduce Task 的数目作为资源的表示过于简单，没有考虑到 CPU/内存的占用情况，如果两个大内存消耗的 Task 被调度到一起， 就很容易出现内存消耗殆尽的问题; TaskTracker 把资源强制划分为 Map Task Slot 和 Reduce Task Slot，如果当系统中只有 Map Task 或者只有 Reduce Task 时，会造成资源的浪费，导致集群资源利用不足。  YARN 框架原理及运行机制 为了从根本上解决经典 MapReduce 框架的性能瓶颈，Hadoop 的 MapReduce 框架完全重构，叫做 YARN 或者 MR V2。\nYARN 的基本思想就是将经典调度框架中 JobTracker 的资源管理和任务调度/监控功能分离成两个单独的组件，即一个全局的资源管理器 ResoureManager 和每个应用程序特有的 ApplicationMaster。ResoureManager 负责整个系统资源的管理和分配，而 ApplicationMaster 则负责单个应用程序的资源管理。\nYARN 调度框架包括 ResourceManager、ApplicationMaster、NodeMananger 及 Container 等组件概念。\nResourceManager 是基于应用程序对资源的需求进行调度的。每一个应用程序需要不同类型的资源，因此就需要不同的容器。这些资源包括内存、CPU、磁盘、网络等。 ApplicationMaster 负责向调度器申请、释放资源，清求 NodeManager 运行任务、跟踪应用程序的状态和监控它们的进程。\nNodeManager 是 YARN 中单个节点的代理，负责与应用程序的 ApplicationMaster 和集群管理者 ResourceManager 交互；从 ApplicationMaster 上接收有关 Container 的命令并执行（例如，启动、停止 Container）；向 ResourceManager 汇报各个 Container 执行状态和节点健康状况，并读取有关 Container 的命令；执行应用程序的容器、监控应用程序的资源使用情况并且向 ResourceManager 调度器汇报。\nContainer 是 YARN 中资源的抽象，它封装了节点上一定量的资源（CPU 和内存等）。一个应用程序所需的 Container 分为两类：一类是运行 ApplicationMaster 的 Container，是由 ResourceManager（向内部的资源调度器）申请和启动的，用户提交应用程序时，可指定唯一的 ApplicationMaster 所需的资源；另一类是运行各类任务的 Container，是由 ApplicationMaster 向 ResourceManager 申请的，并由 ApplicationMaster 与 NodeManager 通信后启动。\n用户向 YARN 提交一个应用程序后，YARN 将分为两个阶段运行该应用程序：第一个阶段是启动 ApplicationMaster；第二个阶段是由 ApplicationMaster 创建应用程序，为它申请资源，并监控它的整个运行过程，直到运行成功。\nYARN 任务调度流程如下图所示。\n 用户向 YARN 提交应用程序； ResourceManager 为该应用程序在某个 NodeManagr 分配一个 Container，并要求 NodeManager 启动应用程序的 ApplicationMaster； ApplicationMaster 启动后立即向 ResourceManager 注册，此时用户可以直接通过 ResourceManager 查看应用程序的运行状态，然后它将为各个任务申请分布在某些 NodeManager 上的容器资源，并监控它的运行状态（步骤 4~7），直到运行结束； ApplicationMaster 采用轮询的方式向 ResourceManager 申请和领取资源； ApplicationMaster 申请到资源后，即与资源容器所在的 NodeManager 通信，要求其在容器内启动任务; NodeManager 为任务初始化运行环境（包括环境变量、jar 包、二进制程序等)，启动任务； 运行各个任务的容器通过向 ApplicationMaster 汇报自己的状态和进度，使 ApplicationMaster 随时掌握各个任务的运行状态，从而可以在任务失败时重新启动任务。用户可以向 ApplicationMaster 查询应用程序的当前运行状态； 应用程序运行完成后，ApplicationMaster 向 ResourceManager 注销并关闭。  YARN 框架和经典的 MRV1 调度框架相比，主要有以下优化：\n ApplicationMaster 使得检测每一个 Job 子任务状态的程序分布式化，减少了 JobTracker 资源消耗； 在 YARN 中，用户可以对不同的编程模型写自己的 ApplicationMaster, 可以让更多类型的编程模型运行在 Hadoop 集群上，如 Spark 基于内存的计算模型； Container 提供 Java 虚拟机内存的隔离，优化了经典调度框架中 Map Slot 和 Reduce Slot 分开造成集群资源闲置的不足。  Youtube 数据集统计分析 本例的数据来自于 Youtube 的数据集，完整的数据集以及源代码下载地址请点击以下链接 https://github.com/sudrizzz/BigDataTechnologyFoundation-SourceCodeAndDataSet/blob/main/ch04\n该数据集各字段的具体含义如表所示：\n   字段名 解释及数据类型     video ID 视频 ID：每个视频存在唯一的 11 位字符串   uploader 上传者用户名：字符串类型   age 视频上传日期与 2007 年 2 月 15 日（YouTube 创立日）的间隔天数：整数值   category 视频类别：字符串类型   length 视频长度：整数值   views 浏览量：整数值   rate 视频评分：浮点值   ratings 评分次数：整数值   comments 评论数：整数值   related IDs 相关视频 ID，每个相关视频的 ID 均为单独的一列：字符串类型    视频类型统计 场景：从已经上传的视频中，统计每一个视频类型下的视频数量。下表所示为数据集数据格式示例。category 列代表了视频类型，因而 map 函数只需逐行读取，返回视频类型为键和数字 1 为值的键值对，再传给 reduce 函数处理即可。map 函数的输入键依然为文本文件中行的偏移量，值为行内容。reduce 函数输出键值对为视频类型和该视频类型中的视频数量。\n   video ID uploader age category length views rate ratings comments Related IDs     PRGUU_ggO3k tom 704 Entertainment 262 11235 3.86 247 280 tpAL3iOurl4\u0026hellip;ifn1njiY4s   RX24KLBhwMI jsack 687 Blogs 512 24149 4.22 315 474 PkGUU_ggO3k\u0026hellip;tpAl3iOurl4    Mapper 类代码实现 1public static class Map extends Mapper\u0026lt;LongWritable, Text, Text, IntWritable\u0026gt; { 2 private static final IntWritable ONE = new IntWritable(1); 3 private final Text tx = new Text(); 4 5 public void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException { 6 String line = value.toString(); 7 String[] str = line.split(\u0026#34;\\t\u0026#34;); 8 if (str.length \u0026gt; 3) { 9 this.tx.set(str[3]); 10 } 11 context.write(this.tx, ONE); 12 } 13} 第 2 行构造 IntWritable 可持久化对象并赋值为 1；第 8~10 行过滤字段，将一条记录中的分类 category 作为 map 函数的 value 输出。\nReduce 类代码实现 1public static class Reduce extends Reducer\u0026lt;Text, IntWritable, Text, IntWritable\u0026gt; { 2 public void reduce(Text key, Iterable\u0026lt;IntWritable\u0026gt; values, Context context) throws IOException, InterruptedException { 3 int sum = 0; 4 for (IntWritable v : values) { 5 sum += v.get(); 6 } 7 context.write(key, new IntWritable(sum)); 8 } 9} reduce 函数接收 Map 阶段传来的键值对，第 3~6 行遍历每一组记录，累加同一视频类型下的视频数量，第 7 行通过 context 输出计算结果。\n运行  通过 IDEA-Build-Build Artifacts 功能将代码打包为 jar 文件，命名为 CategoryCount.jar 登录 Hadoop 集群，将数据集文件 YoutubeDataSets.txt 传到 HDFS 下 /tmp 目录下 执行如下命令，开始运行程序  1hadoop jar CategoryCount.jar CategoryCount /tmp/YoutubeDataSets.txt /tmp/output 执行如下命令，查看各类别视频数量  1hadoop fs -cat /tmp/output/part-r-00000 可以得到如下输出\nUNA\t32 Autos \u0026amp; Vehicles\t77 Comedy\t420 Education\t65 Entertainment\t911 Film \u0026amp; Animation\t261 Howto \u0026amp; Style\t138 Music\t870 News \u0026amp; Politics\t343 Nonprofits \u0026amp; Activism\t43 People \u0026amp; Blogs\t399 Pets \u0026amp; Animals\t95 Science \u0026amp; Technology\t80 Sports\t253 Travel \u0026amp; Events\t113  ","date":"2020-10-17T20:00:00+08:00","permalink":"https://example.com/posts/mapreduce-distributed-programming/","title":"MapReduce 分布式编程"},{"content":" 本文所有代码均可在 https://github.com/sudrizzz/HDFSOperations 查看。\n 通过命令行访问 HDFS 命令行是最简单、最直接操作文件的方式。这里介绍通过诸如读取文件、新建目录、移动文件、删除数据、列出目录等命令来进一步认识 HDFS。也可以输入 hadoop fs -help 命令获取每个命令的详细帮助。若熟悉 Linux 命令，Hadoop 命令看起来非常直观且易于使用。\n对文件和目录的操作 通过命令行对 HDFS 文件和目录的操作主要包括：创建、浏览、删除文件和目录，以及从本地文件系统与 HDFS 文件系统互相拷贝等。常用命令格式如下。\n1hadoop fs -ls \u0026lt;path\u0026gt; # 列出 path 目录下的所有内容（文件和目录） 2hadoop fs -lsr \u0026lt;path\u0026gt; # 递归列出 path 下的所有内容（文件或目录） 3hadoop fs -df \u0026lt;path\u0026gt; # 查看目录的使用情况 4hadoop fs -du \u0026lt;path\u0026gt; # 显示目录中所有文件及目录大小 5hadoop fs -touchz \u0026lt;path\u0026gt; # 创建一个路径为为 path 的 0 字节的 HDFS 空文件 6hadoop fs -mkdir \u0026lt;path\u0026gt; # 查看目录的使用情况 7hadoop fs -rm [-skipTrash] \u0026lt;path\u0026gt; # 将 HDFS 上路径为 \u0026lt;path\u0026gt; 的文件移动到回收站，加上 -skipTrash，则直接删除 8hadoop fs -rmr [-skipTrash] \u0026lt;path\u0026gt; # 将 HDFS 上路径为 \u0026lt;path\u0026gt; 的目录以及目录下的文件移动到回收站。如果加上 -skipTrash，则直接删除 9hadoop fs -moveFromLocal \u0026lt;localsrc\u0026gt;...\u0026lt;dst\u0026gt; # 将 \u0026lt;localsrc\u0026gt; 本地文件移动到 HDFS 的 \u0026lt;dst\u0026gt; 目录下路径下 10hadoop fs -moveToLocal [-crc] \u0026lt;src\u0026gt; \u0026lt;localdst\u0026gt; # 将 HDFS 上路径为 \u0026lt;src\u0026gt; 的文件移动到本地 \u0026lt;localdst\u0026gt; 路径下 11hadoop fs -put \u0026lt;localsrc\u0026gt;...\u0026lt;dst\u0026gt; # 从本地文件系统中复制单个或者多个源路径到目标文件系统 12hadoop fs -cat \u0026lt;src\u0026gt; # 浏览 HDFS 路径为 \u0026lt;src\u0026gt; 的文件的内容 修改权限或用户组 HDFS 提供了一些命令可以用来修改文件的权限、所属用户以及所属组别，具体格式如下:\n  hadoop fs -chmod [-R] \u0026lt;MODE [,MODE]...|OCTALMODE\u0026gt; PATH...\n改变 HDFS 上路径为 PATH 的文件的权限，R 选项表示递归执行该操作。\n例如: hadoop fs -chmod -R +r /user/test，表示将 /user/test 目录下的所有文件赋予读的权限\n  hadoop fs -chown [-R][OWNER][:[GROUP]]PATH...\n改变 HDFS 上路径为 PATH 的文件的所属用户，-R 选项表示递归执行该操作。\n例如: hadoop fs -chown -R hadoop:hadoop /user/test，表示将 /user/test 目录下所有文件的所属用户和所属组别改为 hadoop\n  hadoop fs -chgrp ［-R] GROUP PATH...\n改变 HDFS 上路径为 PATH 的文件的所属组别，-R 选项表示递归执行该操作。\n例如: hadoop fs -chown -R hadoop /user/test 表示将 /user/test 目录下所有文件的所属组别改为 hadoop\n  其他命令 HDFS 除了提供上述两类操作之外，还提供许多实用性较强的操作，如显示指定路径上的内容，上传本地文件到 HDFS 指定文件夹，以及从 HDFS 上下载文件到本地等命令。\n  hadoop fs -tail [-f] \u0026lt;file\u0026gt;\n显示 HDFS 上路径为 \u0026lt;file\u0026gt; 的文件的最后 1KB 的字节，-f 选项会使显示的内容随着文件内容更新而更新。\n例如: hadoop fs -tail -f /user/test.txt\n  hadoop fs -stat [format] \u0026lt;path\u0026gt;\n显示 HDFS 上路径为 \u0026lt;path\u0026gt; 的文件或目录的统计信息。格式为：%b 文件大小，%n 文件名，%r 复制因子，%y、%Y 修改日期。\n例如：hadoop fs -stat %b %n %o %r /user/test\n  hadoop fs -put \u0026lt;localsrc\u0026gt;...\u0026lt;dt\u0026gt;\n将 \u0026lt;localsrc\u0026gt; 本地文件上传到 HDFS 的 \u0026lt;dst\u0026gt; 目录下。\n例如: hadoop fs -put /home/hadoop/test.txt /user/hadoop\n  hadoop fs -count [-q] \u0026lt;path\u0026gt;\n显示 \u0026lt;path\u0026gt; 下的目录数及文件数，输出格式为”目录数 文件数 大小 文件名“，加上 -q 可以查看文件索引的情况。\n例如: hadoop fs -count /\n  hadoop fs -get [-ignoreCrc] [-crc] \u0026lt;src\u0026gt; \u0026lt;localdst\u0026gt;\n将 HDFS 上 \u0026lt;src\u0026gt; 的文件下载到本地的 \u0026lt;localdst\u0026gt; 目录，可用 -ignorecrc 选项复制 CRC 校验失败的文件，使用 -crc 选项复制文件以及 CRC 信息。\n例如: hadoop fs -get /user/hadoop/a.txt /home/hadoop\n  hadoop fs -getmerge \u0026lt;src\u0026gt; \u0026lt;localdst\u0026gt; [addnl]\n将 HDFS 上 \u0026lt;src\u0026gt; 目录下的所有文件按文件名排序并合并成一个文件输出到本地的 \u0026lt;localdst\u0026gt; 目录，addnl 是可选的，用于指定在每个文件结尾添加一个换行符。\n例如: hadoop fs -getmerge /user/test /home/hadoop/o\n  hadoop fs -test -[ezd] \u0026lt;path\u0026gt;\n检查 HDFS 上路径为 \u0026lt;path\u0026gt; 的文件。-e 检查文件是否存在，如果存在则返回 0。-z 检查文件是否为 0 字节，如果是则返回 0。-d 检查路径是否是目录，如果是则返回 1，否则返回 0。\n例如：hadoop fs -test -e /user/test.txt\n  通过 Java API 访问 HDFS 使用 Hadoop URL 读取数据 要从 Hadoop 文件系统读取数据，最简单的方法是使用 java.net.URL 对象打开数据流，从中读取数据。\n让 Java 程序能够识别 Hadoop 的 HDFS URL 方案还需要一些额外的工作，这里采用的方法是通过 org.apache.hdfs.FsUrlStreamHandlerFactor 实例调用 java.net.URL 对象的 setURLStreamHandlerFactory 实例方法。每个 Java 虚拟机只能调用一次这个方法，因此通常在静态方法中调用。下述范例展示的程序以标准输出方式显示 Hadoop 文件系统中的文件，类似于 UNIX 中的 cat 命令。\n1import org.apache.hadoop.fs.FsUrlStreamHandlerFactory; 2import org.apache.hadoop.io.IOUtils; 3 4import java.io.InputStream; 5import java.net.URL; 6 7public class URLCat { 8 static { 9 URL.setURLStreamHandlerFactory(new FsUrlStreamHandlerFactory()); 10 } 11 12 public static void main(String[] args) throws Exception{ 13 InputStream inputStream = null; 14 try { 15 inputStream = new URL(args[0]).openStream(); 16 IOUtils.copyBytes(inputStream, System.out, 4096, false); 17 } finally { 18 IOUtils.closeStream(inputStream); 19 } 20 } 21} 编译代码，导出为 URLCat.jar 文件，并在 /user/hadoop/ 中准备一个测试文件 test，然后执行命令：\n1hadoop jar hdfsclient.jar URLCat hdfs://master:9000/user/hadoop/test 执行完成后可以在屏幕上看到 /user/hadoop/test 文件中的内容。该程序是从 HDFS 读取文件的最简单的方式，即用 java.net.URL 对象打开数据流。其中，第 8~10 行静态代码块的作用是设置 URL 类能够识别 Hadoop 的 HDFS URL。第 16 行 IOUtils 是 Hadoop 中定义的类，调用其静态方法 copyBytes 实现从 HDFS 文件系统拷贝文件到标准输出流。4096 表示用来拷贝的缓冲区大小，false 表示拷贝完成后不关闭拷贝源。\n通过 FileSystem API 读取数据 在实际开发中，访问 HDFS 最常用的类是 FileSystem 类。Hadoop 文件系统中通过 Hadoop Path 对象来定位文件。可以将路径视为一个 Hadoop 文件系统 URI，如 hdfs:localhost/user/hadoop/test。FileSystem 是一个通用的文件系统 API，获取 FileSystem 实例有下面几个静态方法:\n1public static FileSystem get(Configuration conf) throws IOException 2public static FileSystem get(URI uri,Configuration conf) throws IOException 3public static FileSystem get(URI uri, Configuration conf, String user) throw IOException 下面分别给出几个常用操作的代码示例。\n读取文件 1@Test 2public void readFile() throws Exception { 3 String uri = \u0026#34;hdfs://master:9000/user/hadoop/test\u0026#34;; 4 Configuration configuration = new Configuration(); 5 FileSystem fileSystem = FileSystem.get(URI.create(uri), configuration); 6 InputStream in = null; 7 try { 8 in = fileSystem.open(new Path(uri)); 9 IOUtils.copyBytes(in, System.out, 4096, false); 10 } finally { 11 IOUtils.closeStream(in); 12 } 13} 上述代码直接使用 FileSystem 以标准输出格式显示 Hadoop 文件系统中的文件。\n第 4 行产生一个 Confguation 类的实例，代表了 Hadoop 平台的配置信息，并在第 5 行作为引用传递到 FileSystem 的静态方法 get 中，产生 FileSystem 对象。\n第 9 行与上例类似，调用 Hadoop 中 IOUtils，并在 finally 字中关闭数据流，同时也可以在输入流和输出流之间复制数据。copyBytes 方的最后两个参数，第一个设置用于复制的缓冲区大小，第二个设置复制结束后是否关闭数据流。\n写入文件 1@Test 2public void writeFile() throws Exception { 3 String source = \u0026#34;C:\\\\Users\\\\Desktop\\\\test\u0026#34;; 4 String destination = \u0026#34;hdfs://master:9000/user/hadoop/test2\u0026#34;; 5 BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(source)); 6 Configuration configuration = new Configuration(); 7 FileSystem fileSystem = FileSystem.get(URI.create(destination), configuration); 8 OutputStream outputStream = fileSystem.create(new Path(destination)); 9 IOUtils.copyBytes(inputStream, outputStream, 4096, true); 10} 创建目录 1@Test 2public void createFolder() throws Exception { 3 String uri = \u0026#34;hdfs://master:9000/user/test\u0026#34;; 4 Configuration configuration = new Configuration(); 5 FileSystem fileSystem = FileSystem.get(URI.create(uri), configuration); 6 Path path = new Path(uri); 7 fileSystem.mkdirs(path); 8 fileSystem.close(); 9} 删除文件或目录 1@Test 2public void deleteFile() throws Exception { 3 String uri = \u0026#34;hdfs://master:9000/user/hadoop/test2\u0026#34;; 4 Configuration configuration = new Configuration(); 5 FileSystem fileSystem = FileSystem.get(URI.create(uri), configuration); 6 Path path = new Path(\u0026#34;hdfs://master:9000/user/hadoop\u0026#34;); 7 boolean isDeleted = fileSystem.delete(path, true); 8 System.out.println(isDeleted); 9 fileSystem.close(); 10} 使用 FileSystem 的 delete() 方法可以永久性删除文件或目录。如果要递归删除文件夹，则需要将其第二个参数设为 true。\n列出文件或目录 1@Test 2public void listFiles() throws Exception { 3 String uri = \u0026#34;hdfs://master:9000/user\u0026#34;; 4 Configuration configuration = new Configuration(); 5 FileSystem fileSystem = FileSystem.get(URI.create(uri), configuration); 6 Path path = new Path(uri); 7 FileStatus[] status = fileSystem.listStatus(path); 8 for (FileStatus fileStatus : status) { 9 System.out.println(fileStatus.getPath().toString()); 10 } 11 fileSystem.close(); 12} 文件系统的重要特性是提供浏览和检索其目录结构下所存文件与目录相关信息的功能。 FileStatus 类封装了文件系统中文件和目录的元数据，例如文件长度、块大小、副本、修改时间、所有者以及权限信息等。编译运行上述代码后控制台将会打印出 /user 目录下的名称或者文件名。\n小结 HDFS 组成部分  HDFS 是一个分布式文件存储系统 Client 提交读写请求（拆分 blocksize） NameNode 全局把控（存储数据位置） DataNode 存储数据（将数据存储进去，且以 Pipeline 的方式把数据写完）  HDFS 数据交互 写入数据  使用 HDFS 提供的客户端 Client，向远程的 NameNode 发起 RPC 请求 NameNode 会检查要创建的文件是否已经存在，创建者是否有权限进行操作，成功则会为文件创建一个记录，否则会让客户端抛出异常 当客户端开始写入文件的时候，客户端会将文件切分成多个 packets，并在内部以数据队列 data queue（数据队列） 的形式管理这些 packets，并向 NameNode 申请 blocks，获取用来存储 replicas 的合适的 DataNode 列表，列表的大小根据 NameNode 中 replication（副本份数）的设定而定 开始以 pipeline（管道）的形式将 packet 写入所有的 replicas 中。客户端把 packet 以流的方式写入第一个 DataNode，该 DataNode 把该 packet 存储之后，再将其传递给在此 pipeline 中的下一个 DataNode，直到最后一个 DataNode，这种写数据的方式呈流水线的形式 最后一个 DataNode 成功存储之后会返回一个 ack packet（确认队列），在 pipeline 里传递至客户端，在客户端的开发库内部维护着 \u0026ldquo;ack queue\u0026rdquo;，成功收到 DataNode 返回的 ack packet 后会从 \u0026ldquo;data queue\u0026rdquo; 移除相应的 packet 如果传输过程中，有某个 DataNode 出现了故障，那么当前的 pipeline 会被关闭，出现故障的 DataNode 会从当前的 pipeline 中移除，剩余的 block 会继续剩下的 DataNode 中继续以 pipeline 的形式传输，同时 NameNode 会分配一个新的 DataNode，保持 replicas 设定的数量。 客户端完成数据的写入后，会对数据流调用 close() 方法，关闭数据流 只要写入了 dfs.replication.min（最小写入成功的副本数）的复本数（默认为 1），写操作就会成功，并且这个块可以在集群中异步复制，直到达到其目标复本数（dfs.replication 的默认值为 3），因为 NameNode 已经知道文件由哪些块组成，所以它在返回成功前只需要等待数据块进行最小量的复制  读取数据  客户端调用 FileSystem 实例的 open 方法，获得这个文件对应的输入流 InputStream 通过 RPC 远程调用 NameNode，获得 NameNode 中此文件对应的数据块保存位置，包括这个文件的副本的保存位置（主要是各 DataNode 的地址） 获得输入流之后，客户端调用 read 方法读取数据。选择最近的 DataNode 建立连接并读取数据 如果客户端和其中一个 DataNode 位于同一机器（比如 MapReduce 过程中的 mapper 和 reducer)，那么就会直接从本地读取数据 到达数据块末端，关闭与这个 DataNode 的连接，然后重新查找下一个数据块 不断执行第 2~5 步直到数据全部读完 客户端调用 close，关闭输入流 DFS InputStream  HDFS 漫画  以上漫画版权均归原图作者所有\n 参考文章 https://www.cnblogs.com/qingyunzong/p/8548806.html\n","date":"2020-10-12T15:20:11+08:00","permalink":"https://example.com/posts/hdfs-file-system/","title":"HDFS 文件管理"},{"content":"前言 本系列文章是基于《大数据技术基础》与 10 小时入门大数据 课程，如果有兴趣可以先阅读该书并观看视频教程。本系列文章中所用到的软件版本及其下载地址如下：\n   名称 版本 下载地址     CentOS 8.2.2004 https://mirrors.tuna.tsinghua.edu.cn/centos/8.2.2004/isos/x86_64/CentOS-8.2.2004-x86_64-minimal.iso   JDK 14.0.2 https://www.oracle.com/java/technologies/javase/jdk14-archive-downloads.html   Hadoop 2.10.1 https://www.apache.org/dyn/closer.cgi/hadoop/common/hadoop-2.10.1/hadoop-2.10.1-src.tar.gz    环境准备 配置网络 此篇文章所使用的 CentOS 环境均是使用 VMware 15 虚拟的，具体安装教程请查看 使用 VMware 15 安装虚拟机和使用 CentOS 8，此处不再赘述。安装好一个节点之后，我们可以采用“虚拟机克隆”的方式，直接完成另外两个节点系统的安装。\n虚拟机的网络配置采用 DHCP 自动分配模式，每台机器的 IP 地址可以通过命令 ip address 或 ifconfig 查看，其中 ifconfig 输出如下，第一组配置中 ens33 即为本机网络配置，inet 项对应的即为本机 ip（192.168.61.128）。\n1ens33: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500 2 inet 192.168.61.128 netmask 255.255.255.0 broadcast 192.168.61.255 3 inet6 fe80::20c:29ff:fe65:9052 prefixlen 64 scopeid 0x20\u0026lt;link\u0026gt; 4 ether 00:0c:29:65:90:52 txqueuelen 1000 (Ethernet) 5 RX packets 38037 bytes 6542757 (6.2 MiB) 6 RX errors 0 dropped 0 overruns 0 frame 0 7 TX packets 30479 bytes 16809162 (16.0 MiB) 8 TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 9 10lo: flags=73\u0026lt;UP,LOOPBACK,RUNNING\u0026gt; mtu 65536 11 inet 127.0.0.1 netmask 255.0.0.0 12 inet6 ::1 prefixlen 128 scopeid 0x10\u0026lt;host\u0026gt; 13 loop txqueuelen 1000 (Local Loopback) 14 RX packets 23656 bytes 13542580 (12.9 MiB) 15 RX errors 0 dropped 0 overruns 0 frame 0 16 TX packets 23656 bytes 13542580 (12.9 MiB) 17 TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 18 19virbr0: flags=4099\u0026lt;UP,BROADCAST,MULTICAST\u0026gt; mtu 1500 20 ether 52:54:00:d2:b3:31 txqueuelen 1000 (Ethernet) 21 RX packets 0 bytes 0 (0.0 B) 22 RX errors 0 dropped 0 overruns 0 frame 0 23 TX packets 0 bytes 0 (0.0 B) 24 TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 本篇文章中三台集群的 IP 分别如下，下文中不再赘述。\n   主机名 IP     master 192.168.61.128   slave1 192.168.61.129   slave2 192.168.61.131    配置 host 以上三台机器要搭建成为集群，就需要让它们互相认识。这个认识的过程是通过 /etc/hosts 文件来实现的。这一步需要修改每一台机器的 hosts 文件，将以下内容分别粘贴到各个机器的 hosts 文件中。\n1vim /etc/hosts 192.168.61.128 master 192.168.61.129 slave1 192.168.61.131 slave2 配置 JDK 因为 Hadoop 的环境依赖于 Java JDK，所以需要确保虚拟机中已经正确安装了 JDK，除此之外我们还需要将 JDK 地址配置到环境变量中。在本例中，我的 JDK 安装位置是 /usr/java/jdk-14.0.2。\n修改 bash_profile 1vim ~/.bash_profile 添加以下内容到 .bash_profile 文件末尾：\nexport JAVA_HOME=/usr/java/jdk-14.0.2 export PATH=$JAVA_HOME/bin:$PATH 修改完成并保存后，还需要执行 source 命令使环境变量立即生效。\n1source ~/.bash_profile 然后即可使用 java -version 检查环境变量是否配置成功，执行结果如下所示。\njava version \u0026quot;14.0.2\u0026quot; 2020-07-14 Java(TM) SE Runtime Environment (build 14.0.2+12-46) Java HotSpot(TM) 64-Bit Server VM (build 14.0.2+12-46, mixed mode, sharing) 配置 SSH 免密钥登录 在 Linux 集群间配置免密钥登录，是 Hadoop 集群运维的基础。以下操作在 master 节点进行，实现从 master 免密钥登录 slave1、slave2 节点。生成 ssh 密钥的命令如下：\n1ssh-keygen 生成过程中会有一些提示，一路回车即可。执行结果如下所示。\nroot@master:/usr/local/software# ssh-keygen Generating public/private rsa key pair. Enter file in which to save the key (/root/.ssh/id_rsa): /root/.ssh/id_rsa already exists. Overwrite (y/n)? y Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /root/.ssh/id_rsa. Your public key has been saved in /root/.ssh/id_rsa.pub. The key fingerprint is: SHA256:DC7+sETaazn0f4OVgxozjdw2XM1Tb60cqoaQvDGXpg8 root@master The key's randomart image is: +---[RSA 3072]----+ | | | . | | . o . ..| | . o . + . +| | oo.*S+ . + + | | =..% @ + . o | | ..=oE# = o | | .+==.o = | | .o..ooo . | +----[SHA256]-----+ 接下来需要将生成的公钥上传到 slave1 节点，命令如下：\n1ssh-copy-id root@slave1 首次通过 master 终端将公钥传给 salve 终端，需要输入 slave 节点的登录密码。上述命令中我们是传输到 slave1 的 root 账户下，所以需要输入 root 用户的密码，传送完毕即可实现免密码登录。执行结果如下。\nroot@master:/usr/local/software# ssh-copy-id root@slave1 /usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: \u0026quot;/root/.ssh/id_rsa.pub\u0026quot; /usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed /usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys root@slave1's password: Number of key(s) added: 1 Now try logging into the machine, with: \u0026quot;ssh 'root@slave1'\u0026quot; and check to make sure that only the key(s) you wanted were added. slave2 节点命令同上，只需更改传送到的节点名称，执行结果如下。\nroot@master:/usr/local/software# ssh-copy-id root@slave2 /usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: \u0026quot;/root/.ssh/id_rsa.pub\u0026quot; /usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed /usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys root@slave2's password: Number of key(s) added: 1 Now try logging into the machine, with: \u0026quot;ssh 'root@slave2'\u0026quot; and check to make sure that only the key(s) you wanted were added. 现在可以尝试登录子节点 slave1 和 slave2。\n1ssh root@slave1 成功登录 salve1 节点的提示如下。\nroot@master:/usr/local/software# ssh root@slave1 Web console: https://slave1:9090/ or https://192.168.61.129:9090/ Last login: Fri Sep 24 14:56:46 2020 from 192.168.61.1 完善配置 以下配置均在 master 节点上完成，配置完成后可直接复制到 slave 节点，以免重复劳动。\n安装 Hadoop 1cd /usr/local/software 2wget http://mirror.cogentco.com/pub/apache/hadoop/common/hadoop-2.10.1/hadoop-2.10.1-src.tar.gz 3tar -zxvf hadoop-2.10.1-src.tar.gz 4cd hadoop-2.10.1-src 5mv * ~/hadoop 在正式使用 Hadoop 集群之前，我们还需要对其配置文件进行修改。本节中的配置内容请以 官方文档 为准。\nHadoop 的配置文件均存放在 Hadoop 所在目录的 /etc/hadoop/ 文件夹下。\n修改配置文件 编辑 core-site.xml 文件 core-site.xml 用来配置 Hadoop 集群的通用属性，包括指定 NameNode 的地址、指定使用 Hadoop 时临时文件的存放路径、指定检查点备份日志的最长时间等。\n使用 vim 打开文件：\n1vim ~/hadoop-2.10.1/etc/hadoop/core-site.xml 使用以下内容替换 core-site.xml 中的内容：\n1\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; 2\u0026lt;?xml-stylesheet type=\u0026#34;text/xsl\u0026#34; href=\u0026#34;configuration.xsl\u0026#34;?\u0026gt; 3 4\u0026lt;configuration\u0026gt; 5 \u0026lt;!-- 指定 namenode 的地址 --\u0026gt; 6 \u0026lt;property\u0026gt; 7 \u0026lt;name\u0026gt;fs.defaultFS\u0026lt;/name\u0026gt; 8 \u0026lt;value\u0026gt;hdfs://master:9000\u0026lt;/value\u0026gt; 9 \u0026lt;/property\u0026gt; 10 11 \u0026lt;!-- 指定使用 Hadoop 时临时文件的存放路径 --\u0026gt; 12 \u0026lt;property\u0026gt; 13 \u0026lt;name\u0026gt;hadoop.tmp.dir\u0026lt;/name\u0026gt; 14 \u0026lt;value\u0026gt;/home/hadoop/temp\u0026lt;/value\u0026gt; 15 \u0026lt;/property\u0026gt; 16\u0026lt;/configuration\u0026gt; 第 6~9 行配置 fs.defaultFS 的属性为 hdfs://master:9000，master 是主机名；第 12~15 行指定 Hadoop 的临时文件夹为 /home/hadoop/temp，此文件夹用户可以自己指定。\n编辑 hdfs-site.xml 文件 hdfs-site.xml 用来配置分布式文件系统 HDFS 的属性，包括指定 HDFS 保存数据的副本数量，指定 HDFS 中 NameNode、DataNode 的存储位置等。\n使用 vim 打开文件：\n1vim ~/hadoop-2.10.1/etc/hadoop/hdfs-site.xml 使用以下内容替换 hdfs-site.xml 中的内容：\n1\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; 2\u0026lt;?xml-stylesheet type=\u0026#34;text/xsl\u0026#34; href=\u0026#34;configuration.xsl\u0026#34;?\u0026gt; 3 4\u0026lt;configuration\u0026gt; 5 \u0026lt;!-- 指定 HDFS 保存数据的副本数量 --\u0026gt; 6 \u0026lt;property\u0026gt; 7 \u0026lt;name\u0026gt;dfs.replication\u0026lt;/name\u0026gt; 8 \u0026lt;value\u0026gt;1\u0026lt;/value\u0026gt; 9 \u0026lt;/property\u0026gt; 10\u0026lt;/configuration\u0026gt; 其中，第 7~8 行，指定 HDFS 文件快的副本数为 1。数据块副本一般为 3 以上，本文章仅作示例，故指定为 1。\n编辑 yarn-site.xml YARN 是 MapReduce 的调度框架。文件 yarn-site.xml 用配置 YARN 的属性，包括指定 NameNodeManager 获取数据的方式，指定 ResourceManager 的地址，配置 YARN 打印工作日志等。\n使用 vim 打开文件：\n1vim ~/hadoop-2.10.1/etc/hadoop/yarn-site.xml 使用以下内容替换 yarn-site.xml 中的内容：\n1\u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; 2 3\u0026lt;configuration\u0026gt; 4 \u0026lt;!-- 指定 NameNodeManager 获取数据的方式是 shuffle --\u0026gt; 5 \u0026lt;property\u0026gt; 6 \u0026lt;name\u0026gt;yarn.nodemanager.aux-services\u0026lt;/name\u0026gt; 7 \u0026lt;value\u0026gt;mapreduce_shuffle\u0026lt;/value\u0026gt; 8 \u0026lt;/property\u0026gt; 9 \u0026lt;property\u0026gt; 10 \u0026lt;name\u0026gt;yarn.nodemanager.env-whitelist\u0026lt;/name\u0026gt; 11 \u0026lt;value\u0026gt;JAVA_HOME,HADOOP_COMMON_HOME,HADOOP_HDFS_HOME,HADOOP_CONF_DIR,CLASSPATH_PREPEND_DISTCACHE,HADOOP_YARN_HOME,HADOOP_MAPRED_HOME\u0026lt;/value\u0026gt; 12 \u0026lt;/property\u0026gt; 13 14 \u0026lt;!-- 指定 YARN 中 ResourceManager 所在的主机名 --\u0026gt; 15 \u0026lt;property\u0026gt; 16 \u0026lt;name\u0026gt;yarn.resourcemanager.hostname\u0026lt;/name\u0026gt; 17 \u0026lt;value\u0026gt;master\u0026lt;/value\u0026gt; 18 \u0026lt;/property\u0026gt; 19\u0026lt;/configuration\u0026gt; 其中，第 15~19 行配置了 ResourceManager 所在的主机名，如果不进行配置，将会导致 MapReduce 不能获得资源，任务不能执行。\n编辑 mapred-site.xml 文件 mapred-site.xml 主要是配置 MapReduce 的属性，主要是 Hadoop 系统提交的 Map/Reduce 程序运行在 YARN 上。\n首先复制一份 mapred-site.xml.template 文件为 mapred-site.xml，然后打开并进行修改。\n1vim ~/hadoop-2.10.1/etc/hadoop/mapred-site.xml 使用以下内容替换 mapred-site.xml 中的内容：\n1\u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; 2\u0026lt;?xml-stylesheet type=\u0026#34;text/xsl\u0026#34; href=\u0026#34;configuration.xsl\u0026#34;?\u0026gt; 3 4\u0026lt;configuration\u0026gt; 5 \u0026lt;property\u0026gt; 6 \u0026lt;name\u0026gt;mapreduce.framework.name\u0026lt;/name\u0026gt; 7 \u0026lt;value\u0026gt;yarn\u0026lt;/value\u0026gt; 8 \u0026lt;/property\u0026gt; 9 \u0026lt;property\u0026gt; 10 \u0026lt;name\u0026gt;mapreduce.application.classpath\u0026lt;/name\u0026gt; 11 \u0026lt;value\u0026gt;$HADOOP_MAPRED_HOME/share/hadoop/mapreduce/*:$HADOOP_MAPRED_HOME/share/hadoop/mapreduce/lib/*\u0026lt;/value\u0026gt; 12 \u0026lt;/property\u0026gt; 13\u0026lt;/configuration\u0026gt; 其中，第 5~8 行为 MapReduce 指定任务调度框架为 YARN。\n编辑 slaves slaves 文件为 Hadoop 提供了子节点的主机名。\n1vim ~/hadoop-2.10.1/etc/hadoop/slaves 使用以下内容替换 slaves 中的内容：\nslave1 slave2 复制文件到子节点 使用下面的命令将 Hadoop 文件复制到其他节点，本文中为 slave1 和 slave2，命令如下：\n1cd ~/hadoop 2scp -r hadoop-2.10.1 root@slave1:~/hadoop/ 3scp -r hadoop-2.10.1 root@slave2:~/hadoop/ 配置 Hadoop 环境变量 注意，此操作需要同时在所有节点（master，slave1，slave2）都执行一次，操作命令如下：\n1vim ~/.bash_profile 将以下内容追加到 .bash_profile 文件末尾：\n#HADOOP export HADOOP_HOME=/root/hadoop/hadoop-2.10.1 export PATH=$HADOOP_HOME/bin:$HADOOP_HOME/sbin:$PATH 然后执行下列命令使环境变量生效：\n1source ~/.bash_profile 创建临时文件存放目录 我们在 core-site.xml 文件中指定了 Hadoop 临时文件存放路径，但是文件夹并没有创建，此操作需要同时在所有节点（master，slave1，slave2）都执行一次，操作命令如下：\n1mkdir /home/hadoop/temp 启动集群 格式化文件系统 注意，格式化仅需要在第一次使用 Hadoop 集群时进行，后续使用时无需格式化，并且在使用过程中进行格式化，所有文件将会丢失。此操作需要在 master 节点上进行，执行如下命令：\n1hdfs namenode -format 启动 Hadoop 集群 Hadoop 启动或停止服务的脚本均存放在 sbin 目录中，所以切换到 /home/hadoop/hadoop-2.10.1/sbin 目录下，执行以下命令：\n1start-all.sh 需要注意的是，在启动过程中，Hadoop 会提示这样的启动方式已经过时，使用如下启动方式即可规避过时提示：\n1start-dfs.sh 2start-yarn.sh 查看进程是否启动成功 在 master 节点终端执行 jps 命令，在打印结果中会看到四个进程，分别是 NodeManager、SecondaryNameNode、ResourceManager、Jps。如果出现了这四个进程表示启动成功。结果如下：\nroot@master:~/hadoop/hadoop-2.10.1/sbin# jps 17874 NameNode 18070 SecondaryNameNode 18281 ResourceManager 18554 Jps 此时在 slave1 和 slave2 的节点的终端执行 jps 命令，在输出结果中会看到三个进程，分别是 Jps、NodeManager、DataNode，如果出现了这三个进程表示子节点进程启动成功。结果如下：\nroot@slave1:~# jps 15776 NodeManager 15639 DataNode 16106 Jps 查看 WebUI Hadoop 页面 如果要在宿主机上访问虚拟机 master 节点的 WebUI，需要先将虚拟机的防火墙关闭（此处仅仅是做示例，生产环境不建议这么做），然后访问虚拟机 master 节点 IP:50070 即可。\n防火墙相关命令如下：\n1# 暂时关闭防火墙 2systemctl stop firewalld 3 4# 永久关闭防火墙 5systemctl disable firewalld 6 7# 启用防火墙 8systemctl enable firewalld 例如本例中 master 节点地址为 192.168.61.128，则访问 192.168.61.128:50070，页面如下图：\nYARN 页面 如上例，与 Hadoop 管理页面不同的是，YARN Web 页面地址端口是 8088，页面如下图：\n运行实例 在 Hadoop 自带的 examples 中有一种利用分布式系统计算圆周率的方法，采用的是拟蒙特卡罗（Quasi-Monte Carlo）算法来对 $ \\pi $ 的值进行估算。下面通过运行该程序来检验 Hadoop 集群是否安装配置成功。\n在 master 节点终端中执行下面的命令：\n1hadoop jar hadoop-2.10.1/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.10.1.jar pi 100 100000 Hadoop 的命令类似 Java 命令，通过 jar 指定要运行的程序所在的 jar 包 hadoop-mapreduce-examples-2.10.1.jar。参数 pi 表示需要计算的圆周率 $ \\pi $。后面两个参数中，100 是指要运行 100 次 map，100000 表示每个 map 的任务次数，即每个节点要模拟飞镖 100000 次。执行过程及结果如下图：\nJob Finished in 131.634 seconds Estimated value of Pi is 3.14158440000000000000 至此，Hadoop 环境配置完成。\n备注 如果在执行 mapreduce 任务中报错如 此问题 的描述，参考 此篇文章，需要在 mapred-site.xml 文件中添加下列配置：\n1\u0026lt;property\u0026gt; 2 \u0026lt;name\u0026gt;mapreduce.map.memory.mb\u0026lt;/name\u0026gt; 3 \u0026lt;value\u0026gt;4096\u0026lt;/value\u0026gt; 4\u0026lt;/property\u0026gt; 5\u0026lt;property\u0026gt; 6 \u0026lt;name\u0026gt;mapreduce.reduce.memory.mb\u0026lt;/name\u0026gt; 7 \u0026lt;value\u0026gt;8192\u0026lt;/value\u0026gt; 8\u0026lt;/property\u0026gt; 9\u0026lt;property\u0026gt; 10 \u0026lt;name\u0026gt;mapreduce.map.java.opts\u0026lt;/name\u0026gt; 11 \u0026lt;value\u0026gt;-Xmx3072m\u0026lt;/value\u0026gt; 12\u0026lt;/property\u0026gt; 13\u0026lt;property\u0026gt; 14 \u0026lt;name\u0026gt;mapreduce.reduce.java.opts\u0026lt;/name\u0026gt; 15 \u0026lt;value\u0026gt;-Xmx6144m\u0026lt;/value\u0026gt; 16\u0026lt;/property\u0026gt; ","date":"2020-09-24T09:20:11+08:00","permalink":"https://example.com/posts/getting-to-know-hadoop/","title":"初识 Hadoop"},{"content":"前言 本课的第三、四章分别是程序的机器级表示和处理器体系结构，由于过于硬核，此处略过。第五章是优化程序性能，讲解了如何最大限度地提高程序执行效能，此处也略过。本文基于第六章存储器层级结构。\n存储技术 在本节中主要介绍 SRAM 存储器、DRAM 存储器、ROM 存储器以及机械和固态硬盘。\n随机访问存储器 随机访问存储器（Random Access Memory, RAM）分为两类：静态的和动态的。静态随机访问存储器（Static Random Access Memory, SRAM）比动态随机访问存储器（Dynamic Random Access Memory, DRAM）更快，但也贵得多。目前 CPU 中的三级缓存都是 SRAM。\n易失性存储器 需要注意的是，虽然 SRAM 是静态随机访问存储器，但是其“静态”是相对于动态随机访问存储器的，仍然属于“易失性存储器”，而非真正意义上的静态，同时 DRAM 也属于“易失性存储器”。通俗的说，就是断电之后保存的信息就会丢失。\nSRAM SRAM 将每个位存储在一个双稳态的存储器单元中，每个单元是用一个六晶体管来实现的，在通电的情况下，它可以无限期地保持在两个不同的电压配置或状态之一，其他任何状态都是不稳定的。当从不稳定状态开始，电路会迅速转换到两个稳定状态中的一个。这样的存储器单元类似于下图倒转的钟摆模型。\n由于上述的特性（SRAM 的双稳态特性），只要有电，它就会永远保持它的值。即使有干扰（例如电子噪音）来扰乱电压，当干扰消除后，电路就会恢复到稳定值。这样体现了上述表格中的持续性和不敏感性。\nDRAM DRAM 将每个位存储位对一个电容的充电，每个单元由一个电容和一个访问晶体管组成。但是与 SRAM 不同，DRAM 存储单元对抗干扰非常敏感。当电容的电压被扰乱之后，它就永远不会恢复了。\n小结 下表总结了 SRAM 和 DRAM 存储器的特性。只要有供电，SRAM 就会保持不变。与 DRAM 不同，它不需要刷新。SRAM 的存取比 DRAM 快。SRAM 对诸如光和电噪声这样的干扰不敏感。代价是 SRAM 单元比 DRAM 单元使用更多的晶体管，因而密集度低，而且更贵，功耗更大。\n    每位晶体管数 相对访问时间 持续的？ 敏感的？ 相对花费 应用     SRAM 6 1X 是 否 1000x 高速缓存存储器   DRAM 1 10X 否 是 1X 主存，帧缓冲区    非易失性存储器 显然，非易失性存储器指即使断电也不会丢失数据的存储器，非易失性存储器包括以下几种：\n 只读存储器（Read-Only Memory, ROM）：在生产期间被编程，虽然 ROM 中有的类型既可以读也可以写，但是他们整体上都被称为只读存储器 可编程存储器（Programmable ROM, PROM）：只能被编程一次 可擦写可编程存储器（Eraseable PROM, EPROM）：有一个透明的石英窗口，允许光到达存储单元。紫外线或者 X 射线照射透过窗口，EPROM 单元就被清除为 0。对 EPROM 编程时通过使用一种把 1 写入 EPROM 的特殊设备来完成的，EPROM 能够被擦除和重编程的次数的数量级可以达到 1000 次 电子可擦除可编程存储器（Electrically Eraseable PROM, EEPROM）：类似与 EPROM，但它不需要独立的编程设备，可以直接在印刷电路板上编程，EEPROM 可以编程的次数的数量级可以达到 $ 10^{5} $ 次 闪存（Flash Memory）：基于 EEPROM，多用于手机、相机等产品中，大约 100000 次擦写后失效  需要说明的是，存储在 ROM 设备中的程序通常被称为固件（firmware）。例如 BIOS、磁盘驱动控制器、显卡驱动控制器等等。\n访问主存 数据流通过称为总线（bus）的共享电子电路在处理器和 DRAM 主存之间来来回回。例如下图中，连接 I/O 桥接器与总线接口的系统总线（system bus），连接主存与 I/O 桥接器的内存总线(memory bus)。\n从主存读数据 数据移动路径：主存 -\u0026gt; 内存总线 -\u0026gt; I/O 桥接器 -\u0026gt; 系统总线 -\u0026gt; 总线接口 -\u0026gt; 寄存器\n从主存写数据 数据移动路径：寄存器 -\u0026gt; 总线接口 -\u0026gt; 系统总线 -\u0026gt; I/O 桥接器 -\u0026gt; 内存总线 -\u0026gt; 主存\n机械硬盘 构造 磁盘是由盘片（platter）组成的，每个盘片有两个表面（surface）。盘片中央有一个可以旋转的主轴（spindle），它使得盘片以固定的旋转速率（rotational rate）旋转，通常是 5400-15000 转每分钟（Revolution Per Minute，RPM）。磁盘通常包含一个或多个盘片，并封装在一个密闭的空间中。\n每个盘片的表面是由一组磁道（track）同心圆组成的，每个磁道又被划分为一组扇区（sector）。每个扇区包含相等数据量的数据位（通常是 512 字节），扇区之间由一些间隙（gap）隔开，间隙存储用来表示扇区的格式化位。\n容量 在磁盘容量的计算中，总是按照 1000 进制为准，例如 $ 1GB = 10^{9} Bytes $\n磁盘容量是由以下技术因素决定的：\n 记录密度（Recording density）（位/英寸）：磁道一英寸的段中可以放入的位数 磁道密度（Track density）（道/英寸）：从盘片中心出发半径一英寸的段内可以有的磁道数 面密度（Areal density）（位/平方英寸）：记录密度与磁道密度的乘积  磁盘容量的计算方式：\n$$ 磁盘容量 = \\frac{字节数}{扇区} \\times \\frac{平均扇区数}{磁道} \\times \\frac{磁道数}{表面} \\times \\frac{表面数}{盘片} \\times \\frac{盘片数}{磁道} $$\n例如现有一磁盘，总共有 5 个盘片，每个盘片有 2 个表面，每个表面有 20000 个磁道，每个磁道平均有 300 个扇区，每个扇区有 512 个字节，计算其磁盘容量。\n$$ \\begin{aligned} 磁盘容量 \u0026amp;= \\frac{512 字节}{扇区} \\times \\frac{300 扇区}{磁盘} \\times \\frac{20000 磁道}{表面} \\times \\frac{2 表面}{盘片} \\times \\frac{5盘片}{磁盘} \\newline \u0026amp;= 512 \\times 300 \\times 20000 \\times 2 \\times 5 \\ Byte \\newline \u0026amp;= 30.72 \\ GB \\end{aligned} $$\n固态硬盘 固态硬盘示意图如下：\n一个固态硬盘由 B 个块的序列组成，每个块由 P 页组成。通常，页的大小是 512 字节~4KB，块是由 32~128 页组成的，块的大小为 16KB~512KB。数据是以页为单位读写的，只有在一页所属的块整个被擦除之后，才能写这一页（通常是指该块中的所有位都被设置为 1）。在进行 100000 次重复写之后，块将会磨损损坏。\n分类 现阶段的固态硬盘主要分为以下几类\n 单阶存储单元（Single-Level Cell，SLC）：一个存储单元能存储 1 bit 信息，SLC 闪存的优点是传输速度更快，功率消耗更低和存储单元的寿命更长 多阶存储单元（Multi-Level Cell，MLC）：一个存储单元能存储 2 bit 信息，MLC 闪存可降低生产成本，但比起 SLC 闪存，其传输速度较慢，功率消耗较高和存储单元的寿命较低 三阶存储单元（Triple-Level Cell，TLC）：一个存储单元能存储 3 bit 信息，TLC 的写入速度比 SLC 和 MLC 慢，寿命也比 SLC 和 MLC 短（使用 LDPC 的话，约有 1500 次），大约 1000 次 四阶存储单元（Quad-Level Cell，QLC）：一个存储单元能存储 4 bit 信息，寿命为四者之中最短，大约只有 500 次  在假设低电位表示二进制的 0，高电位表示二进制的 1 时，SLC、MLC、TLC 和 QLC 的电位及二进制值对比表如下。\n对比机械硬盘 优点  固态硬盘没有移动部件，因而随机访问时间比机械硬盘快得多，能耗更低，同时也更结实。  缺点  在反复写之后，固态硬盘存储单元容易磨损 固态硬盘成本更高，相对容量更小  应用  智能手机 笔记本电脑，PC 服务器  发展趋势 下图以半对数为比例，画出了各类存储以及 CPU 性能的发展趋势。\n局部性 一个编写良好的计算机程序常常具有良好的局部性（locality）。也就是它们倾向于引用邻近与其他最近引用过的数据项的数据项，或者最近引用过的数据项本身。局部性通常有两种不同的形式：时间局部性（temporal locality）和空间局部性（spatial locality）。\n下面是一些量化评价程序中局部性的一些简单原则：\n 重复引用相同变量的程序由良好的时间局部性 对于具有步长为 k 的引用模式的程序，步长越小空间局部性越好。具有步长为 1 的引用模式的程序有很好的空间局部性。在内容中以大步长跳来跳去的程序空间局部性会很差 对于取质量来说，循环有好的时间和空间局部性。循环体越小，循环迭代次数越多，局部性越好  存储器层次结构 存储器层次结构（Memory Hierarchy）如下图所示，越靠近底部的存储器速度越慢单价越低，越靠近顶部的则反之。\n缓存 简介 缓存（Cache）是一种容量小但速度极快的存储设备，速度仅次于 CPU 寄存器。它充当速度较慢、容量较大的存储设备的临时存储区。\n层次结构的基本思想 对于第 k 层更快更小的存储设备都充当了第 k+1 层更慢更小的存储设备的缓存。\n存储结构产生的原因 由于局部性，程序通常更倾向于访问第 k 层存储器的数据，而非第 k+1 层存储器的数据。因此，第 k+1 层存储器设备可以做得速度更慢，容量更大以及单价更便宜。\n存储器层次结构中的缓存示例 参考文献  https://zh.wikipedia.org/wiki/%E9%97%AA%E5%AD%98 https://www.bilibili.com/video/av61437877  ","date":"2020-09-20T15:20:11+08:00","permalink":"https://example.com/posts/cmu-15-213-lesson3/","title":"CMU 15-213 存储器层次结构"},{"content":"前言 在 上一篇文章 中，我们了解了二进制有符号数、无符号数以及其相关的运算方法，在本篇中，我们将进一步了解浮点数在计算机中的相关知识。\n二进制小数 表示方法 二进制小数表达方式：在“二进制小数点”左侧的位表示 2 的 n 次幂，而在“二进制小数点”右侧的位则表示 2 的 -n 次幂。如下图：\n用公式表达如下：\n$$ a = \\sum_{k=-j}^{i}b_{k} \\times 2^{k} $$\n示例 例如，将十进制小数转换为二进制小数，有以下例子：\n   十进制小数 二进制小数     $ 5\\frac{3}{4} $ 101.11   $ 2\\frac{7}{8} $ 10.111   $ 1\\frac{7}{16} $ 1.0111    以第一个为例，我们可以注意到二进制小数按位进行求和的结果是：\n$$ 5\\frac{3}{4} = 2^{2}+2^{0}+2^{-1}+2^{-2} $$\n通过上面三个例子，我们可以注意到，当二进制小数整体右移一位，即相当于将十进制小数除以 2（仅针对无符号数）。相应的，当二进制小数整体左移一位，即相当于将十进制小数乘以 2。\n同时我们应特别注意到，形如 $ 0.11111\u0026hellip;_{2} $ 的二进制小数，表示略比 1 小的十进制数。用公式表示如下：\n$$ 1/2 + 1/4 + 1/8 + \\dots + 1/2^{i} + \\dots \\to 1.0 $$\n记为：\n$$ 1.0-\\varepsilon $$\n其中，$ \\varepsilon $ 取决于二进制小数点右边的 1 有多少位，因此，$ \\varepsilon $ 越小，则二进制小数越接近 1。\n局限性 不精确 二进制小数仅能准确表示形如 $ x/2^{k} $ 的十进制小数，其他形式的小数则需要采用重复位的方式来表示。例如：\n   十进制小数 二进制小数     1/3 $ 0.0101010101[01]\\dots $   1/5 $ 0.001100110011[0011]\\dots $   1/10 $ 0.0001100110011[0011]\\dots $    位数限制 由于浮点数位数有限，将浮点数向左移，则可以表示更大的数，但是会损失精度。将浮点数向右移动，精度得到了提高，但是大数又不能进行表示。\nIEEE 浮点数 位表示 所有的浮点数均可以写成如下形式：\n$$ V = (-1)^{s} \\times M \\times 2^{E} $$\n其中，各个字母含义如下：\n 符号（sign）s 决定这是负数（s=1）还是正数（s=0） 尾数（significand） M 是一个二进制小数，它的范围是 $ 1 \\sim 2 - \\varepsilon $，或者是 $ 0 \\sim 1 - \\varepsilon $ 阶码（exponent）E 的作用是对浮点数进行加权，这个权重是 2 的 E 次幂  32 位或 64 位的浮点数位表示形式如下：\n单精度浮点数各个部分所占的位：\n双精度浮点数各个部分所占的位： 将浮点数的位表示划分为三个字段，分别对这些值进行编码：\n 一个单独的符号位 s 直接编码符号 s k 位的阶码字段 $ exp = e_{k-1} \\dots e_{1}e_{0} $ 编码阶码 E n 位小数字段 $ frac = f_{n-1} \\dots f_{1}f_{0} $ 编码尾数 M，但是编码出来的值也依赖于阶码字段的值是否等于 0  三种情况 规格化的值 当 exp 所有位即不全为 0，也不全为 1 时，我们称之为规格化的值。在这种情况下，阶码字段被解释为以偏置（biased）形式表示的有符号整数。即\n$$ E = e - Bias $$\n其中 e 是无符号数，其位表示为 $ e_{k-1} \\dots e_{1}e_{0} $，而偏置值 $ Bias = 2^{k-1} - 1 $，也即单精度时等于 127，双精度时等于 1023。\n由此编码得到的阶码的取值范围是：\n 单精度：$ -126 \\sim +127 $ 双精度：$ -1022 \\sim +1023 $  小数字段 frac 被解释为描述小数值 f，其中 $ 0 \\le f \u0026lt; 1 $，其二进制表示为 $ 0.f_{n-1} \\dots f_{1}f_{0} $，也就是小数点在最高有效位的左边。\n尾数定义为 $ M = 1 + f $，因此我们可以将 M 看成一个二进制表达式为 $ 1.f_{n-1} \\dots f_{1}f_{0} $ 的数字。此时 $ 1 \\le M \u0026lt; 2 $。\n非规格化的值 当阶码全为 0 时，所表示的数是非规格化形式。在这种情况下，$ E = 1-Bias $，$ M = f $，也就是小数部分的值，不包含隐含的开头的 1。\n非规格化数主要有两个作用：用来表示 0 或者表示接近于 0 的数。\n当浮点数二进制位全为 0 时：符号位为 0，阶码全为 0，小数域全为 0，即 $ s = M = f = 0 $，此时表示得到的浮点数是 +0.0。但当符号位为 1 且其他域全为 0 时，可以得到浮点数 -0.0。根据 IEEE 的浮点格式，值 +0.0 和 -0.0 在某些方面被认为是不同的，而在其他方面是相同的。\n非规格化数提供一种称为逐渐溢出（gradually underflow）的属性，可以用来表示接近于 0 的数值。\n特殊情况 在阶码全为 1 的前提下，如果小数域全为 0 时，结果为无穷大或无穷小；如果小数域非 0 时，结果为 NaN（Not a Number）。\n其中小数域全为 0 时，当 $ s = 0 $ 时是 $ +\\infty $，当 $ s = 1 $ 时是 $ -\\infty $。\n一些运算的结果不是实数或者是无穷时，这样就会返回 NaN，例如计算 $ \\sqrt{-1} $ 或者 $ \\infty - \\infty $ 时。\n舍入    舍入方式 1.40 1.60 1.50 2.50 –1.50     向 0 舍入 1 1 1 2 –1   向下舍入（−∞） 1 1 1 2 –2   向上舍入（+∞） 2 2 2 3 –1   向偶数舍入（默认） 1 2 2 2 –2    上述的向偶数舍入实际上就是四舍五入，但需要注意的是，在舍入时优先考虑向偶数舍入。例如上述的 1.50 向上舍入到 2，而 2.5 按照四舍五入应该舍入到 3，由于 3 并不是偶数，故应该向下舍入到 2。\n在现实情况中，向偶数舍入（也称为向最接近的整数）避在大多数情况下避免了统计误差，在 50% 的时间里它将向上取整，而在另外的 50% 时间里它将向下取整，所以它是默认的舍入方式。\n例如我们要对以下数字进行针对百分位的舍入，结果如下：\n   数据 结果     7.8949999 7.89   7.8950001 7.90   7.8950000 7.90   7.8850000 7.88    浮点运算 乘法 定义：\n$$ a = (-1)^{s_{1}} \\times M_{1} \\times 2^{E_{1}} $$\n$$ b = (-1)^{s_{2}} \\times M_{2} \\times 2^{E_{2}} $$\n$$ c = a \\times b = (-1)^{s} \\times M \\times 2^{E} $$\n其中：\n $ s = s_{1} \\land s_{2} $ $ M = M_{1} \\times M_{2} $ $ E = E_{1} + E_{2} $  特殊情况处理：\n 如果 M ≥ 2，将 M 右移，增大 E 如果 E 超出范围，则溢出到 $ \\infty $ 如果 M 位数过多，则舍入到有限位能表示为止  加法 定义：\n$$ a = (-1)^{s_{1}} \\times M_{1} \\times 2^{E_{1}} $$\n$$ b = (-1)^{s_{2}} \\times M_{2} \\times 2^{E_{2}} $$\n假定 $ E_{1} \\gt E_{2} $，则：\n$$ c = a + b = [(-1)^{s_{1}} \\times M_{1} \\times 2^{E_{1}-E_{2}} + (-1)^{s_{2}} \\times M_{2}] \\times 2^{E_{2}} $$\n浮点数加法的一般步骤如下：\n 对阶：将指数较小的浮点数（b）进行尾数向右移位，指数同步增大，直到两个操作数的指数等 求和：对尾数进行求和 规格化：对指数和尾数做规格化，并对尾数进行舍入  特殊情况处理：\n 如果 M ≥ 2，将 M 右移，增大 E 如果 M \u0026lt; 1，将 M 左移，同步减小 E 如果 E 超出范围，则溢出到 $ \\infty $ 如果 M 位数过多，则舍入到有限位能表示为止  参考文献  https://qiankun214.github.io/2019/05/28/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%A4%84%E7%90%86/  ","date":"2020-09-14T18:57:11+08:00","permalink":"https://example.com/posts/cmu-15-213-lesson2/","title":"CMU 15-213 浮点数"},{"content":"应用示例  本篇文章中所使用的 Nginx 是通过下载软件包手动编译安装的，详见 上一篇文章 离线安装部分。\n 在上一篇文章中，我们初步接触了 Nginx 的安装以及使用方法。在本篇文章中我们将以具体的静态网页作为例子，来详细介绍 Nginx 的部分细节。\n文件准备 我们以 C++ 文档 dlib 为例做介绍，官网 http://dlib.net，点击左下角的 Download 按钮并将下载好的文件解压。将文件夹中的 docs 目录内容复制到 Nginx 安装目录中的 dlib 目录中。相关的目录结构如下。\n1drwxr-xr-x. 9 root root 258 9月 11 16:54 blog 2drwx------. 2 nobody root 6 9月 6 15:26 client_body_temp 3drwxr-xr-x. 2 root root 4096 9月 11 19:48 conf 4drwxrwxrwx. 10 root root 8192 8月 9 03:30 dlib 5drwx------. 2 nobody root 6 9月 6 15:26 fastcgi_temp 6drwxr-xr-x. 2 root root 40 9月 6 15:24 html 7drwxr-xr-x. 2 root root 58 9月 11 16:20 logs 8drwx------. 2 nobody root 6 9月 6 15:26 proxy_temp 9drwxr-xr-x. 2 root root 19 9月 6 15:24 sbin 10drwx------. 2 nobody root 6 9月 6 15:26 scgi_temp 11drwx------. 2 nobody root 6 9月 6 15:26 uwsgi_temp 修改配置 编辑 conf/nginx.conf，将 server 中的 location 部分修改为如下配置。\nlocation / { alias dlib/; #... } 其中，location 后的 / 代表根域名指向括号中的目录配置，alias 指定一个目录替代默认目录。\n 更多信息可以查看官方文档\nhttp://nginx.org/en/docs/http/ngx_http_core_module.html#alias\n 重新加载 执行以下命令，以新加载 Nginx 服务。\n1nginx -s reload 访问 执行完以上步骤后，访问 Nginx 的地址，即可看到 dlib 下的静态文件已经被正常加载了。如下图。\n常用配置 以下内容均在 nginx.conf 文件中进行配置。\n数据压缩 根据以上的配置，我们已经可以正常访问部署好的静态网页，但是根据开发者工具我们可以看到，首页的大小是 26.4 kB。我们还可以进一步进行优化，将所需要加载的数据进行压缩，使其所需数据量大大减少。\n在 http 部分中添加以下配置。\ngzip on; gzip_min_length 1; gzip_comp_level 2; gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/x- httpd- php image/jpeg image/gif image/png; 本例中所涉及到的配置释义如下。\n   配置 释义     gzip on | off 是否启用数据压缩   gzip_min_length 会被压缩的响应的最小长度（单位 kB），即返回内容大于此配置时才会被压缩   gzip_comp_level 设置 gzip 压缩等级，等级越小压缩速度越快、文件压缩比越小。压缩等级范围是 1-9，压缩等级越高对性能要求越高。   gzip_types 设置需要压缩的 MIME 类型，非设置值不进行压缩，即匹配压缩类型     更多信息可以查看官方文档\nhttp://nginx.org/en/docs/http/ngx_http_gzip_module.html\n 可以看到，开启 gzip 压缩后，加载的数据量大幅减少。\n加载速度 使用 limit_rate 可以对网页加载速度进行控制，详细如下。\nserver { #... set $limit_rate 1k; #... } 其中，$limit_rate 是控制访问速度的变量。后面紧跟的 1k 是需要限制的速度，此例中的单位为 kB，也可以设置其他单位，例如 1M。\n 更多信息可以查看官方文档\nhttp://nginx.org/en/docs/http/ngx_http_core_module.html#var_limit_rate\n 记录日志 在 http 模块中，可以配置日志记录的格式，以及日志记录的位置和文件名等等，配置如下。\nhttp { #... log_format main '$remote_addr - $remote_user [$time_local] \u0026quot;$request\u0026quot; ' '$status $body_bytes_sent \u0026quot;$http_referer\u0026quot; ' '\u0026quot;$http_user_agent\u0026quot; \u0026quot;$http_x_forwarded_for\u0026quot;'; access_log logs/sample.log main; #... }  更多信息可以查看官方文档\nhttp://nginx.org/en/docs/http/ngx_http_log_module.html#access_log\n 反向代理 在此部分，我们使用两台 Nginx 服务器作为示例，分别是 192.168.61.128 和 192.168.61.129，简记为 CentOS_1 与 CentOS_2。\n修改 CentOS_1 的 Nginx 配置文件，修改部分如下，此时直接访问 192.168.61.128 已经不能正常进行加载。\nserver { listen 127.0.0.1:80; server_name localhost; #... } 修改 CentOS_2 的 Nginx 配置文件，修改部分如下，我们将 192.168.61.129:80 指向了 192.168.61.128:80。\nupstream local { server 192.168.61.128:80; } server { listen 80; server_name 192.168.61.129; location / { proxy_set_header Host $host:$server_port; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://local/; } #... } 分别在两台机器上重新加载 Nginx 配置文件，并访问 192.168.61.129:80，此时可以正常打开 192.168.61.128:80 上所配置的静态文件。\n 上述配置可以参考官方文档\nhttp://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_set_header\n 日志可视化 在本例中，我们使用 GoAccess 首先日志试试可视化。\n安装 GoAccess 由于此例中使用的系统是 CentOS 8，安装 GoAccess 之前需要先配置 epel 源。\n配置 epel 源  安装 epel 配置包  1yum install -y https://mirrors.aliyun.com/epel/epel-release-latest-8.noarch.rpm 将 repo 配置中的地址替换为阿里云镜像站地址  sed -i 's|^#baseurl=https://download.fedoraproject.org/pub|baseurl=https://mirrors.aliyun.com|' /etc/yum.repos.d/epel* sed -i 's|^metalink|#metalink|' /etc/yum.repos.d/epel* 安装 GeoIP 编译安装 GoAccess 需要用到 GeoIP。\nsudo yum -y --enablerepo=epel install geoip 安装 GoAccess 根据官网的文档，我们顺序执行以下命令即可。\n1wget https://tar.goaccess.io/goaccess-1.4.tar.gz 2tar -xzvf goaccess-1.4.tar.gz 3cd goaccess-1.4/ 4./configure --enable-utf8 --enable-geoip=legacy 5make 6make install 安装完成后，使用以下命令，若得到类似结果则表明安装成功。\n1goaccess -v 1GoAccess - 1.4. 2For more details visit: http://goaccess.io 3Copyright (C) 2009-2020 by Gerardo Orellana 4 5Build configure arguments: 6 --enable-utf8 7 --enable-geoip=legacy 配置 GoAccess 在使用前，我们需要对 GoAccess 的配置文件进行一些修改，以方便后续使用。\nvim /usr/local/etc/goaccess/goaccess.conf 在此配置文件中，将以下内容取消注释，其他内容则保持不变。\n#... no-ip-validation true log-format COMBINED time-format %H:%M:%S date-format %d/%b/%Y real-time-html true #... 启动监听 在 Nginx 的 logs 目录中，我们以 access 为源文件，启动 GoAccess 进程后，会产生一个 websocket 长连接，持续监听客户端的请求数据，进而实时展现在 report.html 页面上。\n1cd /usr/local/nginx/logs 2goaccess access.log -o ../html/report.html 此时我们还需要修改 nginx.conf 使报告页面可以直接访问，在 server 部分添加如下内容。\nlocation /report.html { alias html/report.html; } 然后重新加载配置即可。\n1nginx -s reload 至此，日志可视化已经配置完成，我们可以直接访问 Nginx 服务地址/report.html 查看可视化页面，如下。\n附录 Linux 查看端口占用状态\n查看占用 1netstat -anp 其中，参数 anp 分别表示：\n  a：显示所有活动的 TCP 连接，以及正在监听的 TCP 和 UDP 端口\n  n：以数字形式表示地址和端口号，不试图去解析其名称（number），参数 -n 会将应用程序转为端口显示，即数字格式的地址，如：nfs-\u0026gt;2049，ftp-\u0026gt;21\n  p：列出与端口监听或连接相关的进程，即 pid\n  关闭占用 在本例中，若要关闭 GoAccess 建立的连接，首先执行如下命令拿到其 pid。\n1netstat -anp | grep goaccess 结果如下。\n1tcp 0 0 0.0.0.0:7890 0.0.0.0:* LISTEN 2323/goaccess 2tcp 0 0 192.168.61.128:7890 192.168.61.1:56503 ESTABLISHED 2323/goaccess 然后手动 kill 其进程即可。\n1kill 2323 ","date":"2020-09-11T19:51:07+08:00","permalink":"https://example.com/posts/getting-to-know-nginx-2/","title":"初识 Nginx（二）"},{"content":"Nginx 简介  简介内容来自 Nginx 官网 http://nginx.org/en\nnginx [engine x] is an HTTP and reverse proxy server, a mail proxy server, and a generic TCP/UDP proxy server, originally written by Igor Sysoev. For a long time, it has been running on many heavily loaded Russian sites including Yandex, Mail.Ru, VK, and Rambler. According to Netcraft, nginx served or proxied 25.75% busiest sites in August 2020. Here are some of the success stories: Dropbox, Netflix, Wordpress.com, FastMail.FM.\nThe sources and documentation are distributed under the 2-clause BSD-like license.\nCommercial support is available from Nginx, Inc.\n 简而言之，Nginx 是一个高性能的 HTTP 和反向代理服务器，特点是占有内存少，并发能力强。详细信息请查看 Nginx 官网介绍页面。\n 以下两种安装方式，任意选择一种进行安装即可。\n 在线安装 Nginx 注意，本篇文章基于 CentOS 8.2 版本，如使用其他系统，操作可能有一些变化，一切以官方网站安装教程为准。\n首先我们需要先安装 yum-utils 包，执行以下命令即可。\n1sudo yum install yum-utils 然后配置 Nginx 仓库，我们需要在 /etc/yum.repo.d/ 中创建一个名为 nginx.repo 的文件，并填入以下内容。\n[nginx-stable] name=nginx stable repo baseurl=http://nginx.org/packages/centos/$releasever/$basearch/ gpgcheck=1 enabled=1 gpgkey=https://nginx.org/keys/nginx_signing.key module_hotfixes=true [nginx-mainline] name=nginx mainline repo baseurl=http://nginx.org/packages/mainline/centos/$releasever/$basearch/ gpgcheck=1 enabled=0 gpgkey=https://nginx.org/keys/nginx_signing.key module_hotfixes=true 默认情况下使用的是 Nginx 稳定版仓库，即配置中的 nginx-stable。如果需要使用主线版仓库，可以执行下面的命令进行手动指定。\n1sudo yum-config-manager --enable nginx-mainline 上述准备工作完成后，就可以开始安装 Nginx 了，执行下面这条命令即可。\n1sudo yum install nginx 稍等片刻完成安装后，可使用下述命令来验证是否安装成功。\n1nginx -v 2whereis nginx 得到类似于下面的输出，即代表安装成功。\nnginx version: nginx/1.18.0 nginx: /usr/sbin/nginx /usr/lib64/nginx /etc/nginx /usr/share/nginx /usr/share/man/man8/nginx.8.gz 离线安装 Nginx 下载并解压 1cd /usr/local/software 2 3# 下载 4sudo wget http://nginx.org/download/nginx-1.18.0.tar.gz 5 6# 解压 7tar -zxvf nginx-1.18.0.tar.gz -C ./ 编译 1cd nginx-1.18.0 2sudo ./configure --prefix=/usr/local/nginx 其中 --prefix 的作用是指定编译后的文件存放位置，可以根据实际情况自由确定。\n编译过程中可能会遇到一些报错，详细信息和解决方案如下。\n 此部分内容参照文章 Nginx 教程(一) Nginx 入门教程\n   ./configure: error: C compiler cc is not found\n错误原因：缺少编译环境，安装编译源码所需要的工具和库：\n执行命令：sudo yum install gcc gcc-c++ ncurses-devel perl\n  ./configure: error: the HTTP rewrite module requires the PCRE library\n错误原因：缺少 HTTP rewrite module 模块\n执行命令：sudo yum install pcre pcre-devel\n  ./configure: error: the HTTP gzip module requires the zlib library\n错误原因：缺少 HTTP zlib 类库，我们选择安装模块：\n执行命令：sudo yum install zlib gzip zlib-devel\n  上述报错都解决了之后，再次执行编译命令，可以得到如下输出。\nConfiguration summary + using system PCRE library + OpenSSL library is not used + using system zlib library nginx path prefix: \u0026quot;/usr/local/nginx\u0026quot; nginx binary file: \u0026quot;/usr/local/nginx/sbin/nginx\u0026quot; nginx modules path: \u0026quot;/usr/local/nginx/modules\u0026quot; nginx configuration prefix: \u0026quot;/usr/local/nginx/conf\u0026quot; nginx configuration file: \u0026quot;/usr/local/nginx/conf/nginx.conf\u0026quot; nginx pid file: \u0026quot;/usr/local/nginx/logs/nginx.pid\u0026quot; nginx error log file: \u0026quot;/usr/local/nginx/logs/error.log\u0026quot; nginx http access log file: \u0026quot;/usr/local/nginx/logs/access.log\u0026quot; nginx http client request body temporary files: \u0026quot;client_body_temp\u0026quot; nginx http proxy temporary files: \u0026quot;proxy_temp\u0026quot; nginx http fastcgi temporary files: \u0026quot;fastcgi_temp\u0026quot; nginx http uwsgi temporary files: \u0026quot;uwsgi_temp\u0026quot; nginx http scgi temporary files: \u0026quot;scgi_temp\u0026quot; 安装 1cd /usr/local/software/nginx-1.18.0 2sudo make \u0026amp; make install 得到如下输出时，即表明 Nginx 已经安装成功。\n... test -d '/usr/local/nginx/logs' \\ || mkdir -p '/usr/local/nginx/logs' make[1]: 离开目录“/usr/local/software/nginx-1.18.0” [1]+ 已完成 make 在线安装 Nginx 的启动方式  如果是采用手动编译安装 Nginx 的方式，请跳过本节查看下一节内容。\n 配置 nginx.conf 首先编辑 /etc/nginx/nginx.conf 文件，配置 Nginx 端口与访问地址（即 server 部分）。在配置端口时，不建议设置为 80，以免与其他服务冲突。具体配置如下。\nuser nginx; worker_processes 1; error_log /var/log/nginx/error.log warn; pid /var/run/nginx.pid; events { worker_connections 1024; } http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] \u0026quot;$request\u0026quot; ' '$status $body_bytes_sent \u0026quot;$http_referer\u0026quot; ' '\u0026quot;$http_user_agent\u0026quot; \u0026quot;$http_x_forwarded_for\u0026quot;'; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; include /etc/nginx/conf.d/*.conf; # 在这里新增 server 配置 server { listen 8090; server_name localhost; location / { root html; index index.html index.htm; } } } 系统防火墙 由于我的 CentOS 是安装在虚拟机中，未安装图形界面，故需要在宿主机上进行测试并访问虚拟机地址，所以需要增加一步禁用 CentOS 防火墙的操作，具体命令如下。\n1# 关闭防火墙 2systemctl stop firewalld.service 3 4# 禁止防火墙开机自启 5systemctl disable firewalld.service 现在可以正式启动 Nginx 服务了，执行下述命令即可。\n1sudo nginx 执行之后，可以使用下面命令检查是否启动成功，以及访问地址和端口是否生效。\n查看包含 nginx 关键词的进程 1ps -ef | grep nginx 结果如下，可以看到已经成功启动了。\nroot 4781 1 0 14:31 ? 00:00:00 nginx: master process nginx nginx 5055 4781 0 14:36 ? 00:00:00 nginx: worker process 查看本机所有暴露的端口 1netstat -ntlp 结果如下，可以看到此前配置的 8090 端口已经是 listen 状态，接下来就可以在浏览器中访问了。\nActive Internet connections (only servers) Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name ... tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN - tcp 0 0 0.0.0.0:8090 0.0.0.0:* LISTEN - tcp 0 0 127.0.0.1:6010 0.0.0.0:* LISTEN - ... 在浏览器中访问 虚拟机ip:8090，即可看到 Nginx 的欢迎页面。\n 此时返回 404 是因为 Nginx 目录中并没有欢迎页面的 html 文件，但依然可以说明已经 Nginx 服务已经配置正确并启动成功。\n 离线安装 Nginx 的启动方式 首先执行下述命令来启动 Nginx。\n1cd /usr/local/nginx/sbin 2sudo ./nginx 同样的，我们可以按照上一节中介绍的方法，来验证 Nginx 是否启动成功，以及端口是否开放。\nNginx 服务默认的端口是 80，如果需要修改端口，也可以参照上一节中的内容进行手动修改，略有不同的是，通过手动编译安装的 Nginx，配置文件地址在 /usr/local/nginx/conf/nginx.conf，也就是编译时我们手动指定的路径下。 其余内容此处皆不再赘述。\n打开宿主机浏览器，访问 虚拟机ip:80，就可以看到 Nginx 的欢迎页面。\n修改 nginx.conf 如果后续需要修改 nginx.conf 中的内容，例如更改 Nginx 服务端口号，请务必在修改完成后重启服务。常用的 Nginx 命令如下。\n1# 检查 nginx.conf 是否配置正确 2sudo nginx -t 3 4# 重启 Nginx 服务 5sudo nginx -s reload 6 7# 停止 Nginx 服务 8sudo nginx -s stop 附录 在 Linux 中查找某一个具体文件路径时，可以使用以下命令。\n1sudo find / -name filename  / 代表查找的目录，此例是根目录 -name 代表按照文件名进行查找 filename 代表具体的文件名，例如 nginx.conf  以本文章为例，在根目录中查找 nginx.conf 的结果如下。\n/etc/nginx/nginx.conf /usr/local/software/nginx-1.18.0/conf/nginx.conf /usr/local/nginx/conf/nginx.conf ","date":"2020-09-07T15:47:11+08:00","permalink":"https://example.com/posts/getting-to-know-nginx/","title":"初识 Nginx"},{"content":"简介 CSAPP 课程全程 Computer Systems: A Programmer’s Perspective，中文翻译为“从程序员的视角，看计算机系统！”或“深入理解计算机系统”。此课程是卡耐基梅隆大学开设的一门课程，官方网站 https://www.cs.cmu.edu/~213/index.html。\n 内容简介节选自豆瓣\nhttps://book.douban.com/subject/1230413\n从程序员的视角，看计算机系统！\n本书适用于那些想要写出更快、更可靠程序的程序员。通过掌握程序是如何映射到系统上，以及程序是如何执行的，读者能够更好的理解程序的行为为什么是这样的，以及效率低下是如何造成的。粗略来看，计算机系统包括处理器和存储器硬件、编译器、操作系统和网络互连环境。而通过程序员的视角，读者可以清晰地明白学习计算机系统的内部工作原理会对他们今后作为计算机科学研究者和工程师的工作有进一步的帮助。它还有助于为进一步学习计算机体系结构、操作系统、编译器和网络互连做好准备。\n 一切皆位 十进制 在计算机发展历史上，实际上只有宾夕法尼亚大学建立的第一台计算机 ENIAC 使用了十进制进行了算术运算，他们使用 10 个电子管来表示每个数字。所以他们通过控制电子管的开关来表示 10 个数字中的其中一个。\n二进制 随着计算机的发展，十进制逐渐演化为二进制。在计算机中，我们使用电学层面上的电压高低来存储位数据，如图所示，高电压（0.9v-1.1v）记作逻辑 1，而低电压（0.0v-0.2v）记作逻辑 0。\n之所以这么做，是因为通过区分高低电压，可以有效地过滤噪声和杂讯。\n十六进制 二进制的成功运用也带来了一个问题，由于每一个位只能存储两种信号（即 0 和 1），对于人来说基本属于不可读的，所以我们将每四个二进制在位合并为一个十六进制位，这样大大缩减了数据的展示长度。例如\n具体数据类型实际所占空间 此处以 C 语言数据类型为例，因为在 32 位与 64 位机器上所占空间不尽相同，故列下表。\n   C Data Type Typical 32-bit Typical 64-bit x86-64     char 1 1 1   short 2 2 2   int 4 4 4   long 4 8 8   float 4 4 4   double 8 8 8   pointer 4 8 8    位操作 与、或、非、异或 通俗的解释如下：\n 与（\u0026amp;）：两者都为真时，结果为真，否则为假； 或（|）：任意一者为真时，结果为真，否则为假； 非（~）：对元素取反； 异或（^）：两者性质相同时，结果为假，否则为真。  详细示例见下图。\n与集合的关系 我们将二进制数据从右往左标记位置，红色数字位置代表该为值为 1，右侧集合中数据代表该二进制数据中所有位值为 1 的位置。例如第一个数据 01101001，从右往左计数，第 0、3、5、6 位对应值为 1。对第二个数进行同样的处理。\n此时我们对两个数据进行与、或、非、异或操作时，可以得出下述结论。\n   数据操作 对应集合操作 结果数据 结果集合     \u0026amp; 交集 1000001 {0, 6}   | 并集 1111101 {0, 2, 3, 4, 5, 6}   ^ 差集 111100 {2, 3, 4, 5}   ~ 补集 10101010 {1, 3, 5, 7}    移位 左移 x \u0026laquo; y 左移即将二进数据 x 整体向左移动 y 个位置，并在其右侧补 0。例如\n    结果     元素 x 01100010   \u0026laquo; 3 00010000    右移 x \u0026raquo; y 与左移一样，右移即将二进数据 x 整体向右移动 y 个位置，并在其空缺位填充相应数据。而右移又分为逻辑右移和算数右移，具体区别如下。\n逻辑右移 在逻辑右移过程中，需要在其左侧空缺位置补 0。例如\n    结果     元素 x 01100010   \u0026raquo; 2 00101000    算术右移 在算术右移过程中，需要在其左侧空缺位置补 1。例如\n    结果     元素 x 01100010   \u0026raquo; 2 11101000    无符号数与补码 无符号数的表达形式：\n$$ B2U(X) = \\sum_{i=0}^{w-1}x_{i} \\cdot 2^{i} $$\n补码的表达形式：\n$$ B2T(X) = -x_{w-1}\\cdot 2^{w-1}+\\sum_{i=0}^{w-2}x_{i}\\cdot 2^{i} $$\n在补码中，最高值为 1 时，始终代表 -1，例如：\n有了补码，计算机就可正常表示负数。例如：\n    十进制 十六进制 二进制     x 15213 3B 6D 00111011 01101101   y -15213 C4 93 11000100 10010011    数据范围 此处我们以 16 位二进制数（即 w=16）来探讨无符号数和补码的范围，如下表。 其中，UMax 代表无符号数最大值，TMax 代表补码最大值，TMin 代表补码最小值。\n    十进制 十六进制 二进制     UMax 65535 FF FF 11111111 11111111   TMax 32767 7F FF 01111111 11111111   TMin -32768 80 00 10000000 00000000   -1 -1 FF FF 11111111 11111111   0 0 00 00 00000000 00000000    当数据的位宽 w 发生变化时，代表的数据最值也会发生相应的变化，如下表。\n    8 位 16 位 32 位 64 位     UMax 255 65,535 4,294,967,295 18,446,744,073,709,551,615   TMax 127 32,767 2,147,483,647 9,223,372,036,854,775,807   TMin -128 -32,768 -2,147,483,648 -9,223,372,036,854,775,808    根据以上性质，我们可以得出以下结论：\n$$ |TMin| = TMax + 1 $$\n$$ UMax = 2 * TMax + 1 $$\n补码形式转换为无符号数 有符号数扩充 已知一个 w 位的有符号数 X，现在需要将其转换为 w+k 位相同值的有符号数，可以按照下述步骤进行操作。\n 将符号标识位（sign bit）拷贝 k 份，填充到扩充的 k 个位置上； 此时 X 就可以按位表示为  $$ X^{'} = \\underbrace{X_{w-1},\u0026hellip;, X_{w-1}}_{k 个符号位拷贝}, X_{w-1}, X_{w-2},\u0026hellip;, X_{0} $$\n详细信息如下图所示：\n示例 定义两个 short 变量 x 与 y，将其分别扩充为 int 变量，得到 ix 与 iy，详细结果如下。\n1short int x = 15213; 2int ix = (int) x; 3short int y = -15213; 4int iy = (int) y;     十进制 十六进制 二进制     x 15213 3B 6D 00111011 01101101   ix 15213 00 00 3B 6D 00000000 00000000 00111011 01101101   y -15213 C4 93 11000100 10010011   iy -15213 FF FF C4 93 11111111 11111111 11000100 10010011    移位实现 2 的次方倍算术操作 乘法 给定一个整数 u，其 2 的次方倍乘法操作相对简单，且对于无符号数和有符号数都是统一的操作，即将数据的二进制位向左移动，再将移动产生的多余位进行舍弃，剩余位即最终结果。也即\n$$ u \u0026laquo; k = u * 2^{k} $$\n除法 无符号数 给定一个无符号数 u，对其做 2 的次方倍除法，相当于将其二进制位向右进行逻辑移位，再将小数部分进行舍弃（向下取整），剩余位即最终结果。也即\n$$ u \u0026raquo; k = \\lfloor u / 2^{k} \\rfloor $$\n例如：\n    算术除法 计算结果 十六进制 二进制     x 15213 15213 3B 6D 00111011 01101101   x \u0026raquo; 1 7606.5 7606 1D B6 00011101 10110110   x \u0026raquo; 4 950.8125 950 03 B6 00000011 10110110   x \u0026raquo; 8 59.4257813 59 00 3B 00000000 00111011    有符号数 给定一个有符号数 x，对其做 2 的次方倍除法，相当于将其二进制位向右进行算术移位，再将小数部分进行舍弃（向下取整），剩余位即最终结果。也即\n$$ x \u0026raquo; k = \\lfloor x / 2^{k} \\rfloor $$\n例如：\n    算术除法 计算结果 十六进制 二进制     y -15213 -15213 C4 93 11000100 10010011   y \u0026raquo; 1 -7606.5 -7607 E2 49 11100010 01001001   y \u0026raquo; 4 -950.8125 -951 FC 49 11111100 01001001   y \u0026raquo; 8 -59.4257813 -60 FF C4 11111111 11000100    ","date":"2020-09-04T19:02:11+08:00","permalink":"https://example.com/posts/cmu-15-213-lesson1/","title":"CMU 15-213 位、字节与整数"},{"content":"Docker 简介 简介来自于 Docker 入门教程 - 阮一峰的网络日志\n Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。\nDocker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。\n总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。\n 安装 Docker 在此部分，作者使用的是 Centos 8.2 进行的操作，下述的安装命令仅保证在该环境下运行。\n设置 Docker 仓库 根据官方教程，执行以下两条命令：\n1sudo yum install -y yum-utils 2 3sudo yum-config-manager \\ 4 --add-repo \\ 5 http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 由于国内直接连接 Docker 官方镜像源十分缓慢，所以在第二个命令中将官方镜像源替换为阿里云镜像源。\n安装 Docker 引擎 1sudo yum install docker-ce docker-ce-cli containerd.io 在执行这条命令时，极有可能会报错。比如作者遇到的报错如下：\nError: Problem: package docker-ce-3:19.03.8-3.el7.x86_64 requires containerd.io \u0026gt;= 1.2.2-3, but none of the providers can be installed - cannot install the best candidate for the job - package containerd.io-1.2.10-3.2.el7.x86_64 is excluded - package containerd.io-1.2.13-3.1.el7.x86_64 is excluded - package containerd.io-1.2.2-3.3.el7.x86_64 is excluded - package containerd.io-1.2.2-3.el7.x86_64 is excluded - package containerd.io-1.2.4-3.1.el7.x86_64 is excluded - package containerd.io-1.2.5-3.1.el7.x86_64 is excluded - package containerd.io-1.2.6-3.3.el7.x86_64 is excluded 为了解决这个报错，需要先执行下述命令安装好 containerd.io 组件。\n1sudo yum install -y \\ 2 https://mirrors.aliyun.com/docker-ce/linux/centos/7/x86_64/edge/Packages/containerd.io-1.2.13-3.2.el7.x86_64.rpm 3 4sudo yum -y install ./containerd.io-1.2.13-3.1.el7.x86_64.rpm 至于为什么安装的 containerd.io 组件是 centos 7 目录下的，有两个原因：\n 此版本在 centos 8 环境下也可以正常使用； 阿里云官方只提供了适配 centos 7 的 containerd.io 组件。  然后重新执行上述命令即可完成 Docker 的安装。\n1sudo yum install docker-ce docker-ce-cli 我们可以通过两个命令来验证 Docker 是否安装成功。\n1docker version 2# 或 3docker info 若输出类似于以下的内容，则配置正确。\n[root@localhost ~]# docker version Client: Docker Engine - Community Version: 19.03.12 API version: 1.40 Go version: go1.13.10 Git commit: 48a66213fe Built: Mon Jun 22 15:46:54 2020 OS/Arch: linux/amd64 Experimental: false Server: Docker Engine - Community Engine: Version: 19.03.12 API version: 1.40 (minimum version 1.12) Go version: go1.13.10 Git commit: 48a66213fe Built: Mon Jun 22 15:45:28 2020 OS/Arch: linux/amd64 Experimental: false containerd: Version: 1.2.6 GitCommit: 894b81a4b802e4eb2a91d1ce216b8817763c29fb runc: Version: 1.0.0-rc8 GitCommit: 425e105d5a03fabd737a126ad93d62a9eeede87f docker-init: Version: 0.18.0 GitCommit: fec3683 配置 Docker 仓库 由于在国内连接 Docker 官方仓库 https://hub.docker.com 十分缓慢，故我们可以将仓库地址更换为国内的各种源，详细步骤如下。\n 在 /etc/docker 目录中新增一个名为 daemon.json 的配置文件，如果已经存在这个文件，则只需要进行修改。 将该文件中的 registry-mirrors 项修改为如下形式。  1{ 2 \u0026#34;registry-mirrors\u0026#34;: [ 3 \u0026#34;https://kuamavit.mirror.aliyuncs.com\u0026#34;, 4 \u0026#34;https://docker.mirrors.ustc.edu.cn\u0026#34; 5 ] 6} 到此就配置完毕了。\n启动并运行 Docker 启动 1$ sudo service docker start 2# 或 3$ sudo systemctl start docker 运行 hello-world 1sudo docker run hello-world 此时，由于本地尚未安装 hello-world 实例，Docker 会自动从上文中配置的镜像中拉取 hello-world 实例，然后运行这个实例。具体输出如下。\n[root@localhost docker]# docker run hello-world # 这里提示未在本地找到 hello-world 实例，将从镜像中拉取最新版。 Unable to find image 'hello-world:latest' locally latest: Pulling from library/hello-world 0e03bdcc26d7: Pull complete Digest: sha256:7f0a9f93b4aa3022c3a4c147a449bf11e0941a1fd0bf4a8e6c9408b2600777c5 Status: Downloaded newer image for hello-world:latest # 开始运行 Hello from Docker! This message shows that your installation appears to be working correctly. To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the \u0026quot;hello-world\u0026quot; image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal. To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bash Share images, automate workflows, and more with a free Docker ID: https://hub.docker.com/ For more examples and ideas, visit: https://docs.docker.com/get-started/ 容器管理 当 image 文件开始运行之后，就会生成一个容器实例，容器实例实际上也是一个文件，故也称为实例文件。当容器实例停止运行时，容器文件并不会被删除。\n 列出本机正在运行的容器  1sudo docker container ls 列出本机所有容器（包括已停止运行的）  1sudo docker container ls -all 输出结果如下。\nCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES d3a382fde773 hello-world \u0026quot;/hello\u0026quot; 8 minutes ago Exited (0) 8 minutes ago romantic_proskuriakova 其中 CONTAINER ID 就是该容器的唯一标识符，在后续的终止容器运行时需要用到。\n终止容器运行  1sudo docker container kill d3a382fde773 当然本例中 hello-world 容器已经停止运行了，所以不能再次停止，此处仅做示例。 即使一个容器文件已经停止运行，但是其依然会占据磁盘空间，可以使用下述命令进行删除。\n1sudo docker container rm d3a382fde773 镜像管理 当我们拉取了多个镜像，其中某些又不需要使用了，则需要对镜像进行手动管理，详细操作如下。\n 罗列所有本地已经安装的镜像  1sudo docker image ls 输出如下\nREPOSITORY TAG IMAGE ID CREATED SIZE hello-world latest bf756fb1ae65 8 months ago 13.3kB 移除不需要的镜像  1sudo docker image rm hello-world 注意，如果 image 在运行，或者已经生成了实例文件，是不能直接删除的，需要先将实例容器停止并删除实例文件，才可以正常删除。执行结果如下。\nUntagged: hello-world:latest Untagged: hello-world@sha256:7f0a9f93b4aa3022c3a4c147a449bf11e0941a1fd0bf4a8e6c9408b2600777c5 Deleted: sha256:bf756fb1ae65adf866bd8c456593cd24beb6a0a061dedf42b26a993176745f6b Deleted: sha256:9c27e219663c25e0f28493790cc0b88bc973ba3b1686355f221c38a36978ac63 ","date":"2020-09-02T18:37:11+08:00","permalink":"https://example.com/posts/getting-to-know-docker/","title":"初识 Docker"},{"content":"前情提要 在前文中我们实现了在 Github 中部署博客，此文将简化发文操作步骤，并实现文章图片管理。\n创建仓库  注意：\n由于 username 不方便叙述，故下文中均以 sudrizzz 为例替代 username，\n请读者根据实际情况进行更改。\n 在上文中我们已经创建了一个名为 \u0026lt;username\u0026gt;.github.io 的仓库，现在还需要创建另一个仓库来存放文章管理文件。仓库名任意，公有与私有均可。另外，还需要创建一个仓库来存储文章中涉及到的图片，仓库名任意，但必须是公有的。本例中，我们所用到的仓库名如下。\n   仓库名 用途 公有或私有     blog_workflow 存储博客中文章或者主题等原始文件 私有   sudrizzz.github.io 存储 Hugo 生成的静态文件 公有   blog_images 存储图片文件 公有    拆分文件 上文中我们只是将 /public 文件夹提交到了 sudrizzz.github.io 仓库，现在我们还需要将除了 /public 以外的文件全部提交到 blog_workflow，实现这一步可以再本地建立两个对应的文件夹，分别进行提交，操作步骤不再赘述。拆分后的目录结构如下。\nblog_workflow 仓库 ├─archetypes ├─content │ └─cn │ └─posts ├─layouts ├─resources │ └─_gen └─themes └─yinyang ├─... sudrizzz.github.io 仓库 ├─categories │ └─test ├─css │ └─highlight ├─fonts ├─images ├─js ├─posts │ └─test └─tags 配置公私密钥 生成密钥 打开 Git Bash，执行如下命令\n1ssh-keygen -t rsa -b 4096 -C \u0026#34;sudrizzz.github.io\u0026#34; 设置密钥存储位置，按照提示进行操作，不需要自定义一路回车即可。\nGenerating public/private rsa key pair. Enter file in which to save the key (/c/Users/.ssh/id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /c/Users/.ssh/deploy. Your public key has been saved in /c/Users/.ssh/deploy.pub. The key fingerprint is: SHA256:MpU2IEDuvNADO1AVWrQx/3HMAECYw+C3taw+5Fyy2F4 sudrizzz.github.io The key's randomart image is: +---[RSA 4096]----+ |.++B@oo.. | |.o=o * . = | |o.oo... * + | |.*. + .+ + | |+ =. oo S | | o =.. o | | B.+E | | ..*. | | .o. | +----[SHA256]-----+ 生成的密钥文件放置在 c/Users/\u0026lt;user\u0026gt;/.ssh/ 文件夹中，分别是\n id_rsa id_rsa.pub  其中后缀为 .pub 的文件为公钥，另一个则为私钥。\n配置密钥 配置私钥 打开 blog_workflow 仓库，进入 Settings -\u0026gt; Secrets，选择 New secret，名称填写为 ACTIONS_DEPLOY_KEY，后续需要用到该名称。\n打开 id_rsa，并复制其全部内容，粘贴到 Value 中，点击添加。\n配置公钥 打开 sudrizzz.github.io 仓库，进入 Settings -\u0026gt; Deploy keys，选择 Add deploy key，名字可以任意写。\n打开 id_rsa.pub，并复制其全部内容，粘贴到 Key 中，勾选 Allow write access，点击添加。 配置 Action 脚本 打开 blog_workflow 仓库，进入 Action，初始化左侧界面，选择 set up a workflow yourself，在编辑框中粘贴如下配置\n1name: CI 2 3# 持续发布的分支 4on: 5 push: 6 branches: master 7 8# 执行的 jobs 9jobs: 10 # 编译环境 11 build: 12 runs-on: ubuntu-latest 13 14 # 执行的步骤 15 steps: 16 # 检出 sudrizzz/blog_workflow 工程，固定写法 17 - uses: actions/checkout@v1 18 19 - name: Setup Hugo 20 uses: peaceiris/actions-hugo@v2 21 with: 22 hugo-version: latest 23 24 # 执行 hugo，编译出源文件 25 - name: Build 26 run: hugo --gc --minify --cleanDestinationDir 27 28 # 部署 29 - name: Deploy 30 uses: peaceiris/actions-gh-pages@v3 31 with: 32 deploy_key: ${{ secrets.ACTIONS_DEPLOY_KEY }} # 上面配置的私钥名称 33 external_repository: sudrizzz/sudrizzz.github.io # Pages 发布到远程仓库 34 publish_dir: ./public # hugo 编译生成的 public 目录下的文件 35 keep_files: false # 不保留 *.github.io 仓库中已有的文件 36 publish_branch: master # 远程仓库分支 37 commit_message: ${{ github.event.head_commit.message }} 注意修改第 33 行 external_repository 中的用户名。 该配置的文件名任意，例如 main.yml。保存后即可在 Actions 界面查看脚本执行情况。每当 blog_workflow 仓库有新的 push 操作时，就会自动执行该脚本，然后将执行后生成的文件自动提交到 sudrizzz.github.io。\n至此，利用 Github Actions 实现自动部署就已经完成了，写作步骤简化为：\n 在 content/posts/cn/ 目录中新增文章，修改相关头信息，完成内容创作并保存； 执行 hugo server 并访问 localhost:1313 查看文章显示效果； 提交新文章到 blog_workflow； 上述 Action 自动编译并将生成的静态文件部署到 sudrizzz.github.io。  创作流程得到了极大的简化。下面将介绍使用 Github 作为图床的相关配置。\n安装并配置 PicGo 本文使用的方案是 VSCode + PicGo 扩展，所以首先打开 VSCode 安装好 PicGo，此处不再赘述。\n如果需要使用 PicGo Windows 客户端，请点击 https://github.com/Molunerfinn/PicGo/releases 下载，并跳过本节配置说明。\n生成 Token 点击 Github 右上角个人头像，进入 Settings -\u0026gt; Developer settings -\u0026gt; Personal access tokens，点击 Generate new token。\nNote 中可以任意填写，勾选下方的 repo 复选框，点击页面最下方的 Generate token，复制生成的 token 字符串。 配置 PicGo 在 VSCode 中打开 PicGo 的设置界面，将复制的 token 字符串填到 picgo.picBed.github.token 中，具体配置见下图。  picgo.picBed.github.customUrl\n此项是利用 jsDelivr CDN 为图片进行加速服务，填写时只需将 sudrizzz/blog_images 更改为自己的用户名与仓库即可，具体如下。  https://cdn.jsdelivr.net/gh/sudrizzz/blog_images@main  picgo.picBed.github.path\n此项是配置图片的存储路径，根目录为 picgo.picBed.github.repo 中设置的仓库。  当然你可以新建一个仓库专门用来存储图片，只需要调整上述相关设置，使其保持一致即可。\n使用 PicGo 写作 在编写 markdown 文件需要插入图片时，只需要使用相应的快捷键即可完成上传图片操作，具体如下。\n从剪贴板上传图像 Windows / Unix：Ctrl + Alt + U OSX：Cmd + Opt + U 从资源管理器上传图像 Windows / Unix：Ctrl + Alt + E OSX：Cmd + Opt + E 结语 至此，搭建 Github Pages 系列文章就到此结束了，作者的需求基本得到了满足，感谢您的阅读。\n","date":"2020-08-09T15:00:00+08:00","permalink":"https://example.com/posts/integrating-with-github-action/","title":"Github 自动部署与图床"},{"content":"创建仓库 首先需要在 Github 中创建一个名为 \u0026lt;username\u0026gt;.github.io 的仓库，其中 \u0026lt;username\u0026gt; 为你的 Github 用户名。\n 注意：\n由于 username 不方便叙述，故下文中均以 sudrizzz 为例替代 username，\n请根据实际情况进行更改。\n 例如我的 Github 用户名是 sudrizzz，于是创建的仓库名就是 sudrizzz.github.io。\n初始化 Hugo 安装 Hugo 应用 https://github.com/gohugoio/hugo/releases\n配置环境变量 将安装 Hugo 的目录路径配置到用户环境变量 PATH 中，如图 检验配置 在命令行窗口中输入以下内容\n1hugo version 如果得到类似以下的结果则说明配置正确。\nHugo Static Site Generator v0.74.3-DA0437B4 windows/amd64 BuildDate: 2020-07-23T16:23:30Z 创建博客 在命令行中输入以下命令\nhugo new site \u0026lt;blog_name\u0026gt; 上述命令将会创建一个名为 blog_name 的文件夹，请按照个人喜好取名。按照我的博客为例，取名为 sudrizzz.github.io，这样也方便后续进行代码提交\n添加主题 以 yinyang 主题为例，按照文档中的安装步骤，执行以下命令\n1cd sudrizzz.github.io 2git clone git@github.com:joway/hugo-theme-yinyang.git themes/yinyang 进入 sudrizzz.github.io/themes/yinyang/exampleSite 目录，将 content 文件夹和 config.toml 文件拷贝到 sudrizzz.github.io 目录。\n自定义主题 根据 yinyang 主题配置文档，我们可以按需修改其中的内容即可，以下贴出我自定义的配置内容。\n1baseURL = \u0026#34;https://sudrizzz.github.com\u0026#34; 2languageCode = \u0026#34;zh-cn\u0026#34; 3title = \u0026#34;Anthony\u0026#39;s Blog\u0026#34; 4theme = \u0026#34;yinyang\u0026#34; 5DefaultContentLanguage = \u0026#34;cn\u0026#34; 6 7[author] 8 name = \u0026#34;Anthony Qu\u0026#34; 9 homepage = \u0026#34;https://github.com/sudrizzz/\u0026#34; 10 11[languages] 12 # [languages.en] 13 # contentDir = \u0026#34;content/en\u0026#34; 14 # languageName = \u0026#34;English\u0026#34; 15 # weight = 1 16 [languages.cn] 17 contentDir = \u0026#34;content/cn\u0026#34; 18 languageName = \u0026#34;Chinese\u0026#34; 19 weight = 1 20 21[params] 22disqus = \u0026#34;sudri\u0026#34; # disqus account name 23extraHead = \u0026#39;\u0026#39; 24mainSections = [\u0026#34;posts\u0026#34;] 25# googleAnalytics = \u0026#34;\u0026#34; 26# description = \u0026#34;\u0026#34; 27 28[[params.socials]] 29name = \u0026#34;Github\u0026#34; 30link = \u0026#34;https://github.com/sudrizzz/\u0026#34; 31 32[[params.socials]] 33name = \u0026#34;RSS\u0026#34; 34link = \u0026#34;/index.xml\u0026#34; 添加文章 在 sudrizzz.github.io 文件夹中执行以下命令以新增文章\n1hugo new content/cn/posts/my-first-post.md 但是我个人不建议这么操作，原因有两点\n 此主题的 posts 目录分为 cn 和 en，也就是中文和英语目录，路径较长，敲命令不是很方便； md 文件中需要包含特定格式的头信息（如下），才能被正常渲染，而通过上述命令生成的 md 文件是空白文件，自己添加头信息也不太现实。  md 头信息 title: \u0026quot;从零搭建 Github Pages\u0026quot; date: 2020-08-09T00:00:00+08:00 draft: false categories: [\u0026quot;blog\u0026quot;] slug: \u0026quot;build-blog-from-scratch\u0026quot; 其中各项含义如下 title: 文章显示标题 date: 文章创建日期与时间 draft: 是否为草稿状态 categories: 分类信息，可添多个关键词，用半角逗号分隔 slug: 文章渲染后的 url 所以我更推荐直接拷贝已有的文章，然后修改其中的内容（包括头信息）即可。 在此我创建了名为 TestFile.md 的测试文件以作演示，完整内容如下。\n--- title: \u0026quot;这是一个测试文件\u0026quot; date: 2020-01-01T00:00:00+08:00 draft: false categories: [\u0026quot;test\u0026quot;] slug: \u0026quot;this-is-a-test-file\u0026quot; --- This is a test file. Nothing special here. 启动服务 在 sudrizzz.github.io 目录执行以下命令\nhugo server 会得到类似于如下的信息\nBuilding sites … | CN -------------------+----- Pages | 17 Paginator pages | 0 Non-page files | 0 Static files | 13 Processed images | 0 Aliases | 0 Sitemaps | 1 Cleaned | 0 Built in 28 ms Watching for changes in D:\\Blog\\sudrizzz.github.io\\{archetypes,content,layouts,themes} Watching for config changes in D:\\Blog\\sudrizzz.github.io\\config.toml Environment: \u0026quot;development\u0026quot; Serving pages from memory Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender Web Server is available at http://localhost:1313/ (bind address 127.0.0.1) Press Ctrl+C to stop 可以看到最后一行显示已经启动成功，页面地址是 http://localhost:1313/ ，访问这个地址即可看到如下效果。\n点击标题进入文章即可看到全部内容。\n编译文章  说明：\n下述命令中的参数可以根据 Hugo 官方文档按需添加\nhttps://gohugo.io/commands/hugo/#options\n hugo --minify --cleanDestinationDir 可以得到如下结果\nBuilding sites … | CN -------------------+----- Pages | 14 Paginator pages | 0 Non-page files | 0 Static files | 13 Processed images | 0 Aliases | 0 Sitemaps | 1 Cleaned | 0 Total in 29 ms 这样就编译完成了，编译后生成的静态文件放在 sudrizzz.github.io/public 目录下。结构如下：\n├─categories │ └─test ├─css │ └─highlight ├─fonts ├─images ├─js ├─posts │ └─this-is-a-test-file └─tags 至此博客就基本搭建完成了。接下来要做的就是与前文中提到的 Github Pages 仓库结合起来。\n推送到 Github  说明 1：\n此处涉及到 Git 的相关操作，请先根据其他教程配置好 Git 环境再执行命令；\n或者也可以安装一些 Git 可视化工具来简化操作，例如 TortoiseGit。\n  说明 2:\n我们只需要将 Hugo 生成的静态文件托管到 Github，\n所以请确保下述命令是在 /pulic 目录中执行的。\n 在 sudrizzz.github.io/pulic 目录中执行以下命令\n1git clone https://github.com/sudrizzz/sudrizzz.github.io.git 2git add . 3git commit -m \u0026#34;\u0026lt;commit_info\u0026gt;\u0026#34; 4git push origin master 这样博客的所有内容就都已经推送到了 Github，稍等片刻，即可访问 sudrizzz.github.io 查看部署结果。\n总结 前文搭建的博客是由 Github Pages + Hugo 实现的，具体的新增文章步骤可以总结为以下几点。\n 在 content/posts/cn/ 目录中新增文章，修改相关头信息，完成内容创作并保存； 执行 hugo server 并访问 localhost:1313 查看文章显示效果，酌情修改； 执行 hugo --minify --cleanDestinationDir； 进入 /public 目录，将新生成或编辑过的内容推送到 Github，此处不再赘述。  此时我们的博客就创建好了，但是创建文章内容的操作有一些复杂和繁琐，且本文中并未讲解关于 markdown 中插入图片的相关问题。所以在下文中，我们将简化操作步骤，并实现将图片也托管到 Github 的操作。\n","date":"2020-08-09T12:00:00+08:00","permalink":"https://example.com/posts/build-blog-from-scratch/","title":"从零搭建 Github Pages"},{"content":" ……我细读来书，终觉得你不免作茧自缚。你自己去寻出一个本不成问题的问题，“人生有何意义？”其实这个问题是容易解答的。人生的意义全是各人自己寻出来、造出来的：高尚、卑劣、清贵、污浊、有用、无用，……全靠自己的作为。\n 生命本身不过是一件生物学的事实，有什么意义可说？一个人与一只猎，一只狗，有什么分别？人生的意义不在于何以有生，而在自己怎样生活。你若情愿把这六尺之躯葬送在白昼作梦之上二那就是你这一生的意义。你若发愤振作起来，决心去寻求生命的意义，去创造自己的生命的意义，那么，你活一日便有一日的意义，作一事便添一事的意义，生命无穷，生命的意义也无穷了。\n 总之，生命本没有意义，你要能给他什么意义，他就有什么意义。与其终日冥想人生有何意义，不如试用此生作点有意义的事……\n 节选自《答某君书》—— 胡适\n","date":"2019-06-21T00:00:00+08:00","permalink":"https://example.com/posts/the-meaning-of-life/","title":"The meaning of life"}]