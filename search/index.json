[{"content":"文章简介 来源 深度神经网络在用于飞机结冰检测和特征化的飞行中参数识别中的应用\nAn application of Deep Neural Networks to the in-flight parameter identification for detection and characterization of aircraft icing\nhttps://www.sciencedirect.com/science/article/pii/S1270963817318242\n摘要 本文将深度神经网络应用于飞行器结冰的检测和表征的飞行参数识别。作者为预处理输入的飞行状态数据，设计了一种类似于真实图片的“状态图像（state-image）”，然后作者设计了一个 DNN 网络结构，该结构可对飞行状态的本地连通性（local connectivity，使用 CNN）和时间特征（temporal characteristics，使用 RNN）进行建模。在文中，作者对以下几种情形进行了实验，分别是：未结冰（clean）、不同部位结冰（机翼、尾翼、机翼与尾翼）以及结冰严重程度（中等结冰、严重结冰）。同时，作者还提供了基于 DNN 的方法与基于基线 $H_{\\infty}$ 的识别算法（飞机结冰的最新技术）的比较。基于测试和比较结果，基于 DNN 的方法对多参数输入数据能产生更准确的预测性能。\n实验说明 对于中度结冰的情况，$T_{cld}$ = 600（飞机结冰时间），$\\eta_{ice}(T_{cld})$ = 0.20（结冰严重性参数），$\\eta_{ice}(T_{cld}/2)$ = 0.12。对于快速/严重结冰情况，$T_{cld}$ = 300，$\\eta_{ice}(T_{cld})$ = 0.30，$\\eta_{ice}(T_{cld}/2)$ = 0.20。图 1 展示了两种结冰情形的结冰严重性参数变化，以及未结冰对照组的情况。\n数据预处理  作者认为仅识别俯仰和横摆力矩稳定系数（$C_{m_a}$，$C_{n_{\\beta}}$）是有用的。在纵向平面中，作者展示了 2 个稳定性系数（$C_{m_a}$，$C_{z_a}$）和 2 个控制系数（$C_{m_{\\delta_e}}$，$C_{z_{\\delta_e}}$）的性能，而在横向平面中，作者展示了 3 个稳定性系数（$C_{y_\\beta}$，$C_{l_p}$，$C_{n_\\beta}$）和 2 个控制系数（$C_{y_{\\delta_r}}$，$C_{l_{\\delta_a}}$）的结果。\n 为进行本文的参数识别，作者在纵向中指定速度（$V$），体轴上的垂直载荷系数（$g_z$），俯仰率（$q$），俯仰角（$\\theta$）和高度（$H$）作为输入数据。对于横向，作者使用速度（$V$），体轴上的横向负载系数（$g_y$），横摆率（$r$），横摆角（$\\varphi$），偏航角（$r$）和偏航角（$\\psi$）作为输入数据。\n类似于常用的图像（2D 矩阵），作者将飞机结冰数据按照时间划分，将纵向参数分割成 m * n 的矩阵，其中矩阵每行代表一个参数，每列代表某一时刻的所有参数数值；同理，横向参数也划分为 m * n 的矩阵。其中 $n = \\Delta T / \\Delta t$，文中采用时间窗口的方法来采集数据，设定 $\\Delta T=30s$，$n=30$；m 代表参数数量，纵向参数为 5 个，横向参数为 6 个，故对于纵向数据图像尺寸为 5 * 30，横向参数图像尺寸为 6 * 30。完成数据划分后，将图像数据进行了正则化。\n网络结构 纵向参数 输入为 5 * 30 的数据图像，上半部分为 LSTM 网络，下半部分为 CNN 网络，右半部分为全连接网络，输出为 4 个参数，分别为 $C_{m_a}$、 $C_{m_{\\delta_e}}$、$C_{z_a}$ 与 $C_{z_{\\delta_e}}$。\n横向参数 与纵向参数网络类似，输入为 6 * 30 的数据图像，上半部分为 LSTM 网络，下半部分为 CNN 网络，右半部分为全连接网络，输出为 5 个参数，分别为 $C_{y_\\beta}$、$C_{l_p}$、$C_{n_\\beta}$、$C_{y_{\\delta_r}}$ 与 $C_{l_{\\delta_a}}$。\n模拟数据 上图为 Case 0 与 Case 6 两个例子的数据。所有例子如下\n Case 0: 未结冰 Case 1: 机翼，中等结冰 Case 2: 机翼，严重结冰 Case 3: 尾翼，中等结冰 Case 4: 尾翼，严重结冰 Case 5: 机翼与尾翼，中等结冰 Case 6: 机翼与尾翼，严重结冰  作者总共生成了 210 组模拟数据，其中 140 组数据用于训练，70 组数据用于测试。每一份模拟数据总时长 900 秒，因此对于训练集，数据总时长达 35 小时（140 * 900 秒），对于测试集，数据总时长达 17.5 小时（70 * 900 秒）。\n实验结果 纵向平面 横向平面 如上图所述，红色粗实线表示真实值，绿色实线表示 DNN 网络预测值，蓝色虚线表示 $H_{\\infty}$ 识别算法得到的结果。根据 $H_{\\infty}$ 算法，只有纵向的 $C_{m_a}$ 和横向的 $C_{n_\\beta}$ 足够精确。如图所示，这两个参数的 $H_{\\infty}$ 识别结果相当准确。$H_{\\infty}$ 的其他结果可能会出现不稳定的漂移（$C_{z_a}$，$C_{y_\\beta}$ 等），或者毫无意义。与基于 $H_{\\infty}$ 的方法相比，对于 $H_{\\infty}$ 所要求的参数，DNN 也能产生准确的结果（$C_{m_a}$，$C_{n_\\beta}$）。并且对于 $H_{\\infty}$ 无法处理的参数（$C_{z_a}$，$C_{m_{\\delta_e}}$，$C_{y_\\beta}$，$C_{l_{\\delta_a}}$ 等），DNN 输出仍然相当准确。\n误差定量分析 当我们将参数识别问题建模为状态跟踪问题时；跟踪误差的 RMSE 值越低，表明跟踪越准确且更及时。因此，基于 DNN 的框架的参数识别性能被认为优于基于基线 $H_{\\infty}$ 的方法。\n","date":"2021-04-20T08:00:00+08:00","permalink":"https://sudrizzz.github.io/posts/airplane-icing-paper-reading-note-1/","title":"飞机结冰论文阅读 1"},{"content":"安装 ShareLaTeX 1sudo su 2docker pull kingsleyluoxin/sharelatex:full 编辑配置 在 ~/sharelatex 中放入配置文件 docker-compose.yml，并进行编辑。\n1cd ~/sharelatex 2vim docker-compose.yml 完整配置如下\n1version:\u0026#34;2.2\u0026#34;2services:3sharelatex:4restart:always5image:kingsleyluoxin/sharelatex:full6container_name:sharelatex7depends_on:8mongo:9condition:service_healthy10redis:11condition:service_started12ports:13- 80:8014links:15- mongo16- redis17volumes:18- ~/sharelatex_data:/var/lib/sharelatex19environment:20SHARELATEX_APP_NAME:Overleaf Community Edition2122SHARELATEX_MONGO_URL:mongodb://mongo/sharelatex2324SHARELATEX_REDIS_HOST:redis25REDIS_HOST:redis2627ENABLED_LINKED_FILE_TYPES:\u0026#34;url,project_file\u0026#34;2829ENABLE_CONVERSIONS:\u0026#34;true\u0026#34;3031# Disables email confirmation requirement32EMAIL_CONFIRMATION_DISABLED:\u0026#34;true\u0026#34;3334TEXMFVAR:/var/lib/sharelatex/tmp/texmf-var3536## Set for SSL via nginx-proxy37#VIRTUAL_HOST: 103.112.212.223839SHARELATEX_SITE_URL:http://172.23.253.11340SHARELATEX_ADMIN_EMAIL:username@qq.com4142SHARELATEX_EMAIL_FROM_ADDRESS:\u0026#34;username@qq.com\u0026#34;4344SHARELATEX_EMAIL_SMTP_HOST:smtp.qq.com45SHARELATEX_EMAIL_SMTP_PORT:46546SHARELATEX_EMAIL_SMTP_SECURE:\u0026#34;true\u0026#34;47SHARELATEX_EMAIL_SMTP_USER:username@qq.com48SHARELATEX_EMAIL_SMTP_PASS:SMTP 授权码49SHARELATEX_EMAIL_SMTP_TLS_REJECT_UNAUTH:\u0026#34;true\u0026#34;50SHARELATEX_EMAIL_SMTP_IGNORE_TLS:\u0026#34;false\u0026#34;51# SHARELATEX_CUSTOM_EMAIL_FOOTER: \u0026#34;This system is run by department x\u0026#34;5253mongo:54restart:always55image:mongo:4.056container_name:mongo57expose:58- 2701759volumes:60- ~/mongo_data:/data/db61healthcheck:62test:echo \u0026#39;db.stats().ok\u0026#39; | mongo localhost:27017/test --quiet63interval:10s64timeout:10s65retries:56667redis:68restart:always69image:redis:570container_name:redis71expose:72- 637973volumes:74- ~/redis_data:/data初始化容器 1cd ~/sharelatex 2docker-compose up -d 停止、重启服务 可以先使用以下命令查看正在运行的 docker 服务\n1docker ps -a 输出如下\nCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 471e68a315b9 kingsleyluoxin/sharelatex:full \u0026quot;/sbin/my_init\u0026quot; 2 hours ago Up 2 hours 0.0.0.0:80-\u0026gt;80/tcp sharelatex 86213089675e redis:5 \u0026quot;docker-entrypoint.s…\u0026quot; 2 hours ago Up 2 hours 6379/tcp redis 2ae87df3ecc0 mongo:4.0 \u0026quot;docker-entrypoint.s…\u0026quot; 2 hours ago Up 2 hours (healthy) 27017/tcp mongo 使用以下命令可以停止服务\n1docker stop sharelatex 2docker stop redis 3docker stop mongo 使用以下命令可以重启服务\n1docker restart sharelatex 2docker restart redis 3docker restart mongo ","date":"2021-03-11T08:00:00+08:00","permalink":"https://sudrizzz.github.io/posts/docker-host-sharelatex/","title":"Docker 搭建 ShareLaTeX"},{"content":"5 神经网络 5.1 神经元模型 神经网络是由具有适应性的简单单元组成的广泛并行互连的网络，它的组织能够模拟生物神经系统对真实世界物体所作出的交互反应。我们在机器学习中谈论神经网络时指的是“神经网络学习”。\n神经网络中最基本的成分是神经元（neuron）模型，即上述定义中的“简单单元”。在生物神经网络中，每个神经元与其他神经元相连，当它“兴奋”时，就会向相连的神经元发送化学物质，从而改变这些神经元内的电位；如果某神经元的电位超过了一个“阈值”（threshold），那么它就会被激活。即“兴奋”起来，向其他神经元发送化学物质。\n1943 年，[McCulloch and Pitts,1943] 将上述情形抽象为下图所示的简单模型，这就是一直沿用至今的“M-P 神经元模型”。在这个模型中，神经元接收到来自 n 个其他神经元传递过来的输入信号，这些输入信号通过带权重的连接（connection）进行传递，神经元接收到的总输入值将与神经元的阈值进行比较，然后通过“激活函数”（activation function）处理以产生神经元的输出。\n激活函数是将输入值映射为输出值“0”或“1”的一类函数，“0”代表神经元抑制，“1”代表神经元兴奋。常见的激活函数主要包括三种：阶跃函数，Sigmoid 函数和 ReLU 函数。\n 阶跃函数  $$ f(x) = \\begin{cases} 0, \u0026amp;x\u0026lt;0; \\\\ 1, \u0026amp;x \\geq 0; \\end{cases} $$\nSigmoid 函数  $$ f(x) = \\frac{1}{1+e^{-x}} $$\nReLU 函数  $$ f(x) = \\begin{cases} 0, \u0026amp;x\u0026lt;0; \\\\ x, \u0026amp;x \\geq 0; \\end{cases} $$\n5.2 感知机与多层网络 感知机（Perceptron）由两层神经元组成，如下图所示，输入层接收外界输入信号后传递给输出层，输出层是 M-P 神经元，亦称“阈值逻辑单元”（threshold logic unit）。感知机能容易地实现逻辑与、或、非运算。\n需注意的是,感知机只有输出层神经元进行激活函数处理,即只拥有一层功能神经元（functional neuron），其学习能力非常有限。\n一般的，常见的神经网络是形如下图所示的层级结构，每层神经元与下一层神经元全互连，神经元之间不存在同层连接，也不存在跨层连接。这样的神经网络结构通常称为“多层前馈神经网络”（multi-layer feedforward neural networks），其中输入层神经元接收外界输入，隐层与输出层神经元对信号进行加工，最终结果由输出层神经元输出；换言之，输入层神经元仅是接受输入，不进行函数处理，隐层与输出层包含功能神经元。因此，下图通常被称为“两层网络”或“单隐层网络”。只需包含隐层，即可称为多层网络。\n神经网络的学习过程，就是根据训练数据来调整神经元之间的“连接权”（connection weight）以及每个功能神经元的阈值；换言之，神经网络“学”到的东西，蕴涵在连接权与阈值中。\n5.3 误差逆传播算法 多层网络的学习能力比单层感知机强得多．欲训练多层网络，需要更强大的学习算法。误差逆传播（errorBackPropagation，简称 BP）算法就是其中最杰出的代表，它是迄今最成功的神经网络学习算法。现实任务中使用神经网络时，大多是在使用 BP 算法进行训练。值得指出的是，BP 算法不仅可用于多层前馈神经网络，还可用于其他类型的神经网络。但通常说“BP 网络”时，一般是指用 BP 算法训练的多层前馈神经网络。\n对每个训练样例, BP 算法执行以下操作：\n 先将输入示例提供给输入层神经元，然后逐层将信号前传，直到产生输出层的结果 然后计算输出层的误差，再将误差逆向传播至隐层神经元 最后根据隐层神经元的误差来对连接权和阈值进行调整  该迭代过程循环进行，直到达到某些停止条件为止，例如训练误差已达到一个很小的值。\n需要注意的是，BP 算法的目标是要最小化训练集 $D$ 上的累计误差\n$$ E = \\frac{1}{m} \\sum_{k=1}^{m}{E_k} $$\n[Hornik et al., 1989]证明，只需一个包含足够多神经元的隐层，多层前馈网络就能以任意精度逼近任意复杂度的连续函数。然而，如何设置隐层神经元的个数仍是个未决问题，实际应用中通常靠“试错法”（trial-by-error）调整。\n正是由于其强大的表示能力，BP 神经网络经常遭遇过拟合，其训练误差持续降低，但测试误差却可能上升。有两种策略常用来缓解 BP 网络的过拟合：\n 早停（early stopping）：将数据分成训练集和验证集，训练集用来计算梯度、更新连接权和阈值，验证集用来估计误差，若训练集误差降低但验证集误差升高，则停止训练，同时返回具有最小验证集误差的连接权和阈值 正则化（regularization），其基本思想是在误差目标函数中增加一个用于描述网络复杂度的部分。  5.4 全局最小与局部极小 参数空间内梯度为零的点，只要其误差函数值小于邻点的误差函数值，就是局部极小点；可能存在多个局部极小值，但却只会有一个全局最小值。也就是说，“全局最小”一定是“局部极小”，反之则不成立。\n基于梯度的搜索是使用最为广泛的参数寻优方法。在此类方法中，我们从某些初始解出发，迭代寻找最优参数值。每次迭代中,我们先计算误差函数在当前点的梯度，然后根据梯度确定搜索方向。例如，由于负梯度方向是函数值下降最快的方向，因此梯度下降法就是沿着负梯度方向搜索最优解。若误差函数在当前点的梯度为零，则已达到局部极小，更新量将为零，这意味着参数的迭代更新将在此停止。显然，如果误差函数仅有一个局部极小，那么此时找到的局部极小就是全局最小；然而，如果误差函数具有多个局部极小，则不能保证找到的解是全局最小。对后一种情形，我们称参数寻优陷入了局部极小，这显然不是我们所希望的。\n在现实任务中，人们常采用以下策略来试图“跳出”局部极小，从而进一步接近全局最小：\n 以多组不同参数值初始化多个神经网络，按标准方法训练后，取其中误差最小的解作为最终参数。这相当于从多个不同的初始点开始搜索。这样就可能陷入不同的局部极小，从中进行选择有可能获得更接近全局最小的结果。 使用模拟退火（simulated annealing）技术。模拟退火在每一步都以一定的概率接受比当前解更差的结果，从而有助于“跳出”局部极小。在每步迭代过程中，接受“次优解”的概率要随着时间的推移而逐渐降低，从而保证算法稳定。 使用随机梯度下降。与标准梯度下降法精确计算梯度不同，随机梯度下降法在计算梯度时加入了随机因素。于是，即便陷入局部极小点，它计算出的梯度仍可能不为零，这样就有机会跳出局部极小继续搜索。  此外，遗传算法（genetic algorithms）也常用来训练神经网络以更好地逼近全局最小。\n5.6 深度学习 典型的深度学习模型就是很深层的神经网络。显然，对神经网络模型，提高容量的一个简单办法是增加隐层的数目。隐层多了，相应的神经元连接权、阈值等参数就会更多。模型复杂度也可通过单纯增加隐层神经元的数目来实现，前面我们谈到过，单隐层的多层前馈网络已具有很强大的学习能力；但从增加模型复杂度的角度来看，增加隐层的数目显然比增加隐层神经元的数目更有效，因为增加隐层数不仅增加了拥有激活函数的神经元数目，还增加了激活函数嵌套的层数。然而，多隐层神经网络难以直接用经典算法（例如标准 BP 算法）进行训练，因为误差在多隐层内逆传播时，往往会“发散”（diverge）而不能收敛到稳定状态。\n无监督逐层训练（unsupervised layer-wise training）是多隐层网络训练的有效手段，其基本思想是每次训练一层隐结点，训练时将上一层隐结点的输出作为输入，而本层隐结点的输出作为下一层隐结点的输入，这称为“预训练”（pre-training）；在预训练全部完成后，再对整个网络进行“微调”（fine-tuning）训练。\n事实上，“预训练+微调”的做法可视为将大量参数分组，对每组先找到局部看来比较好的设置，然后再基于这些局部较优的结果联合起来进行全局寻优。这样就在利用了模型大量参数所提供的自由度的同时，有效地节省了训练开销。\n另一种节省训练开销的策略是“权共享”（weight sharing），即让一组神经元使用相同的连接权。\n","date":"2021-02-16T08:00:00+08:00","permalink":"https://sudrizzz.github.io/posts/machine-learning-note-4/","title":"《机器学习》笔记（第五章）"},{"content":"4 决策树 4.1 基本流程 一般的，一棵决策树包含一个根结点、若干个内部结点和若干个叶结点；叶结点对应于决策结果，其他每个结点则对应于一个属性测试；每个结点包含的样本集合根据属性测试的结果被划分到子结点中；根结点包含样本全集。从根结点到每个叶结点的路径对应了一个判定测试序列。决策树学习的目的是为了产生一棵泛化能力强，即处理未见示例能力强的决策树，其基本流程遵循简单且直观的“分而治之”（divide-and-conquer）策略。\n4.2 划分选择 一般而言，随着划分过程不断进行，我们希望决策树的分支结点所包含的样本尽可能属于同一类别，即结点的纯度（purity）越来越高。\n4.2.1 信息增益 信息熵定义为信息的期望值。如果待分类的事物可能划分在多个分类之中，则符号 $x_i$ 的信息定义为\n$$ l(x_i) = -\\log_{2} p(x_i) $$\n其中，$p(x_i)$ 是选择该分类的概率。\n则 $D$ 的信息熵定义为\n$$ Ent(D) = -\\sum_{i=1}^{n} p(x_i) \\log_{2} p(x_i) $$\n其中，$n$ 是分类的数目。$Ent(D)$ 的值越小，则 $D$ 的纯度越高。\n假定离散属性 $a$ 有 $V$ 个可能的取值 ${a^1, a^2,\u0026hellip;, a^V}$，若使用 $a$ 来对样本集 $D$ 进行划分，则会产生 $V$ 个分支结点，其中第 $v$ 个分支结点包含了 $D$ 中所有在属性 $a$ 上取值为 $a^V$ 的样本，记为 $D^V$。我们可根据上式计算出 $D^V$ 的信息熵，再考虑到不同的分支结点所包含的样本数不同，给分支结点赋予权重 $|D^v|/|D|$ ，即样本数越多的分支结点的影响越大，于是可计算出用属性 $a$ 对样本集 $D$ 进行划分所获得的“信息增益”(information gain)\n$$ Gain(D, a) = Ent(D) - \\sum_{v=1}^{V} \\frac{|D^v|}{|D|}Ent(D^v) $$\n一般而言，信息增益越大，则意味着使用属性 $a$ 来进行划分所获得的“纯度提升”越大。因此，我们可用信息增益来进行决策树的划分属性选择。即选择属性：\n$$ a_* = \\mathop{argmin}\\limits_{a \\in A} Gain(D, a) $$\n4.2.2 增益率 实际上，信息增益准则对可取值数目较多的属性有所偏好，为减少这种偏好可能带来的不利影响，著名的 C4.5 决策树算法 [Quinlan,1993] 不直接使用信息增益，而是使用“增益率”（gain ratio）来选择最优划分属性。采用与上式相同的符号表示，增益率定义为：\n$$ Gain_ratio(D, a) = \\frac{Gain(D, a)}{IV(a)} $$\n其中\n$$ IV(a) = - \\sum_{v=1}^{V} \\frac{|D^v|}{|D|} log_2 \\frac{|D^v|}{|D|} $$\n称为属性 $a$ 的“固有值”。属性 $a$ 的可能取值数目越多（即 $V$ 越大），则 $IV(a)$ 的值通常会越大。\n需注意的是，增益率准则对可取值数目较少的属性有所偏好，因此，C4.5 算法并不是直接选择增益率最大的候选划分属性，而是使用了一个启发式：先从候选划分属性中找出信息增益高于平均水平的属性，再从中选择增益率最高的。\n4.2.3 基尼指数 CART 决策树 [Breiman et al., 1984] 使用“基尼指数”（Gini index）来选择划分属性。数据集 $D$ 的纯度可用基尼值来度量:\n$$ Gini(D) = \\sum_{k=1}^{|y|}\\sum_{k' \\neq k}p_k p_{k'} = 1 - \\sum_{k=1}^{|y|}p_k^2 $$\n直观来说，$Gini(D)$ 反映了从数据集 $D$ 中随机抽取两个样本，其类别标记不一致的概率。因此，$Gini(D)$越小，则数据集 $D$ 的纯度越高。属性 $a$ 的基尼指数定义为：\n$$ Gini\\_index(D, a) = \\sum_{v=1}^V\\frac{|D^v|}{|D|}Gini(D^v) $$\n于是，我们在候选属性集合 $A$ 中，选择那个使得划分后基尼指数最小的属性作为最优划分属性，即：\n$$ a_* = \\mathop{argmin}\\limits_{a \\in A} Gini\\_index(D, a) $$\n4.3 剪枝处理 剪枝（pruning）是决策树学习算法对付“过拟合”的主要手段。\n决策树剪枝的基本策略有“预剪枝”（prepruning）和“后剪枝”（postpruning）。预剪枝是指在决策树生成过程中，对每个结点在划分前先进行估计，若当前结点的划分不能带来决策树泛化性能提升，则停止划分并将当前结点标记为叶结点；后剪枝则是先从训练集生成一棵完整的决策树，然后自底向上地对非叶结点进行考察，若将该结点对应的子树替换为叶结点能带来决策树泛化性能提升，则将该子树替换为叶结点。\n4.3.1 预剪枝 基于书上 80-82 页的例子可以看出，预剪枝使得决策树的很多分支都没有“展开”，这不仅降低了过拟合的风险，还显著减少了决策树的训练时间开销和测试时间开销。但另一方面，有些分支的当前划分虽不能提升泛化性能、甚至可能导致泛化性能暂时下降，但在其基础上进行的后续划分却有可能导致性能显著提高；预剪枝基于“贪心”本质禁止这些分支展开，给预剪枝决策树带来了欠拟合的风险。\n4.3.2 后剪枝 基于书上 82 页的例子可以看出，后剪枝决策树通常比预剪枝决策树保留了更多的分支。一般情形下，后剪枝决策树的欠拟合风险很小，泛化性能往往优于预剪枝决策树。但后剪枝过程是在生成完全决策树之后进行的，并且要自底向上地对树中的所有非叶结点进行逐一考察，因此其训练时间开销比未剪枝决策树和预剪枝决策树都要大得多。\n4.4 连续与缺失值 4.4.1 连续值处理 给定样本集 $D$ 和连续属性 $a$，假定 $a$ 在 $D$ 上出现了 $n$ 个不同的取值，将这些值从小到大进行排序，记为 ${a1, a2,\u0026hellip;, a^n}$。基于划分点 $t$ 可将 $D$ 分为子集 $D_t^-$ 和 $D_t^+$，其中 $D_t^-$ 包含那些在属性 $a$ 上取值不大于 $t$ 的样本，而 $D_t^+$ 则包含那些在属性 $a$ 上取值大于 $t$ 的样本。显然，对相邻的属性取值 $a^i$ 与 $a^{i+1}$ 来说，$t$ 在区间 $[a^i, a^{i+1})$ 中取任意值所产生的划分结果相同。因此，对连续属性 $a$，我们可考察包含 $n-1$ 个元素的候选划分点集合\n$$ T_a = {\\frac{a^i + a^{i+1}}{2} | 1 \\leq i \\leq n-1} $$\n即把区间 $[a^i, a^{i+1})$ 的中位点 $\\frac{a^i+a^{i+1}}{2}$ 作为候选划分点。然后，我们就可像离散属性值一样来考察这些划分点，选取最优的划分点进行样本集合的划分。\n$$ Gain(D, a) = \\max_{t \\in T_a} Gain(D, a, t) \\\\ = \\max_{t \\in T_a}Ent(D) - \\sum_{\\lambda \\in {-, +}} \\frac{|D_t^\\lambda|}{D} Ent(D_t^\\lambda) $$\n其中 $Gain(D, a, t)$ 是样本集 $D$ 基于划分点 $t$ 二分后的信息增益。于是，我们就可选择使 $Gain(D, a, t)$ 最大化的划分点。\n4.4.2 缺失值处理 书中对于属性缺失值的样本仅仅介绍了 C4.5 算法中的处理方法，具体如下：\n 将属性无缺失值的样本挑选出来形成一个样例子集 $\\tilde{D}$ 对 $\\tilde{D}$ 做信息熵计算，计算各属性的信息增益 将各个信息增益还原到全体样本，即 $Gain(D, 属性) = \\rho \\times Gain(\\tilde{D}, 属性)$，其中 $\\rho$ 指 $\\tilde{D}$ 与 $D$ 的比例 选择信息增益最大的属性进行划分，并重复上述步骤  另外，还有其他方法来处理属性缺失值这一情况。\n对于离散值属性，可以采用众数填充或相关性最高的列填充的方式，来填充缺失值。\n对于连续值属性，可以对使用中位数填充，也可以对相关性最高的列做线性回归进行估计。\n4.5 多变量决策树 简而言之，单变量决策树（上述决策树）非叶节点，只针对某个（单个）属性取值进行测试分类；而多变量决策树非叶节点，不仅仅局限于单个属性取值，而是对多个属性取值的线性组合进行测试分类。\n","date":"2021-02-02T08:00:00+08:00","permalink":"https://sudrizzz.github.io/posts/machine-learning-note-3/","title":"《机器学习》笔记（第四章）"},{"content":"前言 在上一篇文章中，我们使用 Python 使用 SAE 网络实现了手写数字的重建。在本文中，我们将尝试使用 tiny_dnn 库实现手写数字重建。\ntiny_dnn 简介 tiny-dnn 项目地址：https://github.com/tiny-dnn/tiny-dnn，这是深度学习的一个 C ++ 14 实现。它适合在有限的计算资源，嵌入式系统和 IoT 设备上进行深度学习。整个项目仅由头文件构成，使用时无需编译，直接引用即可。\n搭建环境 版本要求 需要一个 C++ 14 编译器，例如 gcc 4.9+，clang 3.6+ 或者 VS 2015+。本文中使用 Visual Studio 2019 为例进行配置。\n创建项目 打开 VS，创建一个名为 testTinyDNN 的控制台应用。将 tiny_dnn 下载解压之后，放置到如下图所示的位置，与 testTinyDNN.cpp 属于同一层级。\n编辑配置  编辑 config.h 文件第 61 行，将其取消注释；这样我们才可以将栈式自编码器预测的图片保存到本地。涉及内容如下：  1/** 2* Enable Image API support. 3* Currently we use stb by default. 4**/ 5#define DNN_USE_IMAGE_API 编辑 image.h 文件第 378 行，将 border_width 值设置为 0，这样保存的图片每个像素周围就不会存在白色边框。涉及内容如下：  1const size_t border_width = 0; 编写代码 打开 testTinyDNN.cpp 文件，将下列代码粘贴进去。\n1#include \u0026lt;iostream\u0026gt;2#include \u0026lt;string\u0026gt;3#include \u0026#34;tiny_dnn/tiny_dnn.h\u0026#34;4using namespace tiny_dnn; 5using namespace tiny_dnn::activation; 6using namespace tiny_dnn::layers; 7using namespace std; 8 9#define EPOCHS 50 10#define BATCH_SIZE 256 11 12void sae() { 13 // define network, optimizer and engine 14 network\u0026lt;sequential\u0026gt; net; 15 adam optimizer; 16 core::backend_t backend_type = core::default_engine(); 17 18 // construct network layers, include 3 encoder layers and 3 decoder layers 19 net \u0026lt;\u0026lt; fully_connected_layer(784, 128, true, backend_type) \u0026lt;\u0026lt; relu() 20 \u0026lt;\u0026lt; fully_connected_layer(128, 64, true, backend_type) \u0026lt;\u0026lt; relu() 21 \u0026lt;\u0026lt; fully_connected_layer(64, 32, true, backend_type) \u0026lt;\u0026lt; relu() 22 \u0026lt;\u0026lt; fully_connected_layer(32, 64, true, backend_type) \u0026lt;\u0026lt; relu() 23 \u0026lt;\u0026lt; fully_connected_layer(64, 128, true, backend_type) \u0026lt;\u0026lt; sigmoid() 24 \u0026lt;\u0026lt; fully_connected_layer(128, 784, true, backend_type); 25 26 // load MNIST dataset 27 vector\u0026lt;vec_t\u0026gt; train_images, test_images; 28 string data_dir_path = \u0026#34;tiny_dnn/data\u0026#34;; 29 parse_mnist_images(data_dir_path + \u0026#34;/train-images.idx3-ubyte\u0026#34;, 30 \u0026amp;train_images, -1.0, 1.0, 0, 0); 31 parse_mnist_images(data_dir_path + \u0026#34;/t10k-images.idx3-ubyte\u0026#34;, 32 \u0026amp;test_images, -1.0, 1.0, 0, 0); 33 34 cout \u0026lt;\u0026lt; \u0026#34;start training\u0026#34; \u0026lt;\u0026lt; endl; 35 36 // define learning rate (0.05) 37 optimizer.alpha *= static_cast\u0026lt;tiny_dnn::float_t\u0026gt;(0.05); 38 39 // display training progress bar, and show training duration 40 progress_display disp(static_cast\u0026lt;unsigned long\u0026gt;(train_images.size())); 41 timer t; 42 43 // create callback 44 int epoch = 0; 45 auto on_enumerate_epoch = [\u0026amp;]() { 46 epoch++; 47 cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; \u0026lt;\u0026lt; t.elapsed() \u0026lt;\u0026lt; \u0026#34;s elapsed.\u0026#34; \u0026lt;\u0026lt; endl; 48 cout \u0026lt;\u0026lt; \u0026#34;epoch=\u0026#34; \u0026lt;\u0026lt; epoch \u0026lt;\u0026lt; \u0026#34;/\u0026#34; \u0026lt;\u0026lt; EPOCHS \u0026lt;\u0026lt; endl; 49 disp.restart(static_cast\u0026lt;unsigned long\u0026gt;(train_images.size())); 50 t.restart(); 51 }; 52 53 auto on_enumerate_minibatch = [\u0026amp;]() { 54 disp += BATCH_SIZE; 55 }; 56 57 // training 58 net.fit\u0026lt;mse\u0026gt;(optimizer, train_images, train_images, BATCH_SIZE, EPOCHS, 59 on_enumerate_minibatch, on_enumerate_epoch); 60 61 // save model 62 net.save(\u0026#34;sae-net\u0026#34;); 63 cout \u0026lt;\u0026lt; \u0026#34;end training.\u0026#34; \u0026lt;\u0026lt; endl; 64 65 // if the model already exists, you can read it directly 66 //net.load(\u0026#34;sae-net\u0026#34;); 67 68 // save layers to image 69 //for (size_t i = 0; i \u0026lt; net.depth(); i++) { 70 // auto out_img = net[i]-\u0026gt;output_to_image(); 71 // auto filename = \u0026#34;layer_\u0026#34; + to_string(i) + \u0026#34;.bmp\u0026#34;; 72 // out_img.save(filename); 73 //} 74 75 // test and show results 76 for (int i = 0; i \u0026lt; 10; i++) { 77 // get predicted result image 78 auto predict = net.predict(test_images[i]); 79 80 // save predicted result image to file 81 auto image = vec2image\u0026lt;float\u0026gt;(predict, 10, 28); 82 auto filename = \u0026#34;image_predicted_\u0026#34; + to_string(i) + \u0026#34;.bmp\u0026#34;; 83 image.save(filename); 84 85 // save the origin test image to file 86 image = vec2image\u0026lt;float\u0026gt;(test_images[i], 10, 28); 87 filename = \u0026#34;image_test_\u0026#34; + to_string(i) + \u0026#34;.bmp\u0026#34;; 88 image.save(filename); 89 } 90} 91 92int main() { 93 sae(); 94} 在代码中，我们定义了每批次训练数据量为 256 条，总共训练 50 个批次。\n网络结构为 3 个编码层 + 3 个解码层。编码层将数据从 784（28 * 28） 维分别编码（降维）到 128、64、32 维，解码器再将 32 维的编码结果解码（升维）到 64、128、784 维，完成手写数字重建。各层之间的激活函数选用 relu() 与 sigmoid()。\n结果展示 从上到下，第一行为测试图像，第二行为 keras 搭建的 SAE 网络重建图像，第三行为 tiny_dnn 搭建的 SAE 网络重建图像。下面展示数字 2 和 5 重建的详细效果，左侧为 Python 平台重建结果，右侧为 C++ 平台重建结果。\n数字 2\n数字 5\n性能对比 测试使用的 CPU 型号为 Intel i5-4200H，基准频率为 2.80GHz。\n基于 tiny_dnn 的 C++ 平台训练时长为 2624.95 秒，基于 keras 的 Python 平台训练时长为 135.70 秒。在 50 个 epoch 测试中，Python 平台比 C++ 平台快了大约 19 倍，Python 平台 loss 大约为 0.08。由重建图片结果不难看出，Python 平台效果明显优于 C++ 平台。\n存在的不足  C++ 平台目前无法计算每个 epoch 的 loss； 将在 C++ 平台测试更多的 epoch，观察图像重建效果是否会有改善。  参考文献  A simple and basic tutorial of tiny-dnn A quick introduction to tiny-dnn Details about tiny-dnn’s API and short examples  ","date":"2021-01-28T18:00:00+08:00","permalink":"https://sudrizzz.github.io/posts/sae-2/","title":"SAE 入门（二）——基于 tiny_dnn 的手写数字重建"},{"content":"Autoencoder 简介 自编码器（Autoencoder，AE），是一种利用反向传播（backpropagation，BP）算法使得输出值等于输入值的神经网络，它先将输入压缩成潜在空间表征，然后通过这种表征来重构输出。其中，空间表征可以看作是输入数据的高级抽象，通常是将高维度的数据抽象为低维度的数据。\n自编码器由两部分组成：\n编码器：这部分能将输入压缩成潜在空间表征，可以用编码函数 $h=f(x)$ 表示;\n解码器：这部分能重构来自潜在空间表征的输入，可以用解码函数 $r=g(h)$ 表示。\n因此，整个自编码器可以用函数 $g(f(x)) = r$ 来描述，其中输出 $r$ 与原始输入 $x$ 相近。\n自动编码器的目标是最大程度地减少输入和输出之间的重构误差。这有助于自动编码器学习数据中存在的重要功能。当表征很好地重建其输入时，则表示这个表征很好地保留了输入中存在的许多信息。整个过程如下图。\nStacked Autoencoder 简介 Stacked Autoencoder 简写作 SAE。SAE 与 AE 的主要区别在于编码器与解码器的层数，栈式自编码器包含多层隐藏层。具体网络结构如下图所示，图中有两层编码层，两层解码层。\n代码实现  代码环境配置，请参考 GAN 网络之手写数字生成 第一小节——环境搭建。\n 自编码器只是一种思想，在具体实现中，编码器和解码器可以由多种深度学习模型构成，例如全连接层、卷积层和 LSTM 等，以下使用 Keras 来实现栈式自编码器。\n1from keras.datasets import mnist 2from keras.layers import Input, Dense 3from keras.models import Model 4import numpy as np 5import matplotlib.pyplot as plt 6 7EPOCHS = 50 8BATCH_SIZE = 256 9 10 11def train(x_train, x_test): 12 input_img = Input(shape=(784,)) 13 14 # 三个编码层，将数据从 784 维向量编码为 128、64、32 维向量 15 encoded = Dense(units=128, activation=\u0026#39;relu\u0026#39;)(input_img) 16 encoded = Dense(units=64, activation=\u0026#39;relu\u0026#39;)(encoded) 17 encoded = Dense(units=32, activation=\u0026#39;relu\u0026#39;)(encoded) 18 19 # 三个解码层，将数据从 32 维向量解码成 64、128、784 维向量 20 decoded = Dense(units=64, activation=\u0026#39;relu\u0026#39;)(encoded) 21 decoded = Dense(units=128, activation=\u0026#39;relu\u0026#39;)(decoded) 22 decoded = Dense(units=784, activation=\u0026#39;sigmoid\u0026#39;)(decoded) 23 autoencoder = Model(input_img, decoded) 24 encoder = Model(input_img, encoded) 25 26 autoencoder.summary() 27 encoder.summary() 28 29 autoencoder.compile(optimizer=\u0026#39;adam\u0026#39;, loss=\u0026#39;binary_crossentropy\u0026#39;, metrics=[\u0026#39;accuracy\u0026#39;]) 30 autoencoder.fit(x_train, x_train, 31 epochs=EPOCHS, 32 batch_size=BATCH_SIZE, 33 shuffle=True, 34 validation_data=(x_test, x_test)) 35 return encoder, autoencoder 36 37 38def plot(encoded_imgs, decoded_imgs): 39 plt.figure(figsize=(40, 4)) 40 for i in range(10): 41 # 展示原始输入图像 42 ax = plt.subplot(3, 20, i + 1) 43 plt.imshow(x_test[i].reshape(28, 28)) 44 plt.gray() 45 ax.get_xaxis().set_visible(False) 46 ax.get_yaxis().set_visible(False) 47 48 # 展示编码后的图像 49 ax = plt.subplot(3, 20, i + 1 + 20) 50 plt.imshow(encoded_imgs[i].reshape(8, 4)) 51 plt.gray() 52 ax.get_xaxis().set_visible(False) 53 ax.get_yaxis().set_visible(False) 54 55 # 展示解码后的输入图像 56 ax = plt.subplot(3, 20, 2 * 20 + i + 1) 57 plt.imshow(decoded_imgs[i].reshape(28, 28)) 58 plt.gray() 59 ax.get_xaxis().set_visible(False) 60 ax.get_yaxis().set_visible(False) 61 plt.show() 62 63 64if __name__ == \u0026#39;__main__\u0026#39;: 65 # 加载数据，训练数据 60000 条，测试数据 10000 条，数据灰度值 [0, 255] 66 (x_train, _), (x_test, _) = mnist.load_data() 67 68 # 正则化数据，将灰度值区间转换为 [0, 1] 69 x_train = x_train.astype(\u0026#39;float32\u0026#39;) / 255 70 x_test = x_test.astype(\u0026#39;float32\u0026#39;) / 255 71 72 # 将数据集从二维 (28, 28) 矩阵转换为长度为维度是 784 的向量 73 x_train = x_train.reshape(len(x_train), np.prod(x_train.shape[1:])) 74 x_test = x_test.reshape(len(x_test), np.prod(x_test.shape[1:])) 75 print(x_train.shape) 76 print(x_test.shape) 77 78 # 训练数据 79 encoder, autoencoder = train(x_train, x_test) 80 81 # 获取编码后和解码后的图像 82 encoded_imgs = encoder.predict(x_test) 83 decoded_imgs = autoencoder.predict(x_test) 84 85 # 绘制图像 86 plot(encoded_imgs, decoded_imgs) 运行上述代码，可以从输出内容中得到以下信息：\n 输入数据是 60000 张手写数字的灰度图像，灰度取值范围是 [0, 255]，我们将其灰度值按行依次存储到一个 1 * 784 的数组中； 输入数据形如 (0, 0, 0,\u0026hellip;, 84, 185, 159,\u0026hellip;, 170, 52,\u0026hellip;, 0, 0)，我们可以将每张图片（每个向量）理解为一个 784 维空间的中向量； 通过正则化后，输入数据每个维度区间变为 [0, 1]； 编码层将输入的 784 维向量抽象为 128、64、32 维向量（dense，dense_1，dense_2）；  Model: \u0026quot;functional_3\u0026quot; _________________________________________________________________ Layer (type) Output Shape Param # ================================================================= input_1 (InputLayer) [(None, 784)] 0 _________________________________________________________________ dense (Dense) (None, 128) 100480 _________________________________________________________________ dense_1 (Dense) (None, 64) 8256 _________________________________________________________________ dense_2 (Dense) (None, 32) 2080 ================================================================= Total params: 110,816 Trainable params: 110,816 Non-trainable params: 0 _________________________________________________________________ 解码层将抽象后的 32 维向量还原维 64、128、784 维向量（dense_3，dense_4，dense_5）；  Model: \u0026quot;functional_1\u0026quot; _________________________________________________________________ Layer (type) Output Shape Param # ================================================================= input_1 (InputLayer) [(None, 784)] 0 _________________________________________________________________ dense (Dense) (None, 128) 100480 _________________________________________________________________ dense_1 (Dense) (None, 64) 8256 _________________________________________________________________ dense_2 (Dense) (None, 32) 2080 _________________________________________________________________ dense_3 (Dense) (None, 64) 2112 _________________________________________________________________ dense_4 (Dense) (None, 128) 8320 _________________________________________________________________ dense_5 (Dense) (None, 784) 101136 ================================================================= Total params: 222,384 Trainable params: 222,384 Non-trainable params: 0 _________________________________________________________________ 训练完成之后，可以在输出内容中看到详细的训练数据，在 50 次训练之后，loss 已经降低到了 0.08。得到的输出图像如下图所示。\n...... Epoch 48/50 235/235 [==============================] - 3s 12ms/step - loss: 0.0848 - accuracy: 0.0130 - val_loss: 0.0844 - val_accuracy: 0.0147 Epoch 49/50 235/235 [==============================] - 3s 12ms/step - loss: 0.0846 - accuracy: 0.0130 - val_loss: 0.0845 - val_accuracy: 0.0115 Epoch 50/50 235/235 [==============================] - 3s 12ms/step - loss: 0.0845 - accuracy: 0.0139 - val_loss: 0.0840 - val_accuracy: 0.0165 参考文献  Sparse, Stacked and Variational Autoencoder Deep Learning Autoencoders Deep Autoencoder using Keras 自编码器是什么？有什么用？这里有一份入门指南（附代码） 反向传播算法 - 维基百科 Autoencoder - Github  ","date":"2021-01-20T18:00:00+08:00","permalink":"https://sudrizzz.github.io/posts/sae-1/","title":"SAE 入门（一）"},{"content":"3 线性模型 3.1 基本形式 给定由 $d$ 个属性描述的示例 $\\boldsymbol{x}=\\{x_1; x_2;\\cdots;x_d\\}$，其中 $x_i$ 是 $\\boldsymbol{x}$ 在第 $i$ 个属性上的取值，线性模型（linear model）试图学得一个通过属性的线性组合来进行预测的函数，即\n$$ f(\\boldsymbol{x}) = w_1x_1 + w_2x_2 + \\cdots + w_dx_d + b $$\n一般用向量形式写成\n$$ f(\\boldsymbol{x}) = \\boldsymbol{w}^\\mathbf{T}\\boldsymbol{x} + b $$\n其中 $\\boldsymbol{w} = (w_1; w_2; \\cdots; w_d)$，$\\boldsymbol{w}$ 和 $b$ 学得之后，模型就得以确定。\n3.2 线性回归 给定数据集 $D=\\{(x_1, y_1,), (x_2, y_2), \\cdots, (x_m, y_m)\\}$，其中 $\\boldsymbol{x}_i = (x_{i1}; x_{i2}, \\cdots, x_{id})$，$y_i \\in \\mathbb{R}$。“线性回归（linear regression）”试图学得一个线性模型以尽可能准确地预测实值输出标记。\n线性回归试图学得 $f(x_i) = wx_i + b$，使得 $f(x_i) \\simeq y_i$。\n2.3 节中的均方误差是回归任务中最常用的性能度量，因此我们可试图让均方误差最小化，即\n$$ (w^*, b^*) = arg \\min_{(w, b)} \\sum_{i = 1}^{m} (f(x_i) - y_i)^2 \\\\ = arg \\min_{(w, b)} \\sum_{i = 1}^{m} (y_i - wx_i - y_i)^2 $$\n均方误差有非常好的几何意义，它对应了常用的欧几里得距离或简称“欧氏距离”（Euclidean distance）。基于均方误差最小化来进行模型求解的方法称为“最小二乘法”（least square method）。在线性回归中，最小二乘法就是试图找到一条直线，使所有样本到直线上的欧氏距离之和最小。 求解 $w$ 和 $b$ 使 $E_{(w, b)} = \\sum_{i = 1}^m(y_i - wx_i - b)^2$ 最小化的过程，称为线性回归模型的最小二乘“参数估计”（parameter estimation）。我们可将 $E_{(w, b)}$ 分别对 $w$ 和 $b$ 求导，得到\n$$ \\frac{\\partial E_{(w, b)}}{\\partial w} =2\\left(w \\sum_{i=1}^{m} x_{i}^{2}-\\sum_{i=1}^{m}\\left(y_{i}-b\\right) x_{i}\\right) \\\\ \\frac{\\partial E_{(w, b)}}{\\partial b} =2\\left(m b-\\sum_{i=1}^{m}\\left(y_{i}-w x_{i}\\right)\\right) $$\n然后令上述两式为零可得到 $w$ 和 $b$ 最优解的闭式（closed-form）解\n$$ w=\\frac{\\sum_{i=1}^{m} y_{i}\\left(x_{i}-\\bar{x}\\right)}{\\sum_{i=1}^{m} x_{i}^{2}-\\frac{1}{m}\\left(\\sum_{i=1}^{m} x_{i}\\right)^{2}} $$\n$$ b=\\frac{1}{m}\\sum_{i=1}^m(y_i-wx_i) $$\n其中，$\\bar{x}=\\frac{1}{m}\\sum_{i=1}^mx_i$ 为 $x$ 均值。\n线性模型虽简单，却有丰富的变化。例如对于样例 $(\\boldsymbol{x}, y)$，$y\\in \\mathbb{R}$，当我们希望线性模型 $ f(\\boldsymbol{x}) = \\boldsymbol{w}^\\mathbf{T}\\boldsymbol{x} + b $ 的预测值逼近真实标记 $y$ 时，就得到了线性回归模型。为便于观察，我们把线性回归模型简写为\n$$ y = \\boldsymbol{w}^\\mathbf{T}\\boldsymbol{x} + b $$\n可否令模型预测值逼近 $y$ 的衍生物呢？譬如说，假设我们认为示例所对应的输出标记是在指数尺度上变化，那就可将输出标记的对数作为线性模型逼近的目标，即\n$$ \\ln y = \\boldsymbol{w}^\\mathbf{T}\\boldsymbol{x} + b $$\n这就是“对数线性回归”（log-linear regression），它实际上是在试图让 $e^{\\boldsymbol{w}^\\mathbf{T}\\boldsymbol{x} + b}$ 逼近 $y$。上式在形式上仍是线性回归，但实质上已是在求取输入空间到输出空间的非线性函数映射，如下图所示，这里的对数函数起到了将线性回归模型的预测值与真实标记联系起来的作用。\n更一般地，考虑单调可微函数 $g(\\cdot)$，令\n$$ y=g^{-1}(\\boldsymbol{w}^\\mathbf{T}\\boldsymbol{x} + b) $$\n这样得到的模型称为“广义线性模型”（generalized linear model），其中函数 $g(\\cdot)$ 称为“联系函数”（link function）。显然，对数线性回归是广义线性模型在 $g(\\cdot) = \\ln (\\cdot)$ 时的特例。\n3.3 对数几率回归 考虑二分类任务，其输出标记 $y\\in\\{0,1\\}$，而线性回归模型产生的预测值 $z = \\boldsymbol{w}^\\mathbf{T}\\boldsymbol{x} + b $ 是实值，于是我们需将实值 $z$ 转换为 0/1 值。最理想的是“单位阶跃函数”（unit-step function）\n$$ y = \\begin{cases} 0, \u0026amp;z\u0026lt;0; \\\\ 0.5, \u0026amp;z=0; \\\\ 1, \u0026amp;z\u0026gt;0; \\end{cases} $$\n即若预测值 $z$ 大于零就判为正例，小于零则判为反例，预测值为临界值零则可任意判别，如下图所示。\n如果我们希望找到在一定程度上近似单位阶跃函数的“替代函数”（surrogate function），并希望它单调可微。对数几率函数（logistic function）正是这样一个常用的替代函数。\n$$ y = \\frac{1}{1+e^{-z}} $$\n从上图可看出，对数几率函数是一种“Sigmoid 函数”，它将 $z$ 值转化为一个接近 0 或 1 的 $y$ 值，并且其输出值在 $z=0$ 附近变化很陡。将对数几率函数作为 $g^{-1}(\\cdot)$ 代入 $ y=g^{-1}(\\boldsymbol{w}^\\mathbf{T}\\boldsymbol{x} + b) $，得到\n$$ y = \\frac{1}{1+e^{-(\\boldsymbol{w}^\\mathbf{T}\\boldsymbol{x} + b)}} $$\n对上式两边同时取对数，并进行适当变形可得\n$$ \\ln \\frac{y}{1-y} = \\boldsymbol{w}^\\mathbf{T}\\boldsymbol{x} + b $$\n若将 $y$ 视为样本 $\\boldsymbol{x}$ 作为正例的可能性，则 $1-y$ 是其反例可能性，两者的比值\n$$ \\frac{y}{1-y} $$\n称为“几率”（odds），反映了 $\\boldsymbol{x}$ 作为正例的相对可能性。对几率取对数则得到“对数几率”（log odds，亦称 logit）\n$$ \\ln\\frac{y}{1-y} $$\n由此可看出，式 $y = \\frac{1}{1+e^{-(\\boldsymbol{w}^\\mathbf{T}\\boldsymbol{x} + b)}}$ 实际上是在用线性回归模型的预测结果去逼近真实标记的对数几率，因此，其对应的模型称为“对数几率回归”（logisticregression，亦称 logit regression）。\n特别需注意到，虽然对数几率回归的名字是“回归”，但实际却是一种分类学习方法。这种方法有很多优点，例如它是直接对分类可能性进行建模，无需事先假设数据分布，这样就避免了假设分布不准确所带来的问题；它不是仅预测出“类别”，而是可得到近似概率预测，这对许多需利用概率辅助决策的任务很有用；此外，对率函数是任意阶可导的凸函数，有很好的数学性质，现有的许多数值优化算法都可直接用于求取最优解。\n3.4 线性判别分析 线性判别分析（Linear Discriminant Analysis，简称 LDA）是一种经典的线性学习方法，在二分类问题上因为最早由 [Fisher，1936] 提出，亦称“Fisher 判别分析”。\nLDA 的思想非常朴素：给定训练样例集，设法将样例投影到一条直线上，使得同类样例的投影点尽可能接近、异类样例的投影点尽可能远离；在对新样本进行分类时，将其投影到同样的这条直线上，再根据投影点的位置来确定新样本的类别。下图给出了一个二维示意图。\n图中 “+”、“-” 分别代表正例和反例，椭圆表示数据簇的外轮廓，虛线表示投影，红色实心圆和实心三角形分别表示两类样本投影后的中心点。\n3.5 多分类学习 现实中常遇到多分类学习任务。有些二分类学习方法可直接推广到多分类，但在更多情形下，我们是基于一些基本策略，利用二分类学习器来解决多分类问题。\n不失一般性，考虑 N 个类别 $C_1, C_2, \\cdots, C_N$ 多分类学习的基本思路是“拆解法”，即将多分类任务拆为若干个二分类任务求解。具体来说，先对问题进行拆分，然后为拆出的每个二分类任务训练一个分类器；在测试时，对这些分类器的预测结果进行集成以获得最终的多分类结果。这里的关键是如何对多分类任务进行拆分，以及如何对多个分类器进行集成。\n最经典的拆分策略有三种；“一对一”（One vs. One，简称 OvO）、“一对其余”（One vs. Rest，简称 OvR）和“多对多”（Many vs. Many，简称 MvM）。\n给定数据集 $D=\\{(\\boldsymbol{x}_1, y_1,), (\\boldsymbol{x}_2, y_2), \\cdots, (\\boldsymbol{x}_m, y_m)\\}$，$y_i \\in \\{C_1, C_2, \\cdots, C_N\\}$。OvO 将这 $N$ 个类别两两配对，从而产生 $N(N-1)/2$ 个二分类任务，例如 OvO 将为区分类别 $C_i$ 和 $C_j$；训练一个分类器，该分类器把 $D$ 中的 $C_i$ 类样例作为正例, $C_j$ 类样例作为反例。在测试阶段，新样本将同时提交给所有分类器，于是我们将得到 $N(N-1)/2$ 个分类结果，最终结果可通过投票产生：即把被预测得最多的类别作为最终分类结果。下图是 OvO 与 OvR 的示意图。\nOvR 则是每次将一个类的样例作为正例、所有其他类的样例作为反例来训练 N 个分类器。在测试时若仅有一个分类器预测为正类，则对应的类别标记作为最终分类结果，如上图所示，若有多个分类器预测为正类，则通常考虑各 分类器的预测置信度，选择置信度最大的类别标记作为分类结果。\n容易看出，OvR 只需训练 $N$ 个分类器,而 OvO 需训练 $N(N-1)/2$ 个分类器，因此，OvO 的存储开销和测试时间开销通常比 OvR 更大。但在训练时，OvR 的每个分类器均使用全部训练样例，而 OvO 的每个分类器仅用到两个类的样例，因此，在类别很多时，OvO 的训练时间开销通常比 OvR 更小。至于预测性能，则取决于具体的数据分布，在多数情形下两者差不多。\nMvM 是每次将若干个类作为正类，若干个其他类作为反类。显然, OvO 和 OvR 是 MvM 的特例。MvM 的正、反类构造必须有特殊的设计，不能随意选取。这里我们介绍一种最常用的 MvM 技术：“纠错输出码”（Error Correcting Output Codes，简称 ECOC）。\nECOC [Dietterich and Bakiri，1995] 是将编码的思想引入类别拆分，并尽可能在解码过程中具有容错性。ECOC 工作过程主要分为两步:\n  编码：对 $N$ 个类别做 $M$ 次划分，每次划分将一部分类别划为正类，一部分划为反类，从而形成一个二分类训练集；这样一共产生 $M$ 个训练集，可训练出 $M$ 个分类器。\n  解码：$M$ 个分类器分别对测试样本进行预测，这些预测标记组成一个编码。将这个预测编码与每个类别各自的编码进行比较，返回其中距离最小的类别作为最终预测结果。\n  类别划分通过“编码矩阵”（coding matrix）指定。编码矩阵有多种形式，常见的主要有二元码 [Dietterich and Bakiri，1995] 和三元码 [Allwein et al，2000]。前者将每个类别分别指定为正类和反类，后者在正、反类之外，还可指定“停用类”。下图为二元码和三元码的示意图。\n上图中，“+1”、“-1”分别表示学习器 $f_i$ 将该类样本作为正、反例；三元码中“0”表示 $f_i$ 不使用该类样本。\n 海明距离：两个等长编码序列中对应位置的不同字符的个数\n 对同等长度的编码，理论上来说，任意两个类别之间的编码距离越远，则纠错能力越强，也即单个错误不会引起结果剧烈变化。\n3.6 类别不平衡问题 类别不平衡（class-imbalance）就是指分类任务中不同类别的训练样例数目差别很大的情况，例如又 998 个反例，但正例只有 2 个，那么学习方法只需返回一个永远将新样本预测为反例的学习器，就能达到 99.8% 对的精度；然而这样的学习器往往没有价值，因为它不能预测出任何正例。\n从线性分类器的角度讨论容易理解，在我们用 $y = \\boldsymbol{w}^\\mathbf{T}\\boldsymbol{x} + b$ 对新样本 $\\boldsymbol{x}$ 进行分类时，事实上是在用预测出的 $y$ 值与一个阈值进行比较，例如通常在 $y\u0026gt;0.5$ 时判别为正例，否则为反例。$y$ 实际上表达了正例的可能性，几率 $\\frac{y}{1-y}$ 则反映了正例可能性与反例可能性之比值，阈值设置为 0.5 恰表明分类器认为真实正、反例可能性相同，即分类器决策规则为\n$$ 若 \\frac{y}{1-y} \u0026gt; 1 则预测为正例 （式 1）$$\n然而，当训练集中正、反例的数目不同时，令 $m^+$ 表示正例数目，$m^-$ 表示反例数目，则观测几率是 $\\frac{m^+}{m^-}$，由于我们通常假设训练集是真实样本总体的无偏采样，因此观测几率就代表了真实几率。于是，只要分类器的预测几率高于观测几率就应判定为正例，即\n$$ 若 \\frac{y}{1-y} \u0026gt; \\frac{m^+}{m^-} 则预测为正例 （式 2）$$\n但是，我们的分类器是基于式 1 进行决策，因此，需对其预测值进行调整，使其在基于式(3.46)决策时,实际是在执行式 1。要做到这一点很容易，只需令\n$$ \\frac{y'}{1-y'} = \\frac{y}{1-y} \\times \\frac{m^-}{m^+} （式 3）$$\n其中，$\\frac{m^-}{m^+}$ 表示观测反例几率，$\\frac{y}{1-y}$ 表示预测正例几率，这两项相乘得到再缩放预测正例几率。这就是类别不平衡学习的一个基本策略——“再缩放”（rescaling）。\n再缩放的思想虽简单，但实际操作却并不平凡，主要因为“训练集是真实样本总体的无偏采样”这个假设往往并不成立，也就是说，我们未必能有效地基于训练集观测几率来推断出真实几率。现有技术大体上有三类做法：\n 欠采样（undersampling）\n直接对训练集里的反类样例进行“欠采样”（undersampling），即去除一些反例使得正、反例数目接近，然后再进行学习； 过采样（oversampling）\n即增加一些正例使得正、反例数目接近,然后再进行学习; 阈值移动（threshold-moving）\n直接基于原始训练集进行学习，但在用训练好的分类器进行预测时，将式 3 嵌入到其决策过程中。  欠采样法的时间开销通常远小于过采样法，因为前者丢弃了很多反例，使得分类器训练集远小于初始训练集，而过采样法增加了很多正例，其训练集大于初始训练集。\n需注意的是，过采样法不能简单地对初始正例样本进行重复采样，否则会招致严重的过拟合；过采样法的代表性算法 SMOTE[Chawlaetal.,2002] 是通过对训练集里的正例进行插值来产生额外的正例。另一方面，欠采样法若随机丢弃反例，可能丢失一些重要信息；欠采样法的代表性算法 Easy Ensemble[Liu et al.,2009] 则是利用集成学习机制，将反例划分为若干个集合供不同学习器使用，这样对每个学习器来看都进行了欠采样，但在全局来看却不会丢失重要信息。\n值得一提的是，“再缩放”也是“代价敏感学习”（cost-sensitive learning）的基础。在代价敏感学习中将式 3 中的 $m^-/m^+$ 用 $cost^+/cost^-$ 代替即可，其中 $cost^+$ 是将正例误分为反例的代价，$cost^-$ 是将反例误分为正例的代价。\n参考文献  海明距离  ","date":"2020-12-30T17:00:00+08:00","permalink":"https://sudrizzz.github.io/posts/machine-learning-note-2/","title":"《机器学习》笔记（第三章）"},{"content":"《机器学习》笔记系列文章内容按照《机器学习》书本章节进行排布，节号与书中节号一一对应。\n1 绪论 1.2 基本术语    术语 英语原意 释义     数据集 data set 一组关于一个事件或对象的描述的集合   样本 / 示例 sample / instance 数据集中的每条记录   属性 / 特征 attribute / feature 反映样本在某方面的表现或性质的事项   训练数据 training data 用于训练的数据   训练样本 training sample 训练数据中的每个样本   假设 hypothesis 通过训练学得数据的某种规律   真实 ground-truth 潜在规律本身   预测 prediction 训练结果生成的模型   分类 classification 预测离散值   二分类 binary classification 只涉及两个特征的分类   多分类 multi-class classification 涉及多个特征的分类   回归 regression 预测连续值   聚类 clustering 对训练样本进行分组   簇 cluster 聚类后的每一个组   监督学习 supervised learning 训练数据有标记信息的训练（分类与回归）   无监督学习 unsupervised learning 训练数据没有标记信息的训练（聚类）    2 模型评估与选择 2.1 经验误差与过拟合 误差 通常我们把分类错误的样本数占样本总数的比例称为“错误率”（error rate），即如果在 m 个样本中有 a 个样本分类错误，则错误率 $ E = \\frac{a}{m} $； 相应的，$ 1 - \\frac{a}{m} $ 称为“精度”（accuracy），即“精度 = 1 - 错误率”。\n更一般地，我们把学习器的实际预测输出与样本的真实输出之间的差异称为“误差”（error），学习器在训练集上的误差称为”训练误差“（training error） 或“经验误差”（empirical error）, 在新样本上的误差称为“泛化误差”（generalization errorr）。\n过拟合与欠拟合 为了达到更好的学习效果，应该从训练样本中尽可能学出适用于所有潜在样本的“普遍规律”，这样才能在遇到新样本时做出正确的判别。然而，当学习器把训练样本学得“太好”了的时候，很可能已经把训练样本自身的一些特点当作了所有潜在样本都会具有的一般性质，这样就会导致泛化性能下降。这种现象在机器学习中称为“过拟合”（overfitting）。 与“过拟合”相对的是“欠拟合”（underfitting），这是指对训练样本的一般性质尚未学好。\n下图展示了欠拟合与过拟合，蓝色点为训练数据，橙色点为测试数据，红色曲线为拟合曲线。\n最优拟合 欠拟合（underfitting） 过拟合（overfitting） 过拟合的训练误差（蓝色）与泛化误差（红色） 2.2 评估方法 2.2.1 留出法 留出法（hold-out）直接将数据集 $D$ 划分为两个互斥的集合，其中一个集合作为训练集 $S$，另一个作为测试集 $T$，即\n$$ D = S \\cup T , S \\cap T=\\varnothing $$\n需要注意的是训练/测试集的划分要尽可能保持数据分布的一致性，避免因数据划分过程引入额外的偏差而对最终结果产生影响。\n2.2.2 交叉验证法 交叉验证法（cross validation）先将数据集 $D$ 划分为 $k$ 个大小相似的互斥子集，即\n$$ D = D_1 \\cup D_2 \\cup \\dots \\cup D_k , D_i \\cap D_j = \\varnothing (i \\ne j)$$\n每个子集 $D_{i}$ 都尽可能保持数据分布的一致性，即从 $D$ 中通过分层采样得到。然后每次用 $k - 1$ 个子集的并集作为训练集，余下的那个子集作为测试集；这样就可以获得 $k$ 组训练/测试集，从而可进行 $k$ 次训练和测试，最终返回的是这 $k$ 个测试结果得得得均值。显然，交叉验证法评估结果的稳定性和保真性在很大程度上取决于 $k$ 的取值，为强调这一点，通常把交叉验证法称为 ”$k$ 折交叉验证“（$k$-fold cross validation）。$k$ 最常用的取值是 10，此时成为 10 折交叉验证。下图为 10 折交叉验证的示意图。\n假定数据集 $D$ 中包含 $m$ 个样本，令 $k=m$，则得到了交叉验证法的一个特例：留一法（Leave-One-Out，简称 LOO）。显然，留一法不受随机样本划分方式的影响，因为 $m$ 个样本只有唯一的方式划分为 $m$ 个子集——每个子集包含一个样本；留一法使用的训练集与初始数据集相比只少了一个样本，这就使得在绝大多数情况下，留一法中被实际评估的模型与期望评估的用 $D$ 训练出的模型很相似。因此，留一法的评估结果往往被认为比较准确。\n然而，留一法也有其缺陷：在数据集比较大时，训练 $m$ 个模型的计算开销可能是难以忍受的（例如数据集包含 1 百万个样本，则需训练 1 百万个模型)，而这还是在未考虑算法调参的情况下。另外，留一法的估计结果也未必永远比其他评估方法准确；“没有免费的午餐”定理对实验评估方法同样适用。\n2.2.3 自助法 自助法的主要步骤是，给定包含 $m$ 个样本的数据集 $D$，我们对它采样产生数据集 $D^{'}$：每次随机从 $D$ 中挑选一个样本，将其拷贝放入 $D^{'}$，然后再将该样本放回初始数据集 $D$ 中，使得该样本在下次采样时仍有可能被采到；这个过程重复执行 $m$ 次后，我们就得到了包含 $m$ 个样本的数据集 $D^{'}$，这就是自助采样的结果。显然，$D$ 中有一部分样本会在 $D^{'}$中多次出现，而另一部分样本不出现。可以做一个简单的估计，样本在 $m$ 次采样中始终不被采到的概率是 $(1 - \\frac{1}{m})^m$，取极限得到\n$$ \\lim_{m \\rightarrow \\infty } (1 - \\frac{1}{m})^m = \\frac{1}{e} \\approx 0.368 $$\n即通过自助采样，初始数据集 $D$ 中约有 36.8% 的样本未出现在采样数据集 $D^{'}$ 中。于是我们可将 $D^{'}$ 用作训练集, $D$ \\ $D^{'}$ 用作测试集；这样，实际评估的模型与期望评估的模型都使用 $m$ 个训练样本，而我们仍有数据总量约 1/3 的、没在训练集中出现的样本用于测试。这样的测试结果，亦称“包外估计”(out-of-bag estimate)。\n自助法在数据集较小、难以有效划分训练/测试集时很有用；此外，自助法能从初始数据集中产生多个不同的训练集；这对集成学习等方法有很大的好处。然而，自助法产生的数据集改变了初始数据集的分布，这会引入估计偏差。因此，在初始数据量足够时，留出法和交叉验证法更常用一些。\n2.3 性能度量 在预测任务中，给定样例集 $D = \\{ (x_1, y_1), (x_2, y_2), \\dots , (x_m, y_m) \\} $ ，其中 $y_i$ 是 $x_i$ 的真实标记。要评估学习器 $f$ 的性能，就要把学习器预测结果 $f(x)$ 与真实标记 $y$ 进行比较。\n回归任务最常用的性能度量是”均方误差“（mean squared error），即 Loss function\n$$ L(f) = E(f; D) = \\frac{1}{m} \\sum_{i=1}^{m}(f(x_i) - y_i)^2 $$\n更一般的，对于数据分布 $\\mathcal{D}$ 和概率密度函数 $p(\\cdot)$，均方误差可描述为\n$$ L(f) = E(f; D) = \\int_{x\\sim D}^{}(f(x) - y)^2 p(x)dx $$\n则最优学习器 $f^*$ 可以表示为\n$$ f^* = arg \\min_f L(f) $$\n2.3.1 错误率与精度 错误率和精度，这是分类任务中最常用的两种性能度量，既适用于二分类任务，也适用于多分类任务。错误率是分类错误的样本数占样本总数的比例，精度则是分类正确的样本数占样本总数的比例。对样例集 $D$，分类错误率定义为\n$$ E(f; D) = \\frac{1}{m} \\sum_{i=1}^{m} \\mathbb I (f(x_i) \\neq y_i) $$\n精度定义为\n$$ acc(f; D) = \\frac{1}{m} \\sum_{i=1}^{m} \\mathbb I (f(x_i) = y_i) \\\\ = 1 - E(f; D) $$\n更一般的，对于数据分布 $\\mathcal{D}$ 和概率密度函数 $p(\\cdot)$，错误率与精度可分别描述为\n$$ E(f; D) = \\int_{x\\sim D}^{}\\mathbb I (f(x) \\neq y) p(x)dx $$\n$$ acc(f; D) = \\int_{x\\sim D}^{}\\mathbb I (f(x) = y) p(x)dx \\\\ = 1 - E(f; D)$$\n2.3.2 查准率、查全率与 F1 度量 错误率和精度虽常用，但并不能满足所有任务需求。以西瓜问题为例，假定瓜农拉来一车西瓜，我们用训练好的模型对这些西瓜进行判别，显然，错误率衡量了有多少比例的瓜被判别错误。但是若我们关心的是“挑出的西瓜中有多少。比例是好瓜”，或者“所有好瓜中有多少比例被挑了出来”，那么错误率显然就不够用了，这时需要使用其他的性能度量。\n类似的需求在信息检索、Web 搜索等应用中经常出现，例如在信息检索中，我们经常会关心“检索出的信息中有多少比例是用户感兴趣的”，“用户感兴趣的信息中有多少被检索出来了”。“查准率”（precision）与”查全率“（recall）是更为适用于此类需求的性能度量。\n对于二分类问题，可将样例根据其真实类别与学习器预测类别的组合划分为真正例（true positive）、假正例（false positive）、真反例（true negative）、假反例（false negative）四种情形，令 TP、FP、TN、FN 分别表示其对应的样例数，则显然有 TP + FP + TN + FN = 样例总数。分类结果的”混淆矩阵“（confusion matrix）如下表所示。\n查准率 $P$ 与查全率 $R$ 分别定义为\n$$ P = \\frac{TP}{TP + FP} $$\n$$ R = \\frac{TP}{TP + FN} $$\n查准率和查全率是一对矛盾的度量。一般来说，查准率高时，查全率往往偏低；而查全率高时，查准率往往偏低。 我们可以这样理解查准率与查全率：\n 查准率：预测为正例的结果中，真·正例所占的比例；\n查全率：所有正例中，预测为正例所占的比例。\n 在很多情形下，我们可根据学习器的预测结果对样例进行排序，排在前面的是学习器认为”最可能“是正例的样本，排在最后的则是学习器认为”最不可能“是正例的样本。按此顺序逐个把样本作为正例进行预测，则每次可以计算出当前的查全率、查准率。以查准率为纵轴、查全率为横轴作图，就得到了查准率-查全率曲线，简称”P-R 曲线“，显示该曲线的图称为”P-R 图“。下图是”P-R 图“的一个示例。\nP-R 图直观地显示出学习器在样本总体上的查全率、查准率在进行比较时，若一个学习器的 P-R 曲线被另一个学习器的曲线完全”包住“，则可断言后者的性能优于前者，例如上图中学习器 A 的性能优于学习器 C；如果两个学习器的 P-R 曲线发生了交叉，例如上图中的 A 与 B，则难以一般性地断言两者孰优孰劣,只能在具体的查准率或查全率条件下进行比较。然而，在很多情形下，人们往往仍希望把学习器 A 与 B 比出个高低。这时一个比较合理的判据是比较 P-R 曲线下面积的大小，它在一定程度上表征了学习器在查准率和查全率上取得相对”双高“的比例。但这个值不太容易估算，因此，人们设计了一些综合考虑查准率、查全率的性能度量。\n“平衡点”（Break-Event Point，简称 BEP）就是这样一个度量，它是“查准率=查全率”时的取值，例如上图中学习器 C 的 BEP 是 0.64，而基于 BEP 的比较，可认为学习器 A 优于 B。\n2.3.3 ROC 与 AUC 与 2.3.2 节中介绍的 P-R 曲线相似，我们根据学习器的预测结果对样例进行排序，按此顺序逐个把样本作为正例进行预测，每次计算出两个重要量的值，分别以它们为横、纵坐标作图，就得到了“ROC 曲线”。与 P-R 曲线使用查准率、查全率为纵、横轴不同，ROC 曲线的纵轴是“真正例率”（True Positive Rate, 简称 TPR）,横轴是“假正例率”（False PositiveRate，简称 FPR），基于上文中相关表格中的符号，两者分别定义为\n$$ TPR = \\frac{TP}{TP + FN} $$\n$$ FPR = \\frac{FP}{TN + FP} $$\n2.3.4 代价敏感错误率与代价曲线 为权衡不同类型错误所造成的不同损失，可为错误赋予”非均等代价“（unequal cost）。\n以二分类任务为例，我们可根据任务的领域知识设定一个”代价矩阵“（cost matrix），如下表所示，其中 $cost_{ij}$ 表示将第 $i$ 类样本预测为第 $j$ 类样本的代价；一般来说，$cost_{ii} = 0$；若将第 0 类判别为第 1 类所造成的损失更大，则 $cost_{01} \u0026gt; cost_{10}$；损失程度相差越大，$cost_{01}$ 与 $cost_{10}$ 值的差别越大。\n回顾前面介绍的一些性能度量可看出，它们大都隐式地假设了均等代价，并没有考虑不同错误会造成不同的后果。在非均等代价下，我们所希望的不再是简单地最小化错误次数，而是希望最小化“总体代价”（total cost）。若将上表中的第 0 类作为正类、第 1 类作为反类，令 $D^+$ 与 $D^-$ 分别代表样例集 $D$ 的正例子集和反例子集，则“代价敏感”（cost-sensitive）错误率为\n$$ E(f; D; cost) = \\frac{1}{m} (\\sum_{x_i \\in D^+} \\mathbb I (f(x_i) \\neq y_i) \\times cost_{01} \\\\ + \\sum_{x_i \\in D^-} \\mathbb I (f(x_i) \\neq y_i) \\times cost_{10}) $$\n类似的，可给出基于分布定义的代价敏感错误率，以及其他一些性能度量如精度的代价敏感版本。若令 $cost_{ij}$ 中的 $i$、$j$ 取值不限于 0、1, 则可定义出多分类任务的代价敏感性能度量。\n参考文献  过拟合-维基百科 分层抽样 李宏毅机器学习笔记(LeeML-Notes)  ","date":"2020-12-22T09:00:00+08:00","permalink":"https://sudrizzz.github.io/posts/machine-learning-note-1/","title":"《机器学习》笔记（第一、二章）"},{"content":"环境搭建 本例中，所涉及的系统与软件版本列表如下。\n   名称 版本     操作系统 Windows 20H2   Anaconda Anaconda3-2020.11   python 3.6   tensorflow 1.8.0    本例代码存放于 https://github.com/sudrizzz/MachineLearning。\nAnaconda 安装 通过清华大学开源软件镜像站，我们可以直接下载最新版本的 Anaconda，本例中使用的 Anaconda 下载链接： https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-2020.11-Windows-x86_64.exe\nAnaconda 安装教程网络上已经有很多，故此处不再赘述。\n安装完成后，我们需要手动配置 Anaconda 的环境变量，在用户变量的 Path 中添加 Anaconda 的安装路径以及其子文件夹，具体内容如下。\nC:\\Users\\xvyn\\anaconda3 C:\\Users\\xvyn\\anaconda3\\Scripts C:\\Users\\xvyn\\anaconda3\\Library\\bin 上述配置请根据 Anaconda 实际安装路径进行调整，配置完成的效果如下图所示。\n完成后打开 cmd 输入下列命令，如果输出内容与下列内容类似，则表示配置正确，可继续后面的步骤。\n1conda --version 输出 conda 4.9.2  创建虚拟环境 通过如下命令进行创建一个虚拟环境。\n1conda create -n handwrittendigits -n handwrittendigits 的作用是指定虚拟环境的名称，本例中指定为 handwrittendigits。\n执行结束后，可通过下列命令查看 Anaconda 中所有的虚拟环境。\n1conda info --evns 输出如下\n(base) PS C:\\Users\\xvyn\u0026gt; conda info --envs conda environments: base * C:\\Users\\xvyn\\anaconda3 handwrittendigits C:\\Users\\xvyn\\anaconda3\\envs\\handwrittendigits  其中，标记 * 的表示目前已启用，命令行前半部分的 (base) 也表示目前启用的是哪个虚拟环境，此例中为 base 环境。\n切换虚拟环境 如果使用 PowerShell 进行 Anaconda 的一些操作，需要以 管理员 身份运行 PowerShell，然后执行下列命令。\n1set-executionpolicy remotesigned 执行完成后可通过下列命令进行切换虚拟环境。若使用其他 Shell 工具进行操作，则可直接执行下列命令。\n1conda activate handwrittendigits 如果执行时报错如下，则可以通过 https://github.com/conda/conda/issues/7980 来解决。\nCan't execute `conda activate` from batch script  详细操作为：\n 安装并打开 Git Bash 执行 source ~/anaconda3/etc/profile.d/conda.sh 执行 conda init 重启 PowerShell  切换环境操作结束后，可以注意到命令行左侧的括号内容由 (base) 变为 (handwrittendigits)，表明切换成功，后面的操作均在此虚拟环境中进行。\n实际操作过程 (base) PS C:\\Users\\xvyn\u0026gt; conda activate handwrittendigits (handwrittendigits) PS C:\\Users\\xvyn\u0026gt; 再次查看所有虚拟环境 (handwrittendigits) PS C:\\Users\\xvyn\u0026gt; conda info --envs conda environments: base C:\\Users\\xvyn\\anaconda3 handwrittendigits * C:\\Users\\xvyn\\anaconda3\\envs\\handwrittendigits  更换镜像源 由于 Anaconda 和 pip 官方镜像源访问缓慢，故需要将镜像源更换为国内镜像源，例如清华大学、中科大与阿里云镜像源。使用下列命令可以查看当前 Anaconda 镜像源。\n1conda config --show 在输出中找到 channel 部分，有如下内容。\nchannels: - defaults default_channels: - https://repo.anaconda.com/pkgs/main - https://repo.anaconda.com/pkgs/r - https://repo.anaconda.com/pkgs/msys2  更换 Anaconda 镜像源 以清华大学镜像源为例，执行下列命令即可完成更换。\n1conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ 2conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ 3conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/ 4conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/ 5conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda/ 6conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/menpo/ 7conda config --set show_channel_urls yes 恢复默认源\n1conda config --remove-key channels 除了上述命令行操作方式外，也可以直接修改 C:\\Users\u0026lt;USER\u0026gt;\\.condarc 文件来实现换源。参考 Anaconda 镜像使用帮助 修改后的文件内容如下所示。\nssl_verify: false show_channel_urls: true channels: - defaults default_channels: - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/pro - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2 custom_channels: conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  更换 pip 镜像源 以清华大学镜像源为例，执行下列命令即可完成更换。\n1pip config set global.index-url https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple 安装 tensorflow 手写数字生成例子所需要的 tensorflow 版本为 1.x，本例中我们使用的实际版本为 1.8.0。将虚拟环境切换到 handwrittendigits 后，执行以下命令开始安装。\n1conda install tensorflow-gpu=1.8.0 上述命令中 tensorflow-gpu 表示安装的 tensorflow 为 GPU 版本，=1.8.0 指定了安装的版本号。若需要安装 CPU 版 tensorflow 1.8.0，执行以下命令即可。\n1conda install tensorflow=1.8.0 安装 Python 由于需要 1.8.0 版本的 tensorflow，此版本仅兼容 3.5 到 3.7 版本的 Python，故需要先删除 conda 环境中默认安装的 Python，并安装 3.6 版本。\n1# 移除自带 Python 2conda remove python 3 4# 安装 3.6 版本 5conda install python=3.6 测试 Demo 使用 PyCharm 创建项目 在创建项目时，需要将虚拟环境（图中 Location 项）配置为前文中创建的虚拟环境所在目录，然后点击创建项目。\n由于此前作者已经创建过项目，故创建窗口下方会提示虚拟环境目录不为空，忽略即可。\n运行项目 将以下代码置于项目 main.py 中，运行。\n1import tensorflow as tf 2from tensorflow.examples.tutorials.mnist import input_data 3import numpy as np 4import matplotlib.pyplot as plt 5import matplotlib.gridspec as gridspec 6import logging 7import os 8 9if not os.path.exists(\u0026#39;./log\u0026#39;): 10 os.mkdir(\u0026#39;./log\u0026#39;) 11if not os.path.exists(\u0026#39;./out\u0026#39;): 12 os.mkdir(\u0026#39;./out\u0026#39;) 13 14 15def get_logger(filepath, level=logging.INFO): 16 logger = logging.getLogger(__name__) 17 logger.setLevel(level) 18 19 # create a file handler 20 handler = logging.FileHandler(filepath) 21 handler.setLevel(logging.INFO) 22 23 # create a logging format 24 # formatter = logging.Formatter(\u0026#39;%(asctime)s - %(name)s - %(levelname)s - %(message)s\u0026#39;) 25 # handler.setFormatter(formatter) 26 27 # add the handlers to the logger 28 logger.addHandler(handler) 29 return logger 30 31 32def plot(samples): 33 fig = plt.figure(figsize=(4, 4)) 34 gs = gridspec.GridSpec(4, 4) 35 gs.update(wspace=0.05, hspace=0.05) 36 37 for i, sample in enumerate(samples): 38 ax = plt.subplot(gs[i]) 39 plt.axis(\u0026#39;off\u0026#39;) 40 ax.set_xticklabels([]) 41 ax.set_yticklabels([]) 42 ax.set_aspect(\u0026#39;equal\u0026#39;) 43 plt.imshow(sample.reshape(28, 28), cmap=\u0026#39;Greys_r\u0026#39;) 44 45 return fig 46 47 48def random_data(row, column): 49 return np.random.uniform(-1., 1., size=[row, column]) 50 51 52def weight_variable(shape, stddev=0.1): 53 initial = tf.truncated_normal(shape, stddev=stddev) 54 return tf.Variable(initial) 55 56 57def bias_variable(shape, bais=0.1): 58 initial = tf.constant(bais, shape=shape) 59 return tf.Variable(initial) 60 61 62# 鉴别网络weights 63d_w1 = weight_variable([784, 128]) 64d_b1 = bias_variable([128]) 65 66d_w2 = weight_variable([128, 1]) 67d_b2 = bias_variable([1]) 68 69param_d = [d_w1, d_w2, d_b1, d_b2] 70 71# 生成网络weights 72g_w1 = weight_variable([100, 128]) 73g_b1 = bias_variable([128]) 74 75g_w2 = weight_variable([128, 784]) 76g_b2 = bias_variable([784]) 77 78param_g = [g_w1, g_w2, g_b1, g_b2] 79 80 81# 鉴别网络 82def d_network(x): 83 d1 = tf.nn.relu(tf.matmul(x, d_w1) + d_b1) 84 d_out = tf.matmul(d1, d_w2) + d_b2 85 return tf.nn.sigmoid(d_out) 86 87 88# 生成网络 89def g_network(x): 90 g1 = tf.nn.relu(tf.matmul(x, g_w1) + g_b1) 91 g_out = tf.matmul(g1, g_w2) + g_b2 92 return tf.nn.sigmoid(g_out) 93 94 95x = tf.placeholder(tf.float32, shape=[None, 784]) 96z = tf.placeholder(tf.float32, shape=[None, 100]) 97 98d_out_real = d_network(x) 99 100g_out = g_network(z) 101d_out_fake = d_network(g_out) 102 103d_loss = -tf.reduce_mean(tf.log(d_out_real) + tf.log(1. - d_out_fake)) 104g_loss = -tf.reduce_mean(tf.log(d_out_fake)) 105 106d_optimizer = tf.train.AdamOptimizer().minimize(d_loss, var_list=param_d) 107g_optimizer = tf.train.AdamOptimizer().minimize(g_loss, var_list=param_g) 108 109batch_size = 256 110max_step = 1000000 111mnist = input_data.read_data_sets(\u0026#39;../mnist\u0026#39;, one_hot=True) 112logger = get_logger(\u0026#34;./log/info.log\u0026#34;) 113 114with tf.Session() as sess: 115 sess.run(tf.global_variables_initializer()) 116 print(\u0026#34;training\u0026#34;) 117 i = 0 118 for step in range(max_step): 119 batch_real, _ = mnist.train.next_batch(batch_size) 120 _, d_loss_train = sess.run([d_optimizer, d_loss], feed_dict={x: batch_real, z: random_data(batch_size, 100)}) 121 _, g_loss_train = sess.run([g_optimizer, g_loss], feed_dict={z: random_data(batch_size, 100)}) 122 123 if step % 1000 == 0: 124 samples = sess.run(g_out, feed_dict={z: random_data(16, 100)}) 125 126 fig = plot(samples) 127 plt.savefig(\u0026#39;out/{}.png\u0026#39;.format(str(i).zfill(4)), bbox_inches=\u0026#39;tight\u0026#39;) 128 i += 1 129 plt.close(fig) 130 131 logger.info(\u0026#34;step %s: d_loss is %s, gan_loss is %s\u0026#34; % (step, d_loss_train, g_loss_train)) 132 print(\u0026#34;step %s: d_loss is %s, g_loss is %s\u0026#34; % (step, d_loss_train, g_loss_train)) 运行时的截图如下，可以看到已经生成了多张手写数字的图片。\n至此，GAN 网络手写数字生成环境搭建已经完成，后续将进行更加深入的学习。\n参考文章  Anaconda 源使用帮助 gan_practice Can\u0026rsquo;t execute conda activate from bash script python 安装 TensorFlow 吐血整理 conda 安装指定版本的指定包 Python pip 命令行设置国内镜像源  ","date":"2020-12-08T10:00:00+08:00","permalink":"https://sudrizzz.github.io/posts/gan-for-hand-written-digits/","title":"GAN 网络之手写数字生成"},{"content":"FastDFS 简介 FastDFS 是一个开源的高性能分布式文件系统（Distributed File System）。它的主要功能包括：文件存储、文件同步和文件访问以及高容量和负载平衡。主要解决了海量数据存储问题，特别适合以中小文件（建议范围：4KB \u0026lt; file_size \u0026lt; 500MB）为载体的在线服务。\nFastDFS 开源地址：https://github.com/happyfish100/fastdfs\n由于网络上已有很多详细的关于 FastDFS 的介绍，故此处不再赘述。请查看参考文章中的第 1、2 条。\nFastDFS 架构图 FastDFS 上传流程 FastDFS 下载流程 安装 FastDFS 配置防火墙 本篇文章是基于 CentOS v8.2.2004 版本，以下操作均为单机环境，单机 IP 地址为 192.168.61.128。在安装 FastDFS 之前，需要先进行防火墙的设置。防火墙的相关命令如下：\n1# 暂时关闭防火墙 2systemctl stop firewalld 3 4# 永久关闭防火墙 5systemctl disable firewalld 6 7# 启用防火墙 8systemctl enable firewalld 下载安装 libfastcommon libfastcommon 是从 FastDFS 抽取出来的公共 c 函数库。\n1# 下载 2wget https://github.com/happyfish100/libfastcommon/archive/V1.0.43.tar.gz 3 4# 解压 5tar -zxvf V1.0.43.tar.gz 6cd libfastcommon-1.0.43 7 8# 编译安装 9./make.sh 10./make.sh install libfastcommon.so 安装到了 /usr/lib64/libfastcommon.so，但是 FastDFS 主程序设置的 lib 目录是 /usr/local/lib，所以需要创建软链接。\n1ln -s /usr/lib64/libfastcommon.so /usr/local/lib/libfastcommon.so 2ln -s /usr/lib64/libfastcommon.so /usr/lib/libfastcommon.so 3ln -s /usr/lib64/libfdfsclient.so /usr/local/lib/libfdfsclient.so 4ln -s /usr/lib64/libfdfsclient.so /usr/lib/libfdfsclient.so 下载安装 FastDFS 1# 下载 2wget https://github.com/happyfish100/fastdfs/archive/V6.06.tar.gz 3 4# 解压 5tar -zxvf V6.06.tar.gz 6cd fastdfs-6.06 7 8# 编译安装 9./make.sh 10./make.sh install 安装完成之后，服务脚本存储在 /etc/init.d/ 中，详细文件如下：\n/etc/init.d/fdfs_storaged /etc/init.d/fdfs_tracker  默认配置文件存储在 /etc/fdfs/ 中，详细文件如下：\n/etc/fdfs/client.conf.sample /etc/fdfs/storage.conf.sample /etc/fdfs/tracker.conf.sample  命令工具存储在 /usr/bin/ 中，详细文件如下：\nfdfs_appender_test fdfs_appender_test1 fdfs_append_file fdfs_crc32 fdfs_delete_file fdfs_download_file fdfs_file_info fdfs_monitor fdfs_regenerate_filename fdfs_storaged fdfs_test fdfs_test1 fdfs_trackerd fdfs_upload_appender fdfs_upload_file stop.sh restart.sh  配置 FastDFS Tracker 服务 修改配置文件 从上文可知，配置文件在 /etc/fdfs/ 中，我们需要拷贝一份并进行一些修改。\n1cd /etc/fdfs 2cp tracker.conf.sample tracker.conf 3vim tracker.conf 需要修改的部分如下：\n# Tracker 数据和日志存储目录 base_path = /home/fastdfs/tracker # HTTP 服务端口 http.server_port = 80 根据上述配置，创建配置中的目录\n1mkdir -p /home/fastdfs/tracker 启动 Tracker 服务 初次成功启动，会在 base_path 即 /home/fastdfs/tracker 下创建 data、logs 两个目录。启动命令如下：\n1/etc/init.d/fdfs_trackerd start 2# 或 3service fdfs_trackerd start 启动后，可以通过 netstat 命令查看是都启动成功，若得到以下类似输出，22122 端口处于监听状态，则表示 Tracker 服务安装并启动成功。\n1netstat -unltp | grep fdfs # 输出内容 tcp 0 0 0.0.0.0:22122 0.0.0.0:* LISTEN 6220/fdfs_trackerd  同理，可以通过下列命令关闭 Tracker 服务或者设置 Tracker 开机自启：\n1# 关闭服务 2service fdfs_trackerd stop 3 4# 开机自启 5chkconfig fdfs_trackerd on 配置 FastDFS Storage 服务 修改配置文件 与配置 Tracker 服务类似，首先我们也需要拷贝样例配置文件并进行相应修改。\n1cd /etc/fdfs 2cp storage.conf.sample storage.conf 3vim storage.conf 需要修改的部分如下：\n# Tracker 数据和日志存储目录 base_path = /home/fastdfs/storage # 存放文件时 storage server 支持多个路径。这里配置存放文件的基路径数目，通常只配一个目录 store_path_count=1 # 逐一配置 store_path_count 个路径，索引号基于 0 # 如果不配置 store_path0，那它就和 base_path 对应的路径一样 store_path0=/home/fastdfs/file # FastDFS 存储文件时，采用了两级目录。这里配置存放文件的目录个数。 # 如果本参数为 N（默认 256），那么 storage server 在初次运行时，会在 store_path 下自动创建 N*N 个存放文件的子目录 subdir_count_per_path=256 # tracker_server 的列表 ，会主动连接 tracker_server # 有多个 tracker server 时，每个 tracker server 写一行 tracker_server=192.168.61.128:22122 # HTTP 服务端口 http.server_port = 80 根据上述配置，创建配置中的目录\n1# base_path 2mkdir -p /home/fastdfs/storage 3 4# store_path0 5mkdir -p /home/fastdfs/file 启动 Storage 服务 启动 Storage 前确保 Tracker 是启动的。初次启动成功，会在 base_path 即 /home/fastdfs/storage/ 目录下创建 data、logs 两个目录。启动命令如下：\n1/etc/init.d/fdfs_storaged start 2# 或 3service fdfs_storaged start 启动后，可以通过下列命令查看 Storage 服务是否启动成功。若输出结果与下列输出类似，23000 端口正处于监听状态，则 Storage 服务启动成功。\n1netstat -unltp | grep fdfs # 输出内容 tcp 0 0 0.0.0.0:23000 0.0.0.0:* LISTEN 6257/fdfs_storaged tcp 0 0 0.0.0.0:22122 0.0.0.0:* LISTEN 6220/fdfs_trackerd  同理，可以通过下列命令关闭 Tracker 服务或者设置 Tracker 开机自启：\n1# 关闭服务 2service fdfs_storaged stop 3 4# 开机自启 5chkconfig fdfs_storaged on 此时我们可以在 store_path0 目录下看到 Storage 服务自动创建的 N*N 个子目录\n1ls /home/fastdfs/file/data/ 2 3# 统计文件夹数量 4ls -l | grep \u0026#34;^d\u0026#34; | wc -l 5 6cd 00 7ls -l | grep \u0026#34;^d\u0026#34; | wc -l # 输出内容 00 0A 14 1E 28 32 3C 46 50 5A 64 6E 78 82 8C 96 A0 AA B4 BE C8 D2 DC E6 F0 FA 01 0B 15 1F 29 33 3D 47 51 5B 65 6F 79 83 8D 97 A1 AB B5 BF C9 D3 DD E7 F1 FB 02 0C 16 20 2A 34 3E 48 52 5C 66 70 7A 84 8E 98 A2 AC B6 C0 CA D4 DE E8 F2 FC 03 0D 17 21 2B 35 3F 49 53 5D 67 71 7B 85 8F 99 A3 AD B7 C1 CB D5 DF E9 F3 FD 04 0E 18 22 2C 36 40 4A 54 5E 68 72 7C 86 90 9A A4 AE B8 C2 CC D6 E0 EA F4 FE 05 0F 19 23 2D 37 41 4B 55 5F 69 73 7D 87 91 9B A5 AF B9 C3 CD D7 E1 EB F5 FF 06 10 1A 24 2E 38 42 4C 56 60 6A 74 7E 88 92 9C A6 B0 BA C4 CE D8 E2 EC F6 07 11 1B 25 2F 39 43 4D 57 61 6B 75 7F 89 93 9D A7 B1 BB C5 CF D9 E3 ED F7 08 12 1C 26 30 3A 44 4E 58 62 6C 76 80 8A 94 9E A8 B2 BC C6 D0 DA E4 EE F8 09 13 1D 27 31 3B 45 4F 59 63 6D 77 81 8B 95 9F A9 B3 BD C7 D1 DB E5 EF F9 256 256  文件上传测试 修改配置文件 与配置 Storage 服务类似，首先我们也需要拷贝客户端样例配置文件并进行相应修改。\n1cd /etc/fdfs 2cp client.conf.sample client.conf 3vim client.conf 需要修改的部分如下：\n# Client 的数据和日志目录 base_path=/home/fastdfs/client # Tracker端口 tracker_server=192.168.61.128:22122 上传图片测试 执行下列命令，尝试上传一张图片到 FastDFS 中：\n1fdfs_upload_file /home/Pictures/1989.jpg 上传成功后，会输出文件 ID：group1/M00/00/00/wKg9gF-f0aKAUJAlAARra4mLMhc390.jpg\n返回的文件 ID 由 group、存储目录、两级子目录、fileid、文件后缀名（由客户端指定，主要用于区分文件类型）拼接而成。\n配置 Nginx 安装 Nginx 的相关操作请查看文章 初识 Nginx，此处不再赘述。\n修改配置 经过上述操作之后，文件已经可以通过命令行的方式上传到 FastDFS 中，但还无法下载，此时我们需要使用 Nginx 来实现下载功能。修改 Nginx 配置文件，在 server 组内添加以下内容：\nserver { listen 80; server_name localhost; # 添加以下部分 location /group1/M00 { alias /home/fastdfs/file/data; } } 然后重启 Nginx，访问服务器 ip/fileid 进行测试，根据上述例子，此处访问 http://192.168.61.128/group1/M00/00/00/wKg9gF-f0aKAUJAlAARra4mLMhc390.jpg\n测试结果如下图，可以看到已经访问成功，HTTP 状态码返回 200。\n配置 fastdfs-nginx-module 模块 模块简介 fastdfs-nginx-module 可以重定向文件链接到源服务器，避免由于 Storage 服务器复制延迟导致文件无法访问而产生的错误。\n下载解压 1wget https://github.com/happyfish100/fastdfs-nginx-module/archive/V1.22.tar.gz 2tar -zxvf V1.22.tar.gz 3cd fastdfs-nginx-module 为 Nginx 添加模块 首先进入 Nginx 源目录，然后执行 ./configure 命令，具体命令如下：\n1nginx -s stop 2cd /usr/local/software/nginx-1.18.0 3./configure --prefix=/usr/local/nginx/ --add-module=$YOUR_PATH/fastdfs-nginx-module/src 4make \u0026amp;\u0026amp; make install 其中，/usr/local/software/nginx-1.18.0 为 Nginx 源目录，--prefix 参数指定新版本生成的目录，--add-module 参数表示添加模块，$YOUR_PATH 需要手动替换为 fastdfs-nginx-module 模块的文件路径，本例中为 /usr/local/software/fastdfs-nginx-module。\n安装好之后可以通过以下命令查看 Nginx 模块，如果输出与下列内容类似，则表示模块添加成功。\nnginx -V # 输出内容 nginx version: nginx/1.18.0 built by gcc 8.3.1 20191121 (Red Hat 8.3.1-5) (GCC) configure arguments: --prefix=/usr/local/nginx/ --add-module=/usr/local/software/fastdfs-nginx-module/src  修改 Nginx 配置 修改 nginx.conf，在 server 中做出如下修改：\nserver { listen 80; server_name localhost; # 删除以下部分 location /group1/M00 { alias /home/fastdfs/file/data; } # 添加以下部分 location ~/group[0-9]/ { ngx_fastdfs_module; } } 修改 fastdfs-nginx-module 配置 复制 fastdfs-nginx-module 源码中的配置文件到 /etc/fdfs 目录，兵做以下修改。\n1cd /usr/local/software/fastdfs-nginx-module/src 2cp mod_fastdfs.conf /etc/fdfs/ # Tracker Server tracker_server=192.168.61.128:22122 # Storage Server 默认端口 storage_server_port=23000 # 如果文件 ID 的 uri 中包含 /group**，则要设置为 true url_have_group_name = true # Storage 配置的 store_path0 路径，必须和 storage.conf 中的一致 store_path0=/home/fastdfs/file 复制 FastDFS 的部分配置文件到 /etc/fdfs 目录\n1cd /usr/local/software/fastdfs-5.05/conf/ 2cp anti-steal.jpg http.conf mime.types /etc/fdfs/ 测试 配置完成之后，我们先启动 Nginx 服务，并观察输出内容，如果与下列输出类似，则表示配置成功。\n1nginx # 输出内容 ngx_http_fastdfs_set pid=11648  此时我们可以在浏览器中访问前文中上传的文件，能下载文件则表示 fastdfs-nginx-module 模块安装成功。注意和和前文中直接使用 Nginx 路由访问不同的是，这里配置 fastdfs-nginx-module 模块，可以重定向文件链接到源服务器取文件。访问结果如下图所示。\n至此，FastDFS 搭建分布式文件管理系统就初步完成了，在下一篇文章中，将介绍如何在客户端上通过 Java 来实现文件的上传和下载。\n参考文章  用 FastDFS 一步步搭建文件管理系统 FastDFS 简介 FastDFS Distributed File Storage FastDFS 配置文件详解（修订版 1） 初识 Nginx fastdfs nginx module installation introduction  ","date":"2020-11-04T17:00:00+08:00","permalink":"https://sudrizzz.github.io/posts/getting-to-know-fastdfs/","title":"FastDFS 搭建分布式文件管理系统"},{"content":"Spark 简介 Spark 是一种基于内存的、用以实现高效集群计算的平台。准确地讲，Spark 是一个大数据并行计算框架，是对广泛使用的 MapReduce 计算模型的扩展。Spark 有着自己的生态系统，但同时兼容 HDFS、Hive 等分布式存储系统，可以完美融入 Hadoop 的生态圈中，代替 MapReduce 去执行更为高效的分布式计算。两者的区别在于：基于 MapReduce 的计算引擎通常会将中间结果输出到磁盘上进行存储和容错；而 Spark 则是将中间结果尽量保存在内存中以减少底层存储系统的 I/O，以提高计算速度。\nSpark 编程模型 核心数据结构 RDD Spark 将数据抽象成弹性分布式数据集（Resilient Distributed Dataset, RDD），RDD 实际是分布在集群多个节点上数据的集合，通过操作 RDD 对象来并行化操作集群上的分布式数据。\nRDD 有两种创建方式:\n 并行化驱动程序中已有的原生集合; 引用 HDFS、HBase 等外部存储系统上的数据集。  RDD 可以缓存在内存中，每次对 RDD 操作的结果都可以放到内存中，下一次操作时可直接从内存中读取，相对于 MapReduce,它省去了大量的磁盘 I/O 操作。另外，持久化的 RDD 能够在错误中自动恢复，如果某部分 RDD 丢失，Spark 会自动重算丢失的部分。\nRDD 上的操作 从相关数据源获取初始数据形成初始 RDD 后，需要根据应用的需求对得到的初始 RDD 进行必要的处理，来获取满足需求的数据内容，从而对中间数据进行计算加工，得到最终的数据。\nRDD 支持两种操作，一种是转换（Transformation）操作，另一种是行动（Action）操作。\n转换（Transformation）操作 转换操作即将一个 RDD 转换为一个新的 RDD。值得注意的是，转换操作是惰性的，这就意味着对 RDD 调用某种转换操作时，操作并不会立即执行，而是 Spark 在内部记录下所要求执行的操作的相关信息，当在行动操作中需要用到这些转换出来的 RDD 时才会被计算，下表所示为基本的转换操作。通过转换操作，可以从已有的 RDD 生成出新的 RDD, Spark 使用谱系（Lineage）记录新旧 RDD 之间的依赖关系，一旦持久化的 RDD 丢失部分数据时，Spark 能通过谱系图重新计算丢失的数据。\n 输入数据为 {1, 2, 3, 3}\n    函数名 目的 示例 结果     map() 将数据集中的每个元素经过用户自定义的函数转换形成一个新的 RDD rdd.map(x =\u0026gt; x * 2) {2, 4, 6, 6}   flatMap() 与 map() 类似，但每个元素输入项都可以被映射到 0 个或多个的输出项，最终将结果“扁平化“后输出 rdd.flatMap(x =\u0026gt; (1 to x)) {1, 1, 2, 1, 2, 3, 1, 2, 3, 3}   filter() 对 RDD 元素进行过滤，把经过指定函数后返回值为 true 的元素组成一个新的 RDD rdd.filter(x =\u0026gt; (x != 3)) {1, 2}   distinct() 对数据进行去重，返回一个新的 RDD rdd.distinct() {1, 2, 3}   sample(withReplacement, fraction, seed) 以指定的随机种子随机抽样出数量为 fraction 的数据，withReplacement 表示是抽出的数据是否放回，true 为有放回的抽样，false 为无放回的抽样 rdd.sample(true,0.5,3) 非确定的    行动（Action）操作 行动操作会触发 Spark 提交作业，对 RDD 进行实际的计算，并将最终求得的结果返回到驱动器程序，或者写入外部存储系统中。由于行动操作会得到一个结果，所以 Spark 会强制对 RDD 的转换操作进行求值，下表所示为基本的行动操作。\n 输入数据为 {1, 2, 3, 3}\n    函数名 目的 示例 结果     collect() 返回 RDD 中的所有元素 rdd.collect() {1, 2, 3, 3}   count() 返回 RDD 中元素的个数 rdd.count() 4   countByValue() 返回 RDD 中各元素出现的次数 rdd.countByValue() {(1, 1), (2, 1), (3, 2)}   take(n) 从 RDD 中返回 n 个元素（任意位置） rdd.take(2) {2, 3}   top(n) 从 RDD 中返回前 n 个元素 rdd.top(2) {1, 2}   reduce(func) 并行整合 RDD 中的所有数据 rdd.reduce((x, y) =\u0026gt; x + y) 9   fold(zero)(func) 与 reduce() 类似，但需要提供初始值。加法的默认是 0；乘法的默认是 1 rdd.fold(1)((x, y) =\u0026gt; x + y) 10   aggregate() 与 reduce() 类似，但通常返回不同类型的函数 rdd.aggregate((0, 0))((x, y) =\u0026gt; (x._1 + y, x._2 + 1), (x, y) =\u0026gt; (x._1 + y._1, x._2 + y._2)) (9, 4)   foreach(func) 对 RDD 中的每个元素使用给定的函数 rdd.foreach(func) 无    示例 以下两个示例的数据集与源代码均可以在下述链接中进行下载 https://github.com/sudrizzz/BigDataTechnologyFoundation_SourceCodeAndDataSet/tree/main/ch08\n一、分词 WordCount（单词统计程序）是大数据领域经典的例子，与 Hadoop 实现的 WordCount 程序相比，Spark 实现的版本要显得更加简洁。\n从 MapReduce 到 Spark 在经典的计算框架 MapReduce 中，问题会被拆成两个主要阶段: map 阶段和 reduce 阶段。对单词计数来说，MapReduce 程序从 HDFS 中读取一行字符串。在 map 阶段，将字符串分割成单词，并生成 \u0026lt;word, 1\u0026gt; 这样的键值对；在 reduce 阶段，将单词对应的计数值（初始为 1）全部累加起来，最后得到单词的总出现次数。\n在 Spark 中，并没有 map/reduce 这样的划分，而是以 RDD 的转换来呈现程序的逻辑。首先，Spark 程序将从 HDFS 中按行读取的文本作为初始 RDD（即集合的每一个元素都是一行字符串）；然后，通过 flatMap 操作将每一行字符串分割成单词，并收集起来作为新的单词 RDD；接着，使用 map 操作将每一个单词映射成 \u0026lt;word, 1\u0026gt;这样的键值对，转换成新的键值对 RDD；最后，通过 reduceByKey 操作将相同单词的计数值累加起来，得到单词的总出现次数。\nJava 实现 1import org.apache.spark.SparkConf; 2import org.apache.spark.api.java.JavaPairRDD; 3import org.apache.spark.api.java.JavaRDD; 4import org.apache.spark.api.java.JavaSparkContext; 5import scala.Tuple2; 6 7import java.util.Arrays; 8import java.util.List; 9import java.util.regex.Pattern; 10 11public class SparkDemo { 12 private static final Pattern kSpace = Pattern.compile(\u0026#34; \u0026#34;); 13 14 public static void main(String[] args) { 15 SparkConf conf = new SparkConf().setAppName(\u0026#34;WordCount\u0026#34;); 16 JavaSparkContext sc = new JavaSparkContext(conf); 17 18 JavaRDD\u0026lt;String\u0026gt; lines = sc.textFile(args[0]).rdd().toJavaRDD(); 19 JavaRDD\u0026lt;String\u0026gt; words = lines.flatMap(s -\u0026gt; Arrays.asList(kSpace.split(s)).iterator()); 20 JavaPairRDD\u0026lt;String, Integer\u0026gt; ones = words.mapToPair(s -\u0026gt; new Tuple2\u0026lt;\u0026gt;(s, 1)); 21 JavaPairRDD\u0026lt;String, Integer\u0026gt; counts = ones.reduceByKey(Integer::sum); 22 List\u0026lt;Tuple2\u0026lt;String, Integer\u0026gt;\u0026gt; output = counts.collect(); 23 24 for (Tuple2\u0026lt;String, Integer\u0026gt; tuple : output) { 25 System.out.println(tuple._1() + \u0026#34; : \u0026#34; + tuple._2()); 26 } 27 sc.close(); 28 } 29} 运行过程分析  初始化 创建配置文件 SparkConf，这里仅设置应用名称；再创建 JavaSparkContext，在程序中主要通过 JavaSparkContext 来访问 Spark 集群； 处理数据  根据参数使用 Spark.read().textFile() 方法按行读取输入文件，并转换成 RDD lines； 使用 flatMap 操作将所有行按空格分割切割成词，并生成新的 RDD words； 使用 map 操作( Java 中为 mapToPair )，将词映射成 \u0026lt;word, 1\u0026gt;键值对 RDD ones，其中 1 表示出现一次； 使用 reduceByKey 操作将所有相同的 word 对应的计数累加起来，得到新的 RDD counts； 使用 collect 操作将所有结果打印出来；   关闭 JavaSparkContext。  执行 将上述代码生成 Jar 包之后，将其放到服务器中，执行下面的命令即可开始运行。\n1./bin/spark-submit --class SparkDemo ~/Documents/SparkDemo.jar ~/Documents/sample.txt 其中\n \u0026ndash;class SparkDemo 用来指定主类名 ~/Documents/SparkDemo.jar 指定 Jar 包路径 ~/Documents/sample.txt 指定测试文本路径  sample.txt 文本内容如下所示\nYour want text it even a text notes having wrong even about fake want or not even but. Language way contentwise just language contentwise recipes set start are. Recipes a words than with meeting days ?looks? even than is name story more story words generator anything gone. Having story but fairly random some adequate want it set has a kind looking having. Fantasy anything you looks just copy work text random sets even fake having. Piece some recipes repetitive adequate wrong wrong way options to repetitive working some dummy repetitive copy realistic you fake. Work or just fairly with is unrelated having language about set forever not game repetitive adequate now you looks it of even dummy now. That but design language unrelated copy you text placeholder has review those of with fake. Random to want the has gardening which business some realistic that and just work. Gardening you realistic kind and name looks about name words words way which some name. The that copy story realistic the adequate text meeting options game gone piece has options has name random. Days wrong set realistic design repetitive adequate review text your or but having start about right are story fairly fairly but to language sets adequate. But work want sets right kind some having contentwise fairly convincing language notes right name from but want realistic unrelated words. From about generator not looks or fairly copy has more. Forever from gone which or that having a with some having the work wrong generator design a fantasy way convincing. Working in dummy not now happily but to it of happily story want those kind looking right words business it generator language are. A you anything sets fake sets kind notes meeting having has in copy realistic is you. Copy or fairly set story. Wrong and days not work of want piece options unrelated way random just just recipes. Your recipes gardening start fairly. Happily start game days want from in set meeting that forever random. Support has wrong than your language are random business a even design has. Way design dummy unrelated set generator game convincing. Text contentwise copy to of set kind notes a you ?looks? gone work. Way forever result you to not. Your your meeting generator way placeholder looking than has want in repetitive more kind start has you but language a. A than notes name story and a just days some with in options looking just not are want looks. Kind some from review even. Some start random meeting recipes is a a ?looks? unrelated more the about but are dummy. Words review fake now kind of you meeting it design your. To just a about to. Not realistic name from with fake is. Work even business options fake wrong result notes want the more has dummy a notes random. Gone right repetitive fairly want now it want days review. Has notes want random name that random fantasy not unrelated in is dummy work work random game design now. Business result a and piece from working. Your some recipes copy sets are has kind story support fantasy has and some fantasy a which anything are the. Language piece that kind copy right anything dummy a of copy which fantasy placeholder which the work are convincing random. Your gone way copy you copy are that game but looking gardening result is start text the words the a anything. Want piece set set fantasy generator sets a more are happily or ?looks? just the and sets not anything. Support to just start game work looks copy that in of but words placeholder support now fairly fake even now. Text adequate words not fairly looks from game that result name realistic or you fake working want. Kind you some looking of review has sets than want the way working has. Of fantasy gardening and kind just game those adequate your from or text are you story working happily. Business set way gardening more dummy want are you business ?looks? work to placeholder are design options sets having. Working from options work right not meeting story it is of which way fake meeting. Adequate story than words want the anything. Language some gone random or just fairly gone which adequate sets having and adequate or text random from review. From unrelated those a start the ?looks? game business. With copy and which set kind game contentwise which anything the set story notes about or forever. Way anything work ?looks? a contentwise adequate and meeting. Options which realistic words it of to right game random way random your those and those anything some you notes gone gardening dummy than fake. But language just a your work with that set the. Are dummy business story not gardening start wrong fantasy fake and words having text which recipes your ?looks? wrong or. Generator fake than set looking text now forever more design ?looks? text but than has than wrong. Way than fake gardening those a now it language but piece. A is even looks just result that which realistic gone are working right fake some. Which language wrong having with that looks. 执行结果如下所示\nright : 9 Fantasy : 1 review : 5 convincing : 2 is : 8 Business : 2 even : 1 Are : 1 even : 10 start : 10 // 此处省略数行  二、统计用户的视频上传数 场景分析 接下来使用 Spark 来统计 Youtube 的测试数据集中每个用户的视频上传数量。稍加分析，会发现统计每个用户的视频数量其实与 WordCount 中统计每个单词出现的次数的逻辑几乎一致，区别在于处理 Youtube 测试数据集的格式略为复杂些。将给定的数据集按行划分，每行代表一条记录，除了视频类别这一字段中间有可能出现空格之外，其他的字段都是用空格分割。可以考虑使用正则表达式来匹配记录，并提取所需要的信息。\n在测试数据集中，假定每行所代表的视频都是唯一的，所以仅仅需要用户 ID 这一条信息。在提取到用户 ID 之后，可以像 WordCount 一样，组成 \u0026lt;ID, 1\u0026gt; 这样的用来计数的键值对，这步之后的逻辑便与 WordCount 相似了。\nJava 实现 1import org.apache.spark.SparkConf; 2import org.apache.spark.api.java.JavaPairRDD; 3import org.apache.spark.api.java.JavaRDD; 4import org.apache.spark.api.java.JavaSparkContext; 5import scala.Tuple2; 6 7import java.util.ArrayList; 8import java.util.List; 9import java.util.regex.Matcher; 10import java.util.regex.Pattern; 11 12public class SparkDemo { 13 private static final Pattern EXTRACT = Pattern.compile(\u0026#34;(\\\\S+)\\\\s+(\\\\S+)\\\\s+(\\\\d+)\\\\s+(\\\\D+[a-zA-Z])\\\\s+(\\\\d+)\\\\s+(\\\\d+)\\\\s+(\\\\d+\\\\.?\\\\d*)\\\\s+(\\\\d+)\\\\s+(\\\\d+)\\\\s+(.*)\u0026#34;); 14 15 public static void main(String[] args) { 16 SparkConf conf = new SparkConf().setAppName(\u0026#34;CountUploader\u0026#34;); 17 JavaSparkContext sc = new JavaSparkContext(conf); 18 19 JavaRDD\u0026lt;String\u0026gt; lines = sc.textFile(args[0]); 20 JavaRDD\u0026lt;String\u0026gt; filtered = lines.filter(s -\u0026gt; EXTRACT.matcher(s).matches()); 21 JavaPairRDD\u0026lt;String, String\u0026gt; records = filtered.mapToPair(s -\u0026gt; { 22 Matcher m = EXTRACT.matcher(s); 23 boolean result = m.matches(); 24 return new Tuple2\u0026lt;\u0026gt;(m.group(2), m.group(1)); 25 }); 26 JavaPairRDD\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; groups = records.groupByKey().mapToPair(t -\u0026gt; { 27 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); 28 t._2().forEach(list::add); 29 return new Tuple2\u0026lt;\u0026gt;(t._1(), list); 30 }); 31 // 手动实现 sortBy 操作 32 JavaRDD\u0026lt;Tuple2\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt;\u0026gt; tops = groups.keyBy(t -\u0026gt; t._2().size()).sortByKey(false).values(); 33 List\u0026lt;Tuple2\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt;\u0026gt; topList = tops.take(100); 34 35 for (Tuple2\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; t : topList) { 36 System.out.println(\u0026#34;User: \u0026#34; + t._1() + \u0026#34;, Number of videos: \u0026#34; + t._2().size()); 37 } 38 sc.stop(); 39 } 40} 执行 将上述代码生成 Jar 包之后，将其放到服务器中，执行下面的命令即可开始运行。\n1./bin/spark-submit --class SparkDemo ~/Documents/SparkDemo.jar ~/Documents/YoutubeDataSets.txt 执行结果如下所示\nUser: machinima, Number of videos: 21 User: hotforwords, Number of videos: 19 User: theevang1, Number of videos: 19 User: kushtv, Number of videos: 19 User: supermac18, Number of videos: 18 User: NBA, Number of videos: 18 User: somedia, Number of videos: 17 User: tokiohotelchannel, Number of videos: 17 User: AtheneWins, Number of videos: 16 User: davidisbetterthenyou, Number of videos: 16 // 此处省略数行  参考文章  RDD Operations Spark 函数详解系列之 RDD 基本转换 Spark 教程之 RDD 操作-转换和执行（示例） Spark 笔记-玩转 RDD 操作 RDD Aggregate in spark 利用开发工具 IntelliJ IDEA 编写 Spark 应用程序（Scala+Maven）  ","date":"2020-10-23T20:00:00+08:00","permalink":"https://sudrizzz.github.io/posts/spark-distributed-programming/","title":"Spark 分布式内存计算框架"},{"content":"词频统计程序示例 假设将一个英文文本大文件作为输入，统计文件中单词出现的频数。最基本的操作是把输入文件的每一行传递给 map 函数完成对单词的拆分并输出中间结果，中间结果为 \u0026lt;word, 1\u0026gt; 的形式， 表示程序对一个单词，都对应一个计数 1。使用 reduce 函数收集 map 函数的结果作为输入值，并生成最终 \u0026lt;word, count\u0026gt; 形式的结果，完成对每个单词的词频统计。它们对应 MapReduce 处理数据流程如上图所示。\nMapReduce 程序的运行过程 如图所示，MapReduce 运行阶段数据传递经过输入文件、Map 阶段、中间文件、 Reduce 阶段、输出文件五个阶段，用户程序只与 Map 阶段和 Reduce 阶段的 Worker 直接相关，其他事情由 Hadoop 平台根据设置自行完成。\n从用户程序 User Program 开始，用户程序 User Program 链接了 MapReduce 库，实现了最基本的 map 函数和 reduce 函数。\n MapReduce 库先把 User Program 的输入文件划分为 M 份，如上图左方所示，将数据分成了分片 0~4，每一份通常为 16MB~64MB；然后使用 fork 将用户进程复制到集群内其他机器上。 User Program 的副本中有一个 Master 副本和多个 Worker 副本。Master 是负责调度的，为空闲 Worker 分配 Map 作业或者 Reduce 作业。 被分配了 Map 作业的 Worker，开始读取对应分片的输入数据, Map 作业数量与输入文件划分数 M 相同，并与分片一一对应; Map 作业将输入数据转化为键值对表示形式并传递给 map 函数，map 函数产生的中间键值对被缓存在内存中。 缓存的中间键值对会被定期写入本地磁盘，而且被分为 R 个区（R 的大小是由用户定义的），每个区会对应一个 Reduce 作业；这些中间键值对的位置会被通报给 Master, Master 负责将信息转发给 Reduce Worker。 Master 通知分配了 Reduce 作业的 Worker 负责数据分区，Reduce Worker 读取键值对数据并依据键排序，使相同键的键值对聚集在一起。同一个分区可能存在多个键的键值对，而 reduce 函数的一次调用的键值是唯一的， 所以必须进行排序处理。 Reduce Worker 遍历排序后的中间键值对，对于每个唯一的键，都将键与关联的值传递给 reduce 函数，reduce 函数产生的输出会写回到数据分区的输出文件中。 当所有的 Map 和 Reduce 作业都完成了，Master 唤醒 User Program，MapReduce 函数调用返回 User Program。  执行完毕后，MapReduce 的输出放在 R 个分区的输出文件中，即每个 Reduce 作业分别对应一个输出文件。用户可将这 R 个文件作为输入交给另一个 MapReduce 程序处理，而不需要主动合并这 R 个文件。在 MapReduce 计算过程中，输入数据来自分布式文件系统，中间数据放在本地文件系统，最终输出数据写入分布式文件系统。\n必须指出 Map 或 Reduce 作业和 map 或 reduce 函数存在以下几个区别:\n Map 或 Reduce 作业是从计算框架的角度来认识的，而 map 或 reduce 函数是需要程序员编写代码完成的，并在运行过程中被对用 Map 或 Reduce 作业调度; Map 作业处理一个输入数据的分片，可能需要多次调用 map 函数来处理输入的键值对; Reduce 作业处理一个分区的中间键值对，期间要对每个不同的键调用一次 reduce 函数，一个 Reduce 作业最终对应一个输出文件。  经典 MapReduce 任务调度模型 经典 MapReduce 任务调度模型采用主从结构（Master/Slave），包含四个组成部分：Client、JobTracker、TaskTracker、Task。支撑 MapReduce 计算框架的是 JobTracker 和 TaskTracker 两类后台进程。框架结构如下图所示。\n Client 每一个 Job 在 Ciat 端将运行 MapRecdce 程序所需要的所有 Jar 文件和类的集合，打包成一个 Jar 文件存储在 HDFS 中，并把文件路径提交到 JobTracker。 JobTracker JobTracker 主要负责资源的监控和作业调度，一个 Hadoop 集群只有一个 JobTracker，并不参与具体的计算任务。根据提交的 Job，JobTackor 会创建一系列 Task（即 MapTask、ReduceTask），分发到每个 TaskTracker 服务中去执行。常用的作业调度算法主要包括 FIFO(First In First Out) 调度器（默认）、公平调度器、容量调度器等。 TaskTracker TaskTracker 主要负责汇报心跳和执行 JobTracker 分发的任务。TaskTracker 会周期性地通过 HeartBeat 将本节点上资源的使用情况和任务的运行进度汇报给 JobTracker，JobTracker 会根据心跳信息和当前作业运行情况为 TaskTracker 下达任务，主要包括启动任务、提交任务、杀死任务和重新初始化命令等。 Task Task 分为 MapTask 和 ReduceTask 两种，均由 TaskTracker 启动，执行 JobTracker 分发的任务。MapTask 解析每条数据记录，传递给用户编写的 map 函数并执行，最后将输出结果写入 HDFS；ReduceTask 从 MapTask 的执行结果中，对数据进行排序，将数据按分组传递给用户编写的 reduce 函数执行。  TaskTracker 分布在 Map-Reduce 集群每个节点上，主要是监视所在机器的资源情况和当前机器的 tasks 运行状况。TaskTracker 通过 HeartBeat 发送给 JobTracker，JobTracker 会根据这些信息给新提交的 job 分配计算节点。经典 MapReduce 框架 MR V1 模型简单直观，但是不能满足大规模集群任务调度的需要。主要表现为以下四点:\n JobTracker 是 MapReduce 的集中处理点，存在单点故障问题； 当 MapRcduce job 非常多的时候，会造成很大的内存开销，就增加了 JobTracker 失败的风险，业界普遍认为该调度模型支持的上限为 4000 个节点; 在 TaskTracker 端，以 Map/Reduce Task 的数目作为资源的表示过于简单，没有考虑到 CPU/内存的占用情况，如果两个大内存消耗的 Task 被调度到一起， 就很容易出现内存消耗殆尽的问题; TaskTracker 把资源强制划分为 Map Task Slot 和 Reduce Task Slot，如果当系统中只有 Map Task 或者只有 Reduce Task 时，会造成资源的浪费，导致集群资源利用不足。  YARN 框架原理及运行机制 为了从根本上解决经典 MapReduce 框架的性能瓶颈，Hadoop 的 MapReduce 框架完全重构，叫做 YARN 或者 MR V2。\nYARN 的基本思想就是将经典调度框架中 JobTracker 的资源管理和任务调度/监控功能分离成两个单独的组件，即一个全局的资源管理器 ResoureManager 和每个应用程序特有的 ApplicationMaster。ResoureManager 负责整个系统资源的管理和分配，而 ApplicationMaster 则负责单个应用程序的资源管理。\nYARN 调度框架包括 ResourceManager、ApplicationMaster、NodeMananger 及 Container 等组件概念。\nResourceManager 是基于应用程序对资源的需求进行调度的。每一个应用程序需要不同类型的资源，因此就需要不同的容器。这些资源包括内存、CPU、磁盘、网络等。 ApplicationMaster 负责向调度器申请、释放资源，清求 NodeManager 运行任务、跟踪应用程序的状态和监控它们的进程。\nNodeManager 是 YARN 中单个节点的代理，负责与应用程序的 ApplicationMaster 和集群管理者 ResourceManager 交互；从 ApplicationMaster 上接收有关 Container 的命令并执行（例如，启动、停止 Container）；向 ResourceManager 汇报各个 Container 执行状态和节点健康状况，并读取有关 Container 的命令；执行应用程序的容器、监控应用程序的资源使用情况并且向 ResourceManager 调度器汇报。\nContainer 是 YARN 中资源的抽象，它封装了节点上一定量的资源（CPU 和内存等）。一个应用程序所需的 Container 分为两类：一类是运行 ApplicationMaster 的 Container，是由 ResourceManager（向内部的资源调度器）申请和启动的，用户提交应用程序时，可指定唯一的 ApplicationMaster 所需的资源；另一类是运行各类任务的 Container，是由 ApplicationMaster 向 ResourceManager 申请的，并由 ApplicationMaster 与 NodeManager 通信后启动。\n用户向 YARN 提交一个应用程序后，YARN 将分为两个阶段运行该应用程序：第一个阶段是启动 ApplicationMaster；第二个阶段是由 ApplicationMaster 创建应用程序，为它申请资源，并监控它的整个运行过程，直到运行成功。\nYARN 任务调度流程如下图所示。\n 用户向 YARN 提交应用程序； ResourceManager 为该应用程序在某个 NodeManagr 分配一个 Container，并要求 NodeManager 启动应用程序的 ApplicationMaster； ApplicationMaster 启动后立即向 ResourceManager 注册，此时用户可以直接通过 ResourceManager 查看应用程序的运行状态，然后它将为各个任务申请分布在某些 NodeManager 上的容器资源，并监控它的运行状态（步骤 4~7），直到运行结束； ApplicationMaster 采用轮询的方式向 ResourceManager 申请和领取资源； ApplicationMaster 申请到资源后，即与资源容器所在的 NodeManager 通信，要求其在容器内启动任务; NodeManager 为任务初始化运行环境（包括环境变量、jar 包、二进制程序等)，启动任务； 运行各个任务的容器通过向 ApplicationMaster 汇报自己的状态和进度，使 ApplicationMaster 随时掌握各个任务的运行状态，从而可以在任务失败时重新启动任务。用户可以向 ApplicationMaster 查询应用程序的当前运行状态； 应用程序运行完成后，ApplicationMaster 向 ResourceManager 注销并关闭。  YARN 框架和经典的 MRV1 调度框架相比，主要有以下优化：\n ApplicationMaster 使得检测每一个 Job 子任务状态的程序分布式化，减少了 JobTracker 资源消耗； 在 YARN 中，用户可以对不同的编程模型写自己的 ApplicationMaster, 可以让更多类型的编程模型运行在 Hadoop 集群上，如 Spark 基于内存的计算模型； Container 提供 Java 虚拟机内存的隔离，优化了经典调度框架中 Map Slot 和 Reduce Slot 分开造成集群资源闲置的不足。  Youtube 数据集统计分析 本例的数据来自于 Youtube 的数据集，完整的数据集以及源代码下载地址请点击以下链接 https://github.com/sudrizzz/BigDataTechnologyFoundation-SourceCodeAndDataSet/blob/main/ch04\n该数据集各字段的具体含义如表所示：\n   字段名 解释及数据类型     video ID 视频 ID：每个视频存在唯一的 11 位字符串   uploader 上传者用户名：字符串类型   age 视频上传日期与 2007 年 2 月 15 日（YouTube 创立日）的间隔天数：整数值   category 视频类别：字符串类型   length 视频长度：整数值   views 浏览量：整数值   rate 视频评分：浮点值   ratings 评分次数：整数值   comments 评论数：整数值   related IDs 相关视频 ID，每个相关视频的 ID 均为单独的一列：字符串类型    视频类型统计 场景：从已经上传的视频中，统计每一个视频类型下的视频数量。下表所示为数据集数据格式示例。category 列代表了视频类型，因而 map 函数只需逐行读取，返回视频类型为键和数字 1 为值的键值对，再传给 reduce 函数处理即可。map 函数的输入键依然为文本文件中行的偏移量，值为行内容。reduce 函数输出键值对为视频类型和该视频类型中的视频数量。\n   video ID uploader age category length views rate ratings comments Related IDs     PRGUU_ggO3k tom 704 Entertainment 262 11235 3.86 247 280 tpAL3iOurl4\u0026hellip;ifn1njiY4s   RX24KLBhwMI jsack 687 Blogs 512 24149 4.22 315 474 PkGUU_ggO3k\u0026hellip;tpAl3iOurl4    Mapper 类代码实现 1public static class Map extends Mapper\u0026lt;LongWritable, Text, Text, IntWritable\u0026gt; { 2 private static final IntWritable ONE = new IntWritable(1); 3 private final Text tx = new Text(); 4 5 public void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException { 6 String line = value.toString(); 7 String[] str = line.split(\u0026#34;\\t\u0026#34;); 8 if (str.length \u0026gt; 3) { 9 this.tx.set(str[3]); 10 } 11 context.write(this.tx, ONE); 12 } 13} 第 2 行构造 IntWritable 可持久化对象并赋值为 1；第 8~10 行过滤字段，将一条记录中的分类 category 作为 map 函数的 value 输出。\nReduce 类代码实现 1public static class Reduce extends Reducer\u0026lt;Text, IntWritable, Text, IntWritable\u0026gt; { 2 public void reduce(Text key, Iterable\u0026lt;IntWritable\u0026gt; values, Context context) throws IOException, InterruptedException { 3 int sum = 0; 4 for (IntWritable v : values) { 5 sum += v.get(); 6 } 7 context.write(key, new IntWritable(sum)); 8 } 9} reduce 函数接收 Map 阶段传来的键值对，第 3~6 行遍历每一组记录，累加同一视频类型下的视频数量，第 7 行通过 context 输出计算结果。\n运行  通过 IDEA-Build-Build Artifacts 功能将代码打包为 jar 文件，命名为 CategoryCount.jar 登录 Hadoop 集群，将数据集文件 YoutubeDataSets.txt 传到 HDFS 下 /tmp 目录下 执行如下命令，开始运行程序  1hadoop jar CategoryCount.jar CategoryCount /tmp/YoutubeDataSets.txt /tmp/output 执行如下命令，查看各类别视频数量  1hadoop fs -cat /tmp/output/part-r-00000 可以得到如下输出\nUNA\t32 Autos \u0026amp; Vehicles\t77 Comedy\t420 Education\t65 Entertainment\t911 Film \u0026amp; Animation\t261 Howto \u0026amp; Style\t138 Music\t870 News \u0026amp; Politics\t343 Nonprofits \u0026amp; Activism\t43 People \u0026amp; Blogs\t399 Pets \u0026amp; Animals\t95 Science \u0026amp; Technology\t80 Sports\t253 Travel \u0026amp; Events\t113  ","date":"2020-10-17T20:00:00+08:00","permalink":"https://sudrizzz.github.io/posts/mapreduce-distributed-programming/","title":"MapReduce 分布式编程"},{"content":" 本文所有代码均可在 https://github.com/sudrizzz/HDFSOperations 查看。\n 通过命令行访问 HDFS 命令行是最简单、最直接操作文件的方式。这里介绍通过诸如读取文件、新建目录、移动文件、删除数据、列出目录等命令来进一步认识 HDFS。也可以输入 hadoop fs -help 命令获取每个命令的详细帮助。若熟悉 Linux 命令，Hadoop 命令看起来非常直观且易于使用。\n对文件和目录的操作 通过命令行对 HDFS 文件和目录的操作主要包括：创建、浏览、删除文件和目录，以及从本地文件系统与 HDFS 文件系统互相拷贝等。常用命令格式如下。\n1hadoop fs -ls \u0026lt;path\u0026gt; # 列出 path 目录下的所有内容（文件和目录） 2hadoop fs -lsr \u0026lt;path\u0026gt; # 递归列出 path 下的所有内容（文件或目录） 3hadoop fs -df \u0026lt;path\u0026gt; # 查看目录的使用情况 4hadoop fs -du \u0026lt;path\u0026gt; # 显示目录中所有文件及目录大小 5hadoop fs -touchz \u0026lt;path\u0026gt; # 创建一个路径为为 path 的 0 字节的 HDFS 空文件 6hadoop fs -mkdir \u0026lt;path\u0026gt; # 查看目录的使用情况 7hadoop fs -rm [-skipTrash] \u0026lt;path\u0026gt; # 将 HDFS 上路径为 \u0026lt;path\u0026gt; 的文件移动到回收站，加上 -skipTrash，则直接删除 8hadoop fs -rmr [-skipTrash] \u0026lt;path\u0026gt; # 将 HDFS 上路径为 \u0026lt;path\u0026gt; 的目录以及目录下的文件移动到回收站。如果加上 -skipTrash，则直接删除 9hadoop fs -moveFromLocal \u0026lt;localsrc\u0026gt;...\u0026lt;dst\u0026gt; # 将 \u0026lt;localsrc\u0026gt; 本地文件移动到 HDFS 的 \u0026lt;dst\u0026gt; 目录下路径下 10hadoop fs -moveToLocal [-crc] \u0026lt;src\u0026gt; \u0026lt;localdst\u0026gt; # 将 HDFS 上路径为 \u0026lt;src\u0026gt; 的文件移动到本地 \u0026lt;localdst\u0026gt; 路径下 11hadoop fs -put \u0026lt;localsrc\u0026gt;...\u0026lt;dst\u0026gt; # 从本地文件系统中复制单个或者多个源路径到目标文件系统 12hadoop fs -cat \u0026lt;src\u0026gt; # 浏览 HDFS 路径为 \u0026lt;src\u0026gt; 的文件的内容 修改权限或用户组 HDFS 提供了一些命令可以用来修改文件的权限、所属用户以及所属组别，具体格式如下:\n  hadoop fs -chmod [-R] \u0026lt;MODE [,MODE]...|OCTALMODE\u0026gt; PATH...\n改变 HDFS 上路径为 PATH 的文件的权限，R 选项表示递归执行该操作。\n例如: hadoop fs -chmod -R +r /user/test，表示将 /user/test 目录下的所有文件赋予读的权限\n  hadoop fs -chown [-R][OWNER][:[GROUP]]PATH...\n改变 HDFS 上路径为 PATH 的文件的所属用户，-R 选项表示递归执行该操作。\n例如: hadoop fs -chown -R hadoop:hadoop /user/test，表示将 /user/test 目录下所有文件的所属用户和所属组别改为 hadoop\n  hadoop fs -chgrp ［-R] GROUP PATH...\n改变 HDFS 上路径为 PATH 的文件的所属组别，-R 选项表示递归执行该操作。\n例如: hadoop fs -chown -R hadoop /user/test 表示将 /user/test 目录下所有文件的所属组别改为 hadoop\n  其他命令 HDFS 除了提供上述两类操作之外，还提供许多实用性较强的操作，如显示指定路径上的内容，上传本地文件到 HDFS 指定文件夹，以及从 HDFS 上下载文件到本地等命令。\n  hadoop fs -tail [-f] \u0026lt;file\u0026gt;\n显示 HDFS 上路径为 \u0026lt;file\u0026gt; 的文件的最后 1KB 的字节，-f 选项会使显示的内容随着文件内容更新而更新。\n例如: hadoop fs -tail -f /user/test.txt\n  hadoop fs -stat [format] \u0026lt;path\u0026gt;\n显示 HDFS 上路径为 \u0026lt;path\u0026gt; 的文件或目录的统计信息。格式为：%b 文件大小，%n 文件名，%r 复制因子，%y、%Y 修改日期。\n例如：hadoop fs -stat %b %n %o %r /user/test\n  hadoop fs -put \u0026lt;localsrc\u0026gt;...\u0026lt;dt\u0026gt;\n将 \u0026lt;localsrc\u0026gt; 本地文件上传到 HDFS 的 \u0026lt;dst\u0026gt; 目录下。\n例如: hadoop fs -put /home/hadoop/test.txt /user/hadoop\n  hadoop fs -count [-q] \u0026lt;path\u0026gt;\n显示 \u0026lt;path\u0026gt; 下的目录数及文件数，输出格式为”目录数 文件数 大小 文件名“，加上 -q 可以查看文件索引的情况。\n例如: hadoop fs -count /\n  hadoop fs -get [-ignoreCrc] [-crc] \u0026lt;src\u0026gt; \u0026lt;localdst\u0026gt;\n将 HDFS 上 \u0026lt;src\u0026gt; 的文件下载到本地的 \u0026lt;localdst\u0026gt; 目录，可用 -ignorecrc 选项复制 CRC 校验失败的文件，使用 -crc 选项复制文件以及 CRC 信息。\n例如: hadoop fs -get /user/hadoop/a.txt /home/hadoop\n  hadoop fs -getmerge \u0026lt;src\u0026gt; \u0026lt;localdst\u0026gt; [addnl]\n将 HDFS 上 \u0026lt;src\u0026gt; 目录下的所有文件按文件名排序并合并成一个文件输出到本地的 \u0026lt;localdst\u0026gt; 目录，addnl 是可选的，用于指定在每个文件结尾添加一个换行符。\n例如: hadoop fs -getmerge /user/test /home/hadoop/o\n  hadoop fs -test -[ezd] \u0026lt;path\u0026gt;\n检查 HDFS 上路径为 \u0026lt;path\u0026gt; 的文件。-e 检查文件是否存在，如果存在则返回 0。-z 检查文件是否为 0 字节，如果是则返回 0。-d 检查路径是否是目录，如果是则返回 1，否则返回 0。\n例如：hadoop fs -test -e /user/test.txt\n  通过 Java API 访问 HDFS 使用 Hadoop URL 读取数据 要从 Hadoop 文件系统读取数据，最简单的方法是使用 java.net.URL 对象打开数据流，从中读取数据。\n让 Java 程序能够识别 Hadoop 的 HDFS URL 方案还需要一些额外的工作，这里采用的方法是通过 org.apache.hdfs.FsUrlStreamHandlerFactor 实例调用 java.net.URL 对象的 setURLStreamHandlerFactory 实例方法。每个 Java 虚拟机只能调用一次这个方法，因此通常在静态方法中调用。下述范例展示的程序以标准输出方式显示 Hadoop 文件系统中的文件，类似于 UNIX 中的 cat 命令。\n1import org.apache.hadoop.fs.FsUrlStreamHandlerFactory; 2import org.apache.hadoop.io.IOUtils; 3 4import java.io.InputStream; 5import java.net.URL; 6 7public class URLCat { 8 static { 9 URL.setURLStreamHandlerFactory(new FsUrlStreamHandlerFactory()); 10 } 11 12 public static void main(String[] args) throws Exception{ 13 InputStream inputStream = null; 14 try { 15 inputStream = new URL(args[0]).openStream(); 16 IOUtils.copyBytes(inputStream, System.out, 4096, false); 17 } finally { 18 IOUtils.closeStream(inputStream); 19 } 20 } 21} 编译代码，导出为 URLCat.jar 文件，并在 /user/hadoop/ 中准备一个测试文件 test，然后执行命令：\n1hadoop jar hdfsclient.jar URLCat hdfs://master:9000/user/hadoop/test 执行完成后可以在屏幕上看到 /user/hadoop/test 文件中的内容。该程序是从 HDFS 读取文件的最简单的方式，即用 java.net.URL 对象打开数据流。其中，第 8~10 行静态代码块的作用是设置 URL 类能够识别 Hadoop 的 HDFS URL。第 16 行 IOUtils 是 Hadoop 中定义的类，调用其静态方法 copyBytes 实现从 HDFS 文件系统拷贝文件到标准输出流。4096 表示用来拷贝的缓冲区大小，false 表示拷贝完成后不关闭拷贝源。\n通过 FileSystem API 读取数据 在实际开发中，访问 HDFS 最常用的类是 FileSystem 类。Hadoop 文件系统中通过 Hadoop Path 对象来定位文件。可以将路径视为一个 Hadoop 文件系统 URI，如 hdfs:localhost/user/hadoop/test。FileSystem 是一个通用的文件系统 API，获取 FileSystem 实例有下面几个静态方法:\n1public static FileSystem get(Configuration conf) throws IOException 2public static FileSystem get(URI uri,Configuration conf) throws IOException 3public static FileSystem get(URI uri, Configuration conf, String user) throw IOException 下面分别给出几个常用操作的代码示例。\n读取文件 1@Test 2public void readFile() throws Exception { 3 String uri = \u0026#34;hdfs://master:9000/user/hadoop/test\u0026#34;; 4 Configuration configuration = new Configuration(); 5 FileSystem fileSystem = FileSystem.get(URI.create(uri), configuration); 6 InputStream in = null; 7 try { 8 in = fileSystem.open(new Path(uri)); 9 IOUtils.copyBytes(in, System.out, 4096, false); 10 } finally { 11 IOUtils.closeStream(in); 12 } 13} 上述代码直接使用 FileSystem 以标准输出格式显示 Hadoop 文件系统中的文件。\n第 4 行产生一个 Confguation 类的实例，代表了 Hadoop 平台的配置信息，并在第 5 行作为引用传递到 FileSystem 的静态方法 get 中，产生 FileSystem 对象。\n第 9 行与上例类似，调用 Hadoop 中 IOUtils，并在 finally 字中关闭数据流，同时也可以在输入流和输出流之间复制数据。copyBytes 方的最后两个参数，第一个设置用于复制的缓冲区大小，第二个设置复制结束后是否关闭数据流。\n写入文件 1@Test 2public void writeFile() throws Exception { 3 String source = \u0026#34;C:\\\\Users\\\\Desktop\\\\test\u0026#34;; 4 String destination = \u0026#34;hdfs://master:9000/user/hadoop/test2\u0026#34;; 5 BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(source)); 6 Configuration configuration = new Configuration(); 7 FileSystem fileSystem = FileSystem.get(URI.create(destination), configuration); 8 OutputStream outputStream = fileSystem.create(new Path(destination)); 9 IOUtils.copyBytes(inputStream, outputStream, 4096, true); 10} 创建目录 1@Test 2public void createFolder() throws Exception { 3 String uri = \u0026#34;hdfs://master:9000/user/test\u0026#34;; 4 Configuration configuration = new Configuration(); 5 FileSystem fileSystem = FileSystem.get(URI.create(uri), configuration); 6 Path path = new Path(uri); 7 fileSystem.mkdirs(path); 8 fileSystem.close(); 9} 删除文件或目录 1@Test 2public void deleteFile() throws Exception { 3 String uri = \u0026#34;hdfs://master:9000/user/hadoop/test2\u0026#34;; 4 Configuration configuration = new Configuration(); 5 FileSystem fileSystem = FileSystem.get(URI.create(uri), configuration); 6 Path path = new Path(\u0026#34;hdfs://master:9000/user/hadoop\u0026#34;); 7 boolean isDeleted = fileSystem.delete(path, true); 8 System.out.println(isDeleted); 9 fileSystem.close(); 10} 使用 FileSystem 的 delete() 方法可以永久性删除文件或目录。如果要递归删除文件夹，则需要将其第二个参数设为 true。\n列出文件或目录 1@Test 2public void listFiles() throws Exception { 3 String uri = \u0026#34;hdfs://master:9000/user\u0026#34;; 4 Configuration configuration = new Configuration(); 5 FileSystem fileSystem = FileSystem.get(URI.create(uri), configuration); 6 Path path = new Path(uri); 7 FileStatus[] status = fileSystem.listStatus(path); 8 for (FileStatus fileStatus : status) { 9 System.out.println(fileStatus.getPath().toString()); 10 } 11 fileSystem.close(); 12} 文件系统的重要特性是提供浏览和检索其目录结构下所存文件与目录相关信息的功能。 FileStatus 类封装了文件系统中文件和目录的元数据，例如文件长度、块大小、副本、修改时间、所有者以及权限信息等。编译运行上述代码后控制台将会打印出 /user 目录下的名称或者文件名。\n小结 HDFS 组成部分  HDFS 是一个分布式文件存储系统 Client 提交读写请求（拆分 blocksize） NameNode 全局把控（存储数据位置） DataNode 存储数据（将数据存储进去，且以 Pipeline 的方式把数据写完）  HDFS 数据交互 写入数据  使用 HDFS 提供的客户端 Client，向远程的 NameNode 发起 RPC 请求 NameNode 会检查要创建的文件是否已经存在，创建者是否有权限进行操作，成功则会为文件创建一个记录，否则会让客户端抛出异常 当客户端开始写入文件的时候，客户端会将文件切分成多个 packets，并在内部以数据队列 data queue（数据队列） 的形式管理这些 packets，并向 NameNode 申请 blocks，获取用来存储 replicas 的合适的 DataNode 列表，列表的大小根据 NameNode 中 replication（副本份数）的设定而定 开始以 pipeline（管道）的形式将 packet 写入所有的 replicas 中。客户端把 packet 以流的方式写入第一个 DataNode，该 DataNode 把该 packet 存储之后，再将其传递给在此 pipeline 中的下一个 DataNode，直到最后一个 DataNode，这种写数据的方式呈流水线的形式 最后一个 DataNode 成功存储之后会返回一个 ack packet（确认队列），在 pipeline 里传递至客户端，在客户端的开发库内部维护着 \u0026ldquo;ack queue\u0026rdquo;，成功收到 DataNode 返回的 ack packet 后会从 \u0026ldquo;data queue\u0026rdquo; 移除相应的 packet 如果传输过程中，有某个 DataNode 出现了故障，那么当前的 pipeline 会被关闭，出现故障的 DataNode 会从当前的 pipeline 中移除，剩余的 block 会继续剩下的 DataNode 中继续以 pipeline 的形式传输，同时 NameNode 会分配一个新的 DataNode，保持 replicas 设定的数量。 客户端完成数据的写入后，会对数据流调用 close() 方法，关闭数据流 只要写入了 dfs.replication.min（最小写入成功的副本数）的复本数（默认为 1），写操作就会成功，并且这个块可以在集群中异步复制，直到达到其目标复本数（dfs.replication 的默认值为 3），因为 NameNode 已经知道文件由哪些块组成，所以它在返回成功前只需要等待数据块进行最小量的复制  读取数据  客户端调用 FileSystem 实例的 open 方法，获得这个文件对应的输入流 InputStream 通过 RPC 远程调用 NameNode，获得 NameNode 中此文件对应的数据块保存位置，包括这个文件的副本的保存位置（主要是各 DataNode 的地址） 获得输入流之后，客户端调用 read 方法读取数据。选择最近的 DataNode 建立连接并读取数据 如果客户端和其中一个 DataNode 位于同一机器（比如 MapReduce 过程中的 mapper 和 reducer)，那么就会直接从本地读取数据 到达数据块末端，关闭与这个 DataNode 的连接，然后重新查找下一个数据块 不断执行第 2~5 步直到数据全部读完 客户端调用 close，关闭输入流 DFS InputStream  HDFS 漫画  以上漫画版权均归原图作者所有\n 参考文章 https://www.cnblogs.com/qingyunzong/p/8548806.html\n","date":"2020-10-12T15:20:11+08:00","permalink":"https://sudrizzz.github.io/posts/hdfs-file-system/","title":"HDFS 文件管理"},{"content":"前言 本系列文章是基于《大数据技术基础》与 10 小时入门大数据 课程，如果有兴趣可以先阅读该书并观看视频教程。本系列文章中所用到的软件版本及其下载地址如下：\n   名称 版本 下载地址     CentOS 8.2.2004 https://mirrors.tuna.tsinghua.edu.cn/centos/8.2.2004/isos/x86_64/CentOS-8.2.2004-x86_64-minimal.iso   JDK 14.0.2 https://www.oracle.com/java/technologies/javase/jdk14-archive-downloads.html   Hadoop 2.10.1 https://www.apache.org/dyn/closer.cgi/hadoop/common/hadoop-2.10.1/hadoop-2.10.1-src.tar.gz    环境准备 配置网络 此篇文章所使用的 CentOS 环境均是使用 VMware 15 虚拟的，具体安装教程请查看 使用 VMware 15 安装虚拟机和使用 CentOS 8，此处不再赘述。安装好一个节点之后，我们可以采用“虚拟机克隆”的方式，直接完成另外两个节点系统的安装。\n虚拟机的网络配置采用 DHCP 自动分配模式，每台机器的 IP 地址可以通过命令 ip address 或 ifconfig 查看，其中 ifconfig 输出如下，第一组配置中 ens33 即为本机网络配置，inet 项对应的即为本机 ip（192.168.61.128）。\n1ens33: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500 2 inet 192.168.61.128 netmask 255.255.255.0 broadcast 192.168.61.255 3 inet6 fe80::20c:29ff:fe65:9052 prefixlen 64 scopeid 0x20\u0026lt;link\u0026gt; 4 ether 00:0c:29:65:90:52 txqueuelen 1000 (Ethernet) 5 RX packets 38037 bytes 6542757 (6.2 MiB) 6 RX errors 0 dropped 0 overruns 0 frame 0 7 TX packets 30479 bytes 16809162 (16.0 MiB) 8 TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 9 10lo: flags=73\u0026lt;UP,LOOPBACK,RUNNING\u0026gt; mtu 65536 11 inet 127.0.0.1 netmask 255.0.0.0 12 inet6 ::1 prefixlen 128 scopeid 0x10\u0026lt;host\u0026gt; 13 loop txqueuelen 1000 (Local Loopback) 14 RX packets 23656 bytes 13542580 (12.9 MiB) 15 RX errors 0 dropped 0 overruns 0 frame 0 16 TX packets 23656 bytes 13542580 (12.9 MiB) 17 TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 18 19virbr0: flags=4099\u0026lt;UP,BROADCAST,MULTICAST\u0026gt; mtu 1500 20 ether 52:54:00:d2:b3:31 txqueuelen 1000 (Ethernet) 21 RX packets 0 bytes 0 (0.0 B) 22 RX errors 0 dropped 0 overruns 0 frame 0 23 TX packets 0 bytes 0 (0.0 B) 24 TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 本篇文章中三台集群的 IP 分别如下，下文中不再赘述。\n   主机名 IP     master 192.168.61.128   slave1 192.168.61.129   slave2 192.168.61.131    配置 host 以上三台机器要搭建成为集群，就需要让它们互相认识。这个认识的过程是通过 /etc/hosts 文件来实现的。这一步需要修改每一台机器的 hosts 文件，将以下内容分别粘贴到各个机器的 hosts 文件中。\n1vim /etc/hosts 192.168.61.128 master 192.168.61.129 slave1 192.168.61.131 slave2 配置 JDK 因为 Hadoop 的环境依赖于 Java JDK，所以需要确保虚拟机中已经正确安装了 JDK，除此之外我们还需要将 JDK 地址配置到环境变量中。在本例中，我的 JDK 安装位置是 /usr/java/jdk-14.0.2。\n修改 bash_profile 1vim ~/.bash_profile 添加以下内容到 .bash_profile 文件末尾：\nexport JAVA_HOME=/usr/java/jdk-14.0.2 export PATH=$JAVA_HOME/bin:$PATH 修改完成并保存后，还需要执行 source 命令使环境变量立即生效。\n1source ~/.bash_profile 然后即可使用 java -version 检查环境变量是否配置成功，执行结果如下所示。\njava version \u0026quot;14.0.2\u0026quot; 2020-07-14 Java(TM) SE Runtime Environment (build 14.0.2+12-46) Java HotSpot(TM) 64-Bit Server VM (build 14.0.2+12-46, mixed mode, sharing) 配置 SSH 免密钥登录 在 Linux 集群间配置免密钥登录，是 Hadoop 集群运维的基础。以下操作在 master 节点进行，实现从 master 免密钥登录 slave1、slave2 节点。生成 ssh 密钥的命令如下：\n1ssh-keygen 生成过程中会有一些提示，一路回车即可。执行结果如下所示。\nroot@master:/usr/local/software# ssh-keygen Generating public/private rsa key pair. Enter file in which to save the key (/root/.ssh/id_rsa): /root/.ssh/id_rsa already exists. Overwrite (y/n)? y Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /root/.ssh/id_rsa. Your public key has been saved in /root/.ssh/id_rsa.pub. The key fingerprint is: SHA256:DC7+sETaazn0f4OVgxozjdw2XM1Tb60cqoaQvDGXpg8 root@master The key's randomart image is: +---[RSA 3072]----+ | | | . | | . o . ..| | . o . + . +| | oo.*S+ . + + | | =..% @ + . o | | ..=oE# = o | | .+==.o = | | .o..ooo . | +----[SHA256]-----+ 接下来需要将生成的公钥上传到 slave1 节点，命令如下：\n1ssh-copy-id root@slave1 首次通过 master 终端将公钥传给 salve 终端，需要输入 slave 节点的登录密码。上述命令中我们是传输到 slave1 的 root 账户下，所以需要输入 root 用户的密码，传送完毕即可实现免密码登录。执行结果如下。\nroot@master:/usr/local/software# ssh-copy-id root@slave1 /usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: \u0026quot;/root/.ssh/id_rsa.pub\u0026quot; /usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed /usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys root@slave1's password: Number of key(s) added: 1 Now try logging into the machine, with: \u0026quot;ssh 'root@slave1'\u0026quot; and check to make sure that only the key(s) you wanted were added. slave2 节点命令同上，只需更改传送到的节点名称，执行结果如下。\nroot@master:/usr/local/software# ssh-copy-id root@slave2 /usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: \u0026quot;/root/.ssh/id_rsa.pub\u0026quot; /usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed /usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys root@slave2's password: Number of key(s) added: 1 Now try logging into the machine, with: \u0026quot;ssh 'root@slave2'\u0026quot; and check to make sure that only the key(s) you wanted were added. 现在可以尝试登录子节点 slave1 和 slave2。\n1ssh root@slave1 成功登录 salve1 节点的提示如下。\nroot@master:/usr/local/software# ssh root@slave1 Web console: https://slave1:9090/ or https://192.168.61.129:9090/ Last login: Fri Sep 24 14:56:46 2020 from 192.168.61.1 完善配置 以下配置均在 master 节点上完成，配置完成后可直接复制到 slave 节点，以免重复劳动。\n安装 Hadoop 1cd /usr/local/software 2wget http://mirror.cogentco.com/pub/apache/hadoop/common/hadoop-2.10.1/hadoop-2.10.1-src.tar.gz 3tar -zxvf hadoop-2.10.1-src.tar.gz 4cd hadoop-2.10.1-src 5mv * ~/hadoop 在正式使用 Hadoop 集群之前，我们还需要对其配置文件进行修改。本节中的配置内容请以 官方文档 为准。\nHadoop 的配置文件均存放在 Hadoop 所在目录的 /etc/hadoop/ 文件夹下。\n修改配置文件 编辑 core-site.xml 文件 core-site.xml 用来配置 Hadoop 集群的通用属性，包括指定 NameNode 的地址、指定使用 Hadoop 时临时文件的存放路径、指定检查点备份日志的最长时间等。\n使用 vim 打开文件：\n1vim ~/hadoop-2.10.1/etc/hadoop/core-site.xml 使用以下内容替换 core-site.xml 中的内容：\n1\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; 2\u0026lt;?xml-stylesheet type=\u0026#34;text/xsl\u0026#34; href=\u0026#34;configuration.xsl\u0026#34;?\u0026gt; 3 4\u0026lt;configuration\u0026gt; 5 \u0026lt;!-- 指定 namenode 的地址 --\u0026gt; 6 \u0026lt;property\u0026gt; 7 \u0026lt;name\u0026gt;fs.defaultFS\u0026lt;/name\u0026gt; 8 \u0026lt;value\u0026gt;hdfs://master:9000\u0026lt;/value\u0026gt; 9 \u0026lt;/property\u0026gt; 10 11 \u0026lt;!-- 指定使用 Hadoop 时临时文件的存放路径 --\u0026gt; 12 \u0026lt;property\u0026gt; 13 \u0026lt;name\u0026gt;hadoop.tmp.dir\u0026lt;/name\u0026gt; 14 \u0026lt;value\u0026gt;/home/hadoop/temp\u0026lt;/value\u0026gt; 15 \u0026lt;/property\u0026gt; 16\u0026lt;/configuration\u0026gt; 第 6~9 行配置 fs.defaultFS 的属性为 hdfs://master:9000，master 是主机名；第 12~15 行指定 Hadoop 的临时文件夹为 /home/hadoop/temp，此文件夹用户可以自己指定。\n编辑 hdfs-site.xml 文件 hdfs-site.xml 用来配置分布式文件系统 HDFS 的属性，包括指定 HDFS 保存数据的副本数量，指定 HDFS 中 NameNode、DataNode 的存储位置等。\n使用 vim 打开文件：\n1vim ~/hadoop-2.10.1/etc/hadoop/hdfs-site.xml 使用以下内容替换 hdfs-site.xml 中的内容：\n1\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; 2\u0026lt;?xml-stylesheet type=\u0026#34;text/xsl\u0026#34; href=\u0026#34;configuration.xsl\u0026#34;?\u0026gt; 3 4\u0026lt;configuration\u0026gt; 5 \u0026lt;!-- 指定 HDFS 保存数据的副本数量 --\u0026gt; 6 \u0026lt;property\u0026gt; 7 \u0026lt;name\u0026gt;dfs.replication\u0026lt;/name\u0026gt; 8 \u0026lt;value\u0026gt;1\u0026lt;/value\u0026gt; 9 \u0026lt;/property\u0026gt; 10\u0026lt;/configuration\u0026gt; 其中，第 7~8 行，指定 HDFS 文件快的副本数为 1。数据块副本一般为 3 以上，本文章仅作示例，故指定为 1。\n编辑 yarn-site.xml YARN 是 MapReduce 的调度框架。文件 yarn-site.xml 用配置 YARN 的属性，包括指定 NameNodeManager 获取数据的方式，指定 ResourceManager 的地址，配置 YARN 打印工作日志等。\n使用 vim 打开文件：\n1vim ~/hadoop-2.10.1/etc/hadoop/yarn-site.xml 使用以下内容替换 yarn-site.xml 中的内容：\n1\u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; 2 3\u0026lt;configuration\u0026gt; 4 \u0026lt;!-- 指定 NameNodeManager 获取数据的方式是 shuffle --\u0026gt; 5 \u0026lt;property\u0026gt; 6 \u0026lt;name\u0026gt;yarn.nodemanager.aux-services\u0026lt;/name\u0026gt; 7 \u0026lt;value\u0026gt;mapreduce_shuffle\u0026lt;/value\u0026gt; 8 \u0026lt;/property\u0026gt; 9 \u0026lt;property\u0026gt; 10 \u0026lt;name\u0026gt;yarn.nodemanager.env-whitelist\u0026lt;/name\u0026gt; 11 \u0026lt;value\u0026gt;JAVA_HOME,HADOOP_COMMON_HOME,HADOOP_HDFS_HOME,HADOOP_CONF_DIR,CLASSPATH_PREPEND_DISTCACHE,HADOOP_YARN_HOME,HADOOP_MAPRED_HOME\u0026lt;/value\u0026gt; 12 \u0026lt;/property\u0026gt; 13 14 \u0026lt;!-- 指定 YARN 中 ResourceManager 所在的主机名 --\u0026gt; 15 \u0026lt;property\u0026gt; 16 \u0026lt;name\u0026gt;yarn.resourcemanager.hostname\u0026lt;/name\u0026gt; 17 \u0026lt;value\u0026gt;master\u0026lt;/value\u0026gt; 18 \u0026lt;/property\u0026gt; 19\u0026lt;/configuration\u0026gt; 其中，第 15~19 行配置了 ResourceManager 所在的主机名，如果不进行配置，将会导致 MapReduce 不能获得资源，任务不能执行。\n编辑 mapred-site.xml 文件 mapred-site.xml 主要是配置 MapReduce 的属性，主要是 Hadoop 系统提交的 Map/Reduce 程序运行在 YARN 上。\n首先复制一份 mapred-site.xml.template 文件为 mapred-site.xml，然后打开并进行修改。\n1vim ~/hadoop-2.10.1/etc/hadoop/mapred-site.xml 使用以下内容替换 mapred-site.xml 中的内容：\n1\u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; 2\u0026lt;?xml-stylesheet type=\u0026#34;text/xsl\u0026#34; href=\u0026#34;configuration.xsl\u0026#34;?\u0026gt; 3 4\u0026lt;configuration\u0026gt; 5 \u0026lt;property\u0026gt; 6 \u0026lt;name\u0026gt;mapreduce.framework.name\u0026lt;/name\u0026gt; 7 \u0026lt;value\u0026gt;yarn\u0026lt;/value\u0026gt; 8 \u0026lt;/property\u0026gt; 9 \u0026lt;property\u0026gt; 10 \u0026lt;name\u0026gt;mapreduce.application.classpath\u0026lt;/name\u0026gt; 11 \u0026lt;value\u0026gt;$HADOOP_MAPRED_HOME/share/hadoop/mapreduce/*:$HADOOP_MAPRED_HOME/share/hadoop/mapreduce/lib/*\u0026lt;/value\u0026gt; 12 \u0026lt;/property\u0026gt; 13\u0026lt;/configuration\u0026gt; 其中，第 5~8 行为 MapReduce 指定任务调度框架为 YARN。\n编辑 slaves slaves 文件为 Hadoop 提供了子节点的主机名。\n1vim ~/hadoop-2.10.1/etc/hadoop/slaves 使用以下内容替换 slaves 中的内容：\nslave1 slave2 复制文件到子节点 使用下面的命令将 Hadoop 文件复制到其他节点，本文中为 slave1 和 slave2，命令如下：\n1cd ~/hadoop 2scp -r hadoop-2.10.1 root@slave1:~/hadoop/ 3scp -r hadoop-2.10.1 root@slave2:~/hadoop/ 配置 Hadoop 环境变量 注意，此操作需要同时在所有节点（master，slave1，slave2）都执行一次，操作命令如下：\n1vim ~/.bash_profile 将以下内容追加到 .bash_profile 文件末尾：\n#HADOOP export HADOOP_HOME=/root/hadoop/hadoop-2.10.1 export PATH=$HADOOP_HOME/bin:$HADOOP_HOME/sbin:$PATH 然后执行下列命令使环境变量生效：\n1source ~/.bash_profile 创建临时文件存放目录 我们在 core-site.xml 文件中指定了 Hadoop 临时文件存放路径，但是文件夹并没有创建，此操作需要同时在所有节点（master，slave1，slave2）都执行一次，操作命令如下：\n1mkdir /home/hadoop/temp 启动集群 格式化文件系统 注意，格式化仅需要在第一次使用 Hadoop 集群时进行，后续使用时无需格式化，并且在使用过程中进行格式化，所有文件将会丢失。此操作需要在 master 节点上进行，执行如下命令：\n1hdfs namenode -format 启动 Hadoop 集群 Hadoop 启动或停止服务的脚本均存放在 sbin 目录中，所以切换到 /home/hadoop/hadoop-2.10.1/sbin 目录下，执行以下命令：\n1start-all.sh 需要注意的是，在启动过程中，Hadoop 会提示这样的启动方式已经过时，使用如下启动方式即可规避过时提示：\n1start-dfs.sh 2start-yarn.sh 查看进程是否启动成功 在 master 节点终端执行 jps 命令，在打印结果中会看到四个进程，分别是 NodeManager、SecondaryNameNode、ResourceManager、Jps。如果出现了这四个进程表示启动成功。结果如下：\nroot@master:~/hadoop/hadoop-2.10.1/sbin# jps 17874 NameNode 18070 SecondaryNameNode 18281 ResourceManager 18554 Jps 此时在 slave1 和 slave2 的节点的终端执行 jps 命令，在输出结果中会看到三个进程，分别是 Jps、NodeManager、DataNode，如果出现了这三个进程表示子节点进程启动成功。结果如下：\nroot@slave1:~# jps 15776 NodeManager 15639 DataNode 16106 Jps 查看 WebUI Hadoop 页面 如果要在宿主机上访问虚拟机 master 节点的 WebUI，需要先将虚拟机的防火墙关闭（此处仅仅是做示例，生产环境不建议这么做），然后访问虚拟机 master 节点 IP:50070 即可。\n防火墙相关命令如下：\n1# 暂时关闭防火墙 2systemctl stop firewalld 3 4# 永久关闭防火墙 5systemctl disable firewalld 6 7# 启用防火墙 8systemctl enable firewalld 例如本例中 master 节点地址为 192.168.61.128，则访问 192.168.61.128:50070，页面如下图：\nYARN 页面 如上例，与 Hadoop 管理页面不同的是，YARN Web 页面地址端口是 8088，页面如下图：\n运行实例 在 Hadoop 自带的 examples 中有一种利用分布式系统计算圆周率的方法，采用的是拟蒙特卡罗（Quasi-Monte Carlo）算法来对 $ \\pi $ 的值进行估算。下面通过运行该程序来检验 Hadoop 集群是否安装配置成功。\n在 master 节点终端中执行下面的命令：\n1hadoop jar hadoop-2.10.1/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.10.1.jar pi 100 100000 Hadoop 的命令类似 Java 命令，通过 jar 指定要运行的程序所在的 jar 包 hadoop-mapreduce-examples-2.10.1.jar。参数 pi 表示需要计算的圆周率 $ \\pi $。后面两个参数中，100 是指要运行 100 次 map，100000 表示每个 map 的任务次数，即每个节点要模拟飞镖 100000 次。执行过程及结果如下图：\nJob Finished in 131.634 seconds Estimated value of Pi is 3.14158440000000000000 至此，Hadoop 环境配置完成。\n备注 如果在执行 mapreduce 任务中报错如 此问题 的描述，参考 此篇文章，需要在 mapred-site.xml 文件中添加下列配置：\n1\u0026lt;property\u0026gt; 2 \u0026lt;name\u0026gt;mapreduce.map.memory.mb\u0026lt;/name\u0026gt; 3 \u0026lt;value\u0026gt;4096\u0026lt;/value\u0026gt; 4\u0026lt;/property\u0026gt; 5\u0026lt;property\u0026gt; 6 \u0026lt;name\u0026gt;mapreduce.reduce.memory.mb\u0026lt;/name\u0026gt; 7 \u0026lt;value\u0026gt;8192\u0026lt;/value\u0026gt; 8\u0026lt;/property\u0026gt; 9\u0026lt;property\u0026gt; 10 \u0026lt;name\u0026gt;mapreduce.map.java.opts\u0026lt;/name\u0026gt; 11 \u0026lt;value\u0026gt;-Xmx3072m\u0026lt;/value\u0026gt; 12\u0026lt;/property\u0026gt; 13\u0026lt;property\u0026gt; 14 \u0026lt;name\u0026gt;mapreduce.reduce.java.opts\u0026lt;/name\u0026gt; 15 \u0026lt;value\u0026gt;-Xmx6144m\u0026lt;/value\u0026gt; 16\u0026lt;/property\u0026gt; ","date":"2020-09-24T09:20:11+08:00","permalink":"https://sudrizzz.github.io/posts/getting-to-know-hadoop/","title":"初识 Hadoop"},{"content":"前言 本课的第三、四章分别是程序的机器级表示和处理器体系结构，由于过于硬核，此处略过。第五章是优化程序性能，讲解了如何最大限度地提高程序执行效能，此处也略过。本文基于第六章存储器层级结构。\n存储技术 在本节中主要介绍 SRAM 存储器、DRAM 存储器、ROM 存储器以及机械和固态硬盘。\n随机访问存储器 随机访问存储器（Random Access Memory, RAM）分为两类：静态的和动态的。静态随机访问存储器（Static Random Access Memory, SRAM）比动态随机访问存储器（Dynamic Random Access Memory, DRAM）更快，但也贵得多。目前 CPU 中的三级缓存都是 SRAM。\n易失性存储器 需要注意的是，虽然 SRAM 是静态随机访问存储器，但是其“静态”是相对于动态随机访问存储器的，仍然属于“易失性存储器”，而非真正意义上的静态，同时 DRAM 也属于“易失性存储器”。通俗的说，就是断电之后保存的信息就会丢失。\nSRAM SRAM 将每个位存储在一个双稳态的存储器单元中，每个单元是用一个六晶体管来实现的，在通电的情况下，它可以无限期地保持在两个不同的电压配置或状态之一，其他任何状态都是不稳定的。当从不稳定状态开始，电路会迅速转换到两个稳定状态中的一个。这样的存储器单元类似于下图倒转的钟摆模型。\n由于上述的特性（SRAM 的双稳态特性），只要有电，它就会永远保持它的值。即使有干扰（例如电子噪音）来扰乱电压，当干扰消除后，电路就会恢复到稳定值。这样体现了上述表格中的持续性和不敏感性。\nDRAM DRAM 将每个位存储位对一个电容的充电，每个单元由一个电容和一个访问晶体管组成。但是与 SRAM 不同，DRAM 存储单元对抗干扰非常敏感。当电容的电压被扰乱之后，它就永远不会恢复了。\n小结 下表总结了 SRAM 和 DRAM 存储器的特性。只要有供电，SRAM 就会保持不变。与 DRAM 不同，它不需要刷新。SRAM 的存取比 DRAM 快。SRAM 对诸如光和电噪声这样的干扰不敏感。代价是 SRAM 单元比 DRAM 单元使用更多的晶体管，因而密集度低，而且更贵，功耗更大。\n    每位晶体管数 相对访问时间 持续的？ 敏感的？ 相对花费 应用     SRAM 6 1X 是 否 1000x 高速缓存存储器   DRAM 1 10X 否 是 1X 主存，帧缓冲区    非易失性存储器 显然，非易失性存储器指即使断电也不会丢失数据的存储器，非易失性存储器包括以下几种：\n 只读存储器（Read-Only Memory, ROM）：在生产期间被编程，虽然 ROM 中有的类型既可以读也可以写，但是他们整体上都被称为只读存储器 可编程存储器（Programmable ROM, PROM）：只能被编程一次 可擦写可编程存储器（Eraseable PROM, EPROM）：有一个透明的石英窗口，允许光到达存储单元。紫外线或者 X 射线照射透过窗口，EPROM 单元就被清除为 0。对 EPROM 编程时通过使用一种把 1 写入 EPROM 的特殊设备来完成的，EPROM 能够被擦除和重编程的次数的数量级可以达到 1000 次 电子可擦除可编程存储器（Electrically Eraseable PROM, EEPROM）：类似与 EPROM，但它不需要独立的编程设备，可以直接在印刷电路板上编程，EEPROM 可以编程的次数的数量级可以达到 $ 10^{5} $ 次 闪存（Flash Memory）：基于 EEPROM，多用于手机、相机等产品中，大约 100000 次擦写后失效  需要说明的是，存储在 ROM 设备中的程序通常被称为固件（firmware）。例如 BIOS、磁盘驱动控制器、显卡驱动控制器等等。\n访问主存 数据流通过称为总线（bus）的共享电子电路在处理器和 DRAM 主存之间来来回回。例如下图中，连接 I/O 桥接器与总线接口的系统总线（system bus），连接主存与 I/O 桥接器的内存总线(memory bus)。\n从主存读数据 数据移动路径：主存 -\u0026gt; 内存总线 -\u0026gt; I/O 桥接器 -\u0026gt; 系统总线 -\u0026gt; 总线接口 -\u0026gt; 寄存器\n从主存写数据 数据移动路径：寄存器 -\u0026gt; 总线接口 -\u0026gt; 系统总线 -\u0026gt; I/O 桥接器 -\u0026gt; 内存总线 -\u0026gt; 主存\n机械硬盘 构造 磁盘是由盘片（platter）组成的，每个盘片有两个表面（surface）。盘片中央有一个可以旋转的主轴（spindle），它使得盘片以固定的旋转速率（rotational rate）旋转，通常是 5400-15000 转每分钟（Revolution Per Minute，RPM）。磁盘通常包含一个或多个盘片，并封装在一个密闭的空间中。\n每个盘片的表面是由一组磁道（track）同心圆组成的，每个磁道又被划分为一组扇区（sector）。每个扇区包含相等数据量的数据位（通常是 512 字节），扇区之间由一些间隙（gap）隔开，间隙存储用来表示扇区的格式化位。\n容量 在磁盘容量的计算中，总是按照 1000 进制为准，例如 $ 1GB = 10^{9} Bytes $\n磁盘容量是由以下技术因素决定的：\n 记录密度（Recording density）（位/英寸）：磁道一英寸的段中可以放入的位数 磁道密度（Track density）（道/英寸）：从盘片中心出发半径一英寸的段内可以有的磁道数 面密度（Areal density）（位/平方英寸）：记录密度与磁道密度的乘积  磁盘容量的计算方式：\n$$ 磁盘容量 = \\frac{字节数}{扇区} \\times \\frac{平均扇区数}{磁道} \\times \\frac{磁道数}{表面} \\times \\frac{表面数}{盘片} \\times \\frac{盘片数}{磁道} $$\n例如现有一磁盘，总共有 5 个盘片，每个盘片有 2 个表面，每个表面有 20000 个磁道，每个磁道平均有 300 个扇区，每个扇区有 512 个字节，计算其磁盘容量。\n$$ \\begin{aligned} 磁盘容量 \u0026amp;= \\frac{512 字节}{扇区} \\times \\frac{300 扇区}{磁盘} \\times \\frac{20000 磁道}{表面} \\times \\frac{2 表面}{盘片} \\times \\frac{5盘片}{磁盘} \\newline \u0026amp;= 512 \\times 300 \\times 20000 \\times 2 \\times 5 \\ Byte \\newline \u0026amp;= 30.72 \\ GB \\end{aligned} $$\n固态硬盘 固态硬盘示意图如下：\n一个固态硬盘由 B 个块的序列组成，每个块由 P 页组成。通常，页的大小是 512 字节~4KB，块是由 32~128 页组成的，块的大小为 16KB~512KB。数据是以页为单位读写的，只有在一页所属的块整个被擦除之后，才能写这一页（通常是指该块中的所有位都被设置为 1）。在进行 100000 次重复写之后，块将会磨损损坏。\n分类 现阶段的固态硬盘主要分为以下几类\n 单阶存储单元（Single-Level Cell，SLC）：一个存储单元能存储 1 bit 信息，SLC 闪存的优点是传输速度更快，功率消耗更低和存储单元的寿命更长 多阶存储单元（Multi-Level Cell，MLC）：一个存储单元能存储 2 bit 信息，MLC 闪存可降低生产成本，但比起 SLC 闪存，其传输速度较慢，功率消耗较高和存储单元的寿命较低 三阶存储单元（Triple-Level Cell，TLC）：一个存储单元能存储 3 bit 信息，TLC 的写入速度比 SLC 和 MLC 慢，寿命也比 SLC 和 MLC 短（使用 LDPC 的话，约有 1500 次），大约 1000 次 四阶存储单元（Quad-Level Cell，QLC）：一个存储单元能存储 4 bit 信息，寿命为四者之中最短，大约只有 500 次  在假设低电位表示二进制的 0，高电位表示二进制的 1 时，SLC、MLC、TLC 和 QLC 的电位及二进制值对比表如下。\n对比机械硬盘 优点  固态硬盘没有移动部件，因而随机访问时间比机械硬盘快得多，能耗更低，同时也更结实。  缺点  在反复写之后，固态硬盘存储单元容易磨损 固态硬盘成本更高，相对容量更小  应用  智能手机 笔记本电脑，PC 服务器  发展趋势 下图以半对数为比例，画出了各类存储以及 CPU 性能的发展趋势。\n局部性 一个编写良好的计算机程序常常具有良好的局部性（locality）。也就是它们倾向于引用邻近与其他最近引用过的数据项的数据项，或者最近引用过的数据项本身。局部性通常有两种不同的形式：时间局部性（temporal locality）和空间局部性（spatial locality）。\n下面是一些量化评价程序中局部性的一些简单原则：\n 重复引用相同变量的程序由良好的时间局部性 对于具有步长为 k 的引用模式的程序，步长越小空间局部性越好。具有步长为 1 的引用模式的程序有很好的空间局部性。在内容中以大步长跳来跳去的程序空间局部性会很差 对于取质量来说，循环有好的时间和空间局部性。循环体越小，循环迭代次数越多，局部性越好  存储器层次结构 存储器层次结构（Memory Hierarchy）如下图所示，越靠近底部的存储器速度越慢单价越低，越靠近顶部的则反之。\n缓存 简介 缓存（Cache）是一种容量小但速度极快的存储设备，速度仅次于 CPU 寄存器。它充当速度较慢、容量较大的存储设备的临时存储区。\n层次结构的基本思想 对于第 k 层更快更小的存储设备都充当了第 k+1 层更慢更小的存储设备的缓存。\n存储结构产生的原因 由于局部性，程序通常更倾向于访问第 k 层存储器的数据，而非第 k+1 层存储器的数据。因此，第 k+1 层存储器设备可以做得速度更慢，容量更大以及单价更便宜。\n存储器层次结构中的缓存示例 参考文献  https://zh.wikipedia.org/wiki/%E9%97%AA%E5%AD%98 https://www.bilibili.com/video/av61437877  ","date":"2020-09-20T15:20:11+08:00","permalink":"https://sudrizzz.github.io/posts/cmu-15-213-lesson3/","title":"CMU 15-213 存储器层次结构"},{"content":"前言 在 上一篇文章 中，我们了解了二进制有符号数、无符号数以及其相关的运算方法，在本篇中，我们将进一步了解浮点数在计算机中的相关知识。\n二进制小数 表示方法 二进制小数表达方式：在“二进制小数点”左侧的位表示 2 的 n 次幂，而在“二进制小数点”右侧的位则表示 2 的 -n 次幂。如下图：\n用公式表达如下：\n$$ a = \\sum_{k=-j}^{i}b_{k} \\times 2^{k} $$\n示例 例如，将十进制小数转换为二进制小数，有以下例子：\n   十进制小数 二进制小数     $ 5\\frac{3}{4} $ 101.11   $ 2\\frac{7}{8} $ 10.111   $ 1\\frac{7}{16} $ 1.0111    以第一个为例，我们可以注意到二进制小数按位进行求和的结果是：\n$$ 5\\frac{3}{4} = 2^{2}+2^{0}+2^{-1}+2^{-2} $$\n通过上面三个例子，我们可以注意到，当二进制小数整体右移一位，即相当于将十进制小数除以 2（仅针对无符号数）。相应的，当二进制小数整体左移一位，即相当于将十进制小数乘以 2。\n同时我们应特别注意到，形如 $ 0.11111\u0026hellip;_{2} $ 的二进制小数，表示略比 1 小的十进制数。用公式表示如下：\n$$ 1/2 + 1/4 + 1/8 + \\dots + 1/2^{i} + \\dots \\to 1.0 $$\n记为：\n$$ 1.0-\\varepsilon $$\n其中，$ \\varepsilon $ 取决于二进制小数点右边的 1 有多少位，因此，$ \\varepsilon $ 越小，则二进制小数越接近 1。\n局限性 不精确 二进制小数仅能准确表示形如 $ x/2^{k} $ 的十进制小数，其他形式的小数则需要采用重复位的方式来表示。例如：\n   十进制小数 二进制小数     1/3 $ 0.0101010101[01]\\dots $   1/5 $ 0.001100110011[0011]\\dots $   1/10 $ 0.0001100110011[0011]\\dots $    位数限制 由于浮点数位数有限，将浮点数向左移，则可以表示更大的数，但是会损失精度。将浮点数向右移动，精度得到了提高，但是大数又不能进行表示。\nIEEE 浮点数 位表示 所有的浮点数均可以写成如下形式：\n$$ V = (-1)^{s} \\times M \\times 2^{E} $$\n其中，各个字母含义如下：\n 符号（sign）s 决定这是负数（s=1）还是正数（s=0） 尾数（significand） M 是一个二进制小数，它的范围是 $ 1 \\sim 2 - \\varepsilon $，或者是 $ 0 \\sim 1 - \\varepsilon $ 阶码（exponent）E 的作用是对浮点数进行加权，这个权重是 2 的 E 次幂  32 位或 64 位的浮点数位表示形式如下：\n单精度浮点数各个部分所占的位：\n双精度浮点数各个部分所占的位： 将浮点数的位表示划分为三个字段，分别对这些值进行编码：\n 一个单独的符号位 s 直接编码符号 s k 位的阶码字段 $ exp = e_{k-1} \\dots e_{1}e_{0} $ 编码阶码 E n 位小数字段 $ frac = f_{n-1} \\dots f_{1}f_{0} $ 编码尾数 M，但是编码出来的值也依赖于阶码字段的值是否等于 0  三种情况 规格化的值 当 exp 所有位即不全为 0，也不全为 1 时，我们称之为规格化的值。在这种情况下，阶码字段被解释为以偏置（biased）形式表示的有符号整数。即\n$$ E = e - Bias $$\n其中 e 是无符号数，其位表示为 $ e_{k-1} \\dots e_{1}e_{0} $，而偏置值 $ Bias = 2^{k-1} - 1 $，也即单精度时等于 127，双精度时等于 1023。\n由此编码得到的阶码的取值范围是：\n 单精度：$ -126 \\sim +127 $ 双精度：$ -1022 \\sim +1023 $  小数字段 frac 被解释为描述小数值 f，其中 $ 0 \\le f \u0026lt; 1 $，其二进制表示为 $ 0.f_{n-1} \\dots f_{1}f_{0} $，也就是小数点在最高有效位的左边。\n尾数定义为 $ M = 1 + f $，因此我们可以将 M 看成一个二进制表达式为 $ 1.f_{n-1} \\dots f_{1}f_{0} $ 的数字。此时 $ 1 \\le M \u0026lt; 2 $。\n非规格化的值 当阶码全为 0 时，所表示的数是非规格化形式。在这种情况下，$ E = 1-Bias $，$ M = f $，也就是小数部分的值，不包含隐含的开头的 1。\n非规格化数主要有两个作用：用来表示 0 或者表示接近于 0 的数。\n当浮点数二进制位全为 0 时：符号位为 0，阶码全为 0，小数域全为 0，即 $ s = M = f = 0 $，此时表示得到的浮点数是 +0.0。但当符号位为 1 且其他域全为 0 时，可以得到浮点数 -0.0。根据 IEEE 的浮点格式，值 +0.0 和 -0.0 在某些方面被认为是不同的，而在其他方面是相同的。\n非规格化数提供一种称为逐渐溢出（gradually underflow）的属性，可以用来表示接近于 0 的数值。\n特殊情况 在阶码全为 1 的前提下，如果小数域全为 0 时，结果为无穷大或无穷小；如果小数域非 0 时，结果为 NaN（Not a Number）。\n其中小数域全为 0 时，当 $ s = 0 $ 时是 $ +\\infty $，当 $ s = 1 $ 时是 $ -\\infty $。\n一些运算的结果不是实数或者是无穷时，这样就会返回 NaN，例如计算 $ \\sqrt{-1} $ 或者 $ \\infty - \\infty $ 时。\n舍入    舍入方式 1.40 1.60 1.50 2.50 –1.50     向 0 舍入 1 1 1 2 –1   向下舍入（−∞） 1 1 1 2 –2   向上舍入（+∞） 2 2 2 3 –1   向偶数舍入（默认） 1 2 2 2 –2    上述的向偶数舍入实际上就是四舍五入，但需要注意的是，在舍入时优先考虑向偶数舍入。例如上述的 1.50 向上舍入到 2，而 2.5 按照四舍五入应该舍入到 3，由于 3 并不是偶数，故应该向下舍入到 2。\n在现实情况中，向偶数舍入（也称为向最接近的整数）避在大多数情况下避免了统计误差，在 50% 的时间里它将向上取整，而在另外的 50% 时间里它将向下取整，所以它是默认的舍入方式。\n例如我们要对以下数字进行针对百分位的舍入，结果如下：\n   数据 结果     7.8949999 7.89   7.8950001 7.90   7.8950000 7.90   7.8850000 7.88    浮点运算 乘法 定义：\n$$ a = (-1)^{s_{1}} \\times M_{1} \\times 2^{E_{1}} $$\n$$ b = (-1)^{s_{2}} \\times M_{2} \\times 2^{E_{2}} $$\n$$ c = a \\times b = (-1)^{s} \\times M \\times 2^{E} $$\n其中：\n $ s = s_{1} \\land s_{2} $ $ M = M_{1} \\times M_{2} $ $ E = E_{1} + E_{2} $  特殊情况处理：\n 如果 M ≥ 2，将 M 右移，增大 E 如果 E 超出范围，则溢出到 $ \\infty $ 如果 M 位数过多，则舍入到有限位能表示为止  加法 定义：\n$$ a = (-1)^{s_{1}} \\times M_{1} \\times 2^{E_{1}} $$\n$$ b = (-1)^{s_{2}} \\times M_{2} \\times 2^{E_{2}} $$\n假定 $ E_{1} \\gt E_{2} $，则：\n$$ c = a + b = [(-1)^{s_{1}} \\times M_{1} \\times 2^{E_{1}-E_{2}} + (-1)^{s_{2}} \\times M_{2}] \\times 2^{E_{2}} $$\n浮点数加法的一般步骤如下：\n 对阶：将指数较小的浮点数（b）进行尾数向右移位，指数同步增大，直到两个操作数的指数等 求和：对尾数进行求和 规格化：对指数和尾数做规格化，并对尾数进行舍入  特殊情况处理：\n 如果 M ≥ 2，将 M 右移，增大 E 如果 M \u0026lt; 1，将 M 左移，同步减小 E 如果 E 超出范围，则溢出到 $ \\infty $ 如果 M 位数过多，则舍入到有限位能表示为止  参考文献  https://qiankun214.github.io/2019/05/28/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%A4%84%E7%90%86/  ","date":"2020-09-14T18:57:11+08:00","permalink":"https://sudrizzz.github.io/posts/cmu-15-213-lesson2/","title":"CMU 15-213 浮点数"},{"content":"应用示例  本篇文章中所使用的 Nginx 是通过下载软件包手动编译安装的，详见 上一篇文章 离线安装部分。\n 在上一篇文章中，我们初步接触了 Nginx 的安装以及使用方法。在本篇文章中我们将以具体的静态网页作为例子，来详细介绍 Nginx 的部分细节。\n文件准备 我们以 C++ 文档 dlib 为例做介绍，官网 http://dlib.net，点击左下角的 Download 按钮并将下载好的文件解压。将文件夹中的 docs 目录内容复制到 Nginx 安装目录中的 dlib 目录中。相关的目录结构如下。\n1drwxr-xr-x. 9 root root 258 9月 11 16:54 blog 2drwx------. 2 nobody root 6 9月 6 15:26 client_body_temp 3drwxr-xr-x. 2 root root 4096 9月 11 19:48 conf 4drwxrwxrwx. 10 root root 8192 8月 9 03:30 dlib 5drwx------. 2 nobody root 6 9月 6 15:26 fastcgi_temp 6drwxr-xr-x. 2 root root 40 9月 6 15:24 html 7drwxr-xr-x. 2 root root 58 9月 11 16:20 logs 8drwx------. 2 nobody root 6 9月 6 15:26 proxy_temp 9drwxr-xr-x. 2 root root 19 9月 6 15:24 sbin 10drwx------. 2 nobody root 6 9月 6 15:26 scgi_temp 11drwx------. 2 nobody root 6 9月 6 15:26 uwsgi_temp 修改配置 编辑 conf/nginx.conf，将 server 中的 location 部分修改为如下配置。\nlocation / { alias dlib/; #... } 其中，location 后的 / 代表根域名指向括号中的目录配置，alias 指定一个目录替代默认目录。\n 更多信息可以查看官方文档\nhttp://nginx.org/en/docs/http/ngx_http_core_module.html#alias\n 重新加载 执行以下命令，以新加载 Nginx 服务。\n1nginx -s reload 访问 执行完以上步骤后，访问 Nginx 的地址，即可看到 dlib 下的静态文件已经被正常加载了。如下图。\n常用配置 以下内容均在 nginx.conf 文件中进行配置。\n数据压缩 根据以上的配置，我们已经可以正常访问部署好的静态网页，但是根据开发者工具我们可以看到，首页的大小是 26.4 kB。我们还可以进一步进行优化，将所需要加载的数据进行压缩，使其所需数据量大大减少。\n在 http 部分中添加以下配置。\ngzip on; gzip_min_length 1; gzip_comp_level 2; gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/x- httpd- php image/jpeg image/gif image/png; 本例中所涉及到的配置释义如下。\n   配置 释义     gzip on | off 是否启用数据压缩   gzip_min_length 会被压缩的响应的最小长度（单位 kB），即返回内容大于此配置时才会被压缩   gzip_comp_level 设置 gzip 压缩等级，等级越小压缩速度越快、文件压缩比越小。压缩等级范围是 1-9，压缩等级越高对性能要求越高。   gzip_types 设置需要压缩的 MIME 类型，非设置值不进行压缩，即匹配压缩类型     更多信息可以查看官方文档\nhttp://nginx.org/en/docs/http/ngx_http_gzip_module.html\n 可以看到，开启 gzip 压缩后，加载的数据量大幅减少。\n加载速度 使用 limit_rate 可以对网页加载速度进行控制，详细如下。\nserver { #... set $limit_rate 1k; #... } 其中，$limit_rate 是控制访问速度的变量。后面紧跟的 1k 是需要限制的速度，此例中的单位为 kB，也可以设置其他单位，例如 1M。\n 更多信息可以查看官方文档\nhttp://nginx.org/en/docs/http/ngx_http_core_module.html#var_limit_rate\n 记录日志 在 http 模块中，可以配置日志记录的格式，以及日志记录的位置和文件名等等，配置如下。\nhttp { #... log_format main '$remote_addr - $remote_user [$time_local] \u0026quot;$request\u0026quot; ' '$status $body_bytes_sent \u0026quot;$http_referer\u0026quot; ' '\u0026quot;$http_user_agent\u0026quot; \u0026quot;$http_x_forwarded_for\u0026quot;'; access_log logs/sample.log main; #... }  更多信息可以查看官方文档\nhttp://nginx.org/en/docs/http/ngx_http_log_module.html#access_log\n 反向代理 在此部分，我们使用两台 Nginx 服务器作为示例，分别是 192.168.61.128 和 192.168.61.129，简记为 CentOS_1 与 CentOS_2。\n修改 CentOS_1 的 Nginx 配置文件，修改部分如下，此时直接访问 192.168.61.128 已经不能正常进行加载。\nserver { listen 127.0.0.1:80; server_name localhost; #... } 修改 CentOS_2 的 Nginx 配置文件，修改部分如下，我们将 192.168.61.129:80 指向了 192.168.61.128:80。\nupstream local { server 192.168.61.128:80; } server { listen 80; server_name 192.168.61.129; location / { proxy_set_header Host $host:$server_port; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://local/; } #... } 分别在两台机器上重新加载 Nginx 配置文件，并访问 192.168.61.129:80，此时可以正常打开 192.168.61.128:80 上所配置的静态文件。\n 上述配置可以参考官方文档\nhttp://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_set_header\n 日志可视化 在本例中，我们使用 GoAccess 首先日志试试可视化。\n安装 GoAccess 由于此例中使用的系统是 CentOS 8，安装 GoAccess 之前需要先配置 epel 源。\n配置 epel 源  安装 epel 配置包  1yum install -y https://mirrors.aliyun.com/epel/epel-release-latest-8.noarch.rpm 将 repo 配置中的地址替换为阿里云镜像站地址  sed -i 's|^#baseurl=https://download.fedoraproject.org/pub|baseurl=https://mirrors.aliyun.com|' /etc/yum.repos.d/epel* sed -i 's|^metalink|#metalink|' /etc/yum.repos.d/epel* 安装 GeoIP 编译安装 GoAccess 需要用到 GeoIP。\nsudo yum -y --enablerepo=epel install geoip 安装 GoAccess 根据官网的文档，我们顺序执行以下命令即可。\n1wget https://tar.goaccess.io/goaccess-1.4.tar.gz 2tar -xzvf goaccess-1.4.tar.gz 3cd goaccess-1.4/ 4./configure --enable-utf8 --enable-geoip=legacy 5make 6make install 安装完成后，使用以下命令，若得到类似结果则表明安装成功。\n1goaccess -v 1GoAccess - 1.4. 2For more details visit: http://goaccess.io 3Copyright (C) 2009-2020 by Gerardo Orellana 4 5Build configure arguments: 6 --enable-utf8 7 --enable-geoip=legacy 配置 GoAccess 在使用前，我们需要对 GoAccess 的配置文件进行一些修改，以方便后续使用。\nvim /usr/local/etc/goaccess/goaccess.conf 在此配置文件中，将以下内容取消注释，其他内容则保持不变。\n#... no-ip-validation true log-format COMBINED time-format %H:%M:%S date-format %d/%b/%Y real-time-html true #... 启动监听 在 Nginx 的 logs 目录中，我们以 access 为源文件，启动 GoAccess 进程后，会产生一个 websocket 长连接，持续监听客户端的请求数据，进而实时展现在 report.html 页面上。\n1cd /usr/local/nginx/logs 2goaccess access.log -o ../html/report.html 此时我们还需要修改 nginx.conf 使报告页面可以直接访问，在 server 部分添加如下内容。\nlocation /report.html { alias html/report.html; } 然后重新加载配置即可。\n1nginx -s reload 至此，日志可视化已经配置完成，我们可以直接访问 Nginx 服务地址/report.html 查看可视化页面，如下。\n附录 Linux 查看端口占用状态\n查看占用 1netstat -anp 其中，参数 anp 分别表示：\n  a：显示所有活动的 TCP 连接，以及正在监听的 TCP 和 UDP 端口\n  n：以数字形式表示地址和端口号，不试图去解析其名称（number），参数 -n 会将应用程序转为端口显示，即数字格式的地址，如：nfs-\u0026gt;2049，ftp-\u0026gt;21\n  p：列出与端口监听或连接相关的进程，即 pid\n  关闭占用 在本例中，若要关闭 GoAccess 建立的连接，首先执行如下命令拿到其 pid。\n1netstat -anp | grep goaccess 结果如下。\n1tcp 0 0 0.0.0.0:7890 0.0.0.0:* LISTEN 2323/goaccess 2tcp 0 0 192.168.61.128:7890 192.168.61.1:56503 ESTABLISHED 2323/goaccess 然后手动 kill 其进程即可。\n1kill 2323 ","date":"2020-09-11T19:51:07+08:00","permalink":"https://sudrizzz.github.io/posts/getting-to-know-nginx-2/","title":"初识 Nginx（二）"},{"content":"Nginx 简介  简介内容来自 Nginx 官网 http://nginx.org/en\nnginx [engine x] is an HTTP and reverse proxy server, a mail proxy server, and a generic TCP/UDP proxy server, originally written by Igor Sysoev. For a long time, it has been running on many heavily loaded Russian sites including Yandex, Mail.Ru, VK, and Rambler. According to Netcraft, nginx served or proxied 25.75% busiest sites in August 2020. Here are some of the success stories: Dropbox, Netflix, Wordpress.com, FastMail.FM.\nThe sources and documentation are distributed under the 2-clause BSD-like license.\nCommercial support is available from Nginx, Inc.\n 简而言之，Nginx 是一个高性能的 HTTP 和反向代理服务器，特点是占有内存少，并发能力强。详细信息请查看 Nginx 官网介绍页面。\n 以下两种安装方式，任意选择一种进行安装即可。\n 在线安装 Nginx 注意，本篇文章基于 CentOS 8.2 版本，如使用其他系统，操作可能有一些变化，一切以官方网站安装教程为准。\n首先我们需要先安装 yum-utils 包，执行以下命令即可。\n1sudo yum install yum-utils 然后配置 Nginx 仓库，我们需要在 /etc/yum.repo.d/ 中创建一个名为 nginx.repo 的文件，并填入以下内容。\n[nginx-stable] name=nginx stable repo baseurl=http://nginx.org/packages/centos/$releasever/$basearch/ gpgcheck=1 enabled=1 gpgkey=https://nginx.org/keys/nginx_signing.key module_hotfixes=true [nginx-mainline] name=nginx mainline repo baseurl=http://nginx.org/packages/mainline/centos/$releasever/$basearch/ gpgcheck=1 enabled=0 gpgkey=https://nginx.org/keys/nginx_signing.key module_hotfixes=true 默认情况下使用的是 Nginx 稳定版仓库，即配置中的 nginx-stable。如果需要使用主线版仓库，可以执行下面的命令进行手动指定。\n1sudo yum-config-manager --enable nginx-mainline 上述准备工作完成后，就可以开始安装 Nginx 了，执行下面这条命令即可。\n1sudo yum install nginx 稍等片刻完成安装后，可使用下述命令来验证是否安装成功。\n1nginx -v 2whereis nginx 得到类似于下面的输出，即代表安装成功。\nnginx version: nginx/1.18.0 nginx: /usr/sbin/nginx /usr/lib64/nginx /etc/nginx /usr/share/nginx /usr/share/man/man8/nginx.8.gz 离线安装 Nginx 下载并解压 1cd /usr/local/software 2 3# 下载 4sudo wget http://nginx.org/download/nginx-1.18.0.tar.gz 5 6# 解压 7tar -zxvf nginx-1.18.0.tar.gz -C ./ 编译 1cd nginx-1.18.0 2sudo ./configure --prefix=/usr/local/nginx 其中 --prefix 的作用是指定编译后的文件存放位置，可以根据实际情况自由确定。\n编译过程中可能会遇到一些报错，详细信息和解决方案如下。\n 此部分内容参照文章 Nginx 教程(一) Nginx 入门教程\n   ./configure: error: C compiler cc is not found\n错误原因：缺少编译环境，安装编译源码所需要的工具和库：\n执行命令：sudo yum install gcc gcc-c++ ncurses-devel perl\n  ./configure: error: the HTTP rewrite module requires the PCRE library\n错误原因：缺少 HTTP rewrite module 模块\n执行命令：sudo yum install pcre pcre-devel\n  ./configure: error: the HTTP gzip module requires the zlib library\n错误原因：缺少 HTTP zlib 类库，我们选择安装模块：\n执行命令：sudo yum install zlib gzip zlib-devel\n  上述报错都解决了之后，再次执行编译命令，可以得到如下输出。\nConfiguration summary + using system PCRE library + OpenSSL library is not used + using system zlib library nginx path prefix: \u0026quot;/usr/local/nginx\u0026quot; nginx binary file: \u0026quot;/usr/local/nginx/sbin/nginx\u0026quot; nginx modules path: \u0026quot;/usr/local/nginx/modules\u0026quot; nginx configuration prefix: \u0026quot;/usr/local/nginx/conf\u0026quot; nginx configuration file: \u0026quot;/usr/local/nginx/conf/nginx.conf\u0026quot; nginx pid file: \u0026quot;/usr/local/nginx/logs/nginx.pid\u0026quot; nginx error log file: \u0026quot;/usr/local/nginx/logs/error.log\u0026quot; nginx http access log file: \u0026quot;/usr/local/nginx/logs/access.log\u0026quot; nginx http client request body temporary files: \u0026quot;client_body_temp\u0026quot; nginx http proxy temporary files: \u0026quot;proxy_temp\u0026quot; nginx http fastcgi temporary files: \u0026quot;fastcgi_temp\u0026quot; nginx http uwsgi temporary files: \u0026quot;uwsgi_temp\u0026quot; nginx http scgi temporary files: \u0026quot;scgi_temp\u0026quot; 安装 1cd /usr/local/software/nginx-1.18.0 2sudo make \u0026amp; make install 得到如下输出时，即表明 Nginx 已经安装成功。\n... test -d '/usr/local/nginx/logs' \\ || mkdir -p '/usr/local/nginx/logs' make[1]: 离开目录“/usr/local/software/nginx-1.18.0” [1]+ 已完成 make 在线安装 Nginx 的启动方式  如果是采用手动编译安装 Nginx 的方式，请跳过本节查看下一节内容。\n 配置 nginx.conf 首先编辑 /etc/nginx/nginx.conf 文件，配置 Nginx 端口与访问地址（即 server 部分）。在配置端口时，不建议设置为 80，以免与其他服务冲突。具体配置如下。\nuser nginx; worker_processes 1; error_log /var/log/nginx/error.log warn; pid /var/run/nginx.pid; events { worker_connections 1024; } http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] \u0026quot;$request\u0026quot; ' '$status $body_bytes_sent \u0026quot;$http_referer\u0026quot; ' '\u0026quot;$http_user_agent\u0026quot; \u0026quot;$http_x_forwarded_for\u0026quot;'; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; include /etc/nginx/conf.d/*.conf; # 在这里新增 server 配置 server { listen 8090; server_name localhost; location / { root html; index index.html index.htm; } } } 系统防火墙 由于我的 CentOS 是安装在虚拟机中，未安装图形界面，故需要在宿主机上进行测试并访问虚拟机地址，所以需要增加一步禁用 CentOS 防火墙的操作，具体命令如下。\n1# 关闭防火墙 2systemctl stop firewalld.service 3 4# 禁止防火墙开机自启 5systemctl disable firewalld.service 现在可以正式启动 Nginx 服务了，执行下述命令即可。\n1sudo nginx 执行之后，可以使用下面命令检查是否启动成功，以及访问地址和端口是否生效。\n查看包含 nginx 关键词的进程 1ps -ef | grep nginx 结果如下，可以看到已经成功启动了。\nroot 4781 1 0 14:31 ? 00:00:00 nginx: master process nginx nginx 5055 4781 0 14:36 ? 00:00:00 nginx: worker process 查看本机所有暴露的端口 1netstat -ntlp 结果如下，可以看到此前配置的 8090 端口已经是 listen 状态，接下来就可以在浏览器中访问了。\nActive Internet connections (only servers) Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name ... tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN - tcp 0 0 0.0.0.0:8090 0.0.0.0:* LISTEN - tcp 0 0 127.0.0.1:6010 0.0.0.0:* LISTEN - ... 在浏览器中访问 虚拟机ip:8090，即可看到 Nginx 的欢迎页面。\n 此时返回 404 是因为 Nginx 目录中并没有欢迎页面的 html 文件，但依然可以说明已经 Nginx 服务已经配置正确并启动成功。\n 离线安装 Nginx 的启动方式 首先执行下述命令来启动 Nginx。\n1cd /usr/local/nginx/sbin 2sudo ./nginx 同样的，我们可以按照上一节中介绍的方法，来验证 Nginx 是否启动成功，以及端口是否开放。\nNginx 服务默认的端口是 80，如果需要修改端口，也可以参照上一节中的内容进行手动修改，略有不同的是，通过手动编译安装的 Nginx，配置文件地址在 /usr/local/nginx/conf/nginx.conf，也就是编译时我们手动指定的路径下。 其余内容此处皆不再赘述。\n打开宿主机浏览器，访问 虚拟机ip:80，就可以看到 Nginx 的欢迎页面。\n修改 nginx.conf 如果后续需要修改 nginx.conf 中的内容，例如更改 Nginx 服务端口号，请务必在修改完成后重启服务。常用的 Nginx 命令如下。\n1# 检查 nginx.conf 是否配置正确 2sudo nginx -t 3 4# 重启 Nginx 服务 5sudo nginx -s reload 6 7# 停止 Nginx 服务 8sudo nginx -s stop 附录 在 Linux 中查找某一个具体文件路径时，可以使用以下命令。\n1sudo find / -name filename  / 代表查找的目录，此例是根目录 -name 代表按照文件名进行查找 filename 代表具体的文件名，例如 nginx.conf  以本文章为例，在根目录中查找 nginx.conf 的结果如下。\n/etc/nginx/nginx.conf /usr/local/software/nginx-1.18.0/conf/nginx.conf /usr/local/nginx/conf/nginx.conf ","date":"2020-09-07T15:47:11+08:00","permalink":"https://sudrizzz.github.io/posts/getting-to-know-nginx/","title":"初识 Nginx"},{"content":"简介 CSAPP 课程全程 Computer Systems: A Programmer’s Perspective，中文翻译为“从程序员的视角，看计算机系统！”或“深入理解计算机系统”。此课程是卡耐基梅隆大学开设的一门课程，官方网站 https://www.cs.cmu.edu/~213/index.html。\n 内容简介节选自豆瓣\nhttps://book.douban.com/subject/1230413\n从程序员的视角，看计算机系统！\n本书适用于那些想要写出更快、更可靠程序的程序员。通过掌握程序是如何映射到系统上，以及程序是如何执行的，读者能够更好的理解程序的行为为什么是这样的，以及效率低下是如何造成的。粗略来看，计算机系统包括处理器和存储器硬件、编译器、操作系统和网络互连环境。而通过程序员的视角，读者可以清晰地明白学习计算机系统的内部工作原理会对他们今后作为计算机科学研究者和工程师的工作有进一步的帮助。它还有助于为进一步学习计算机体系结构、操作系统、编译器和网络互连做好准备。\n 一切皆位 十进制 在计算机发展历史上，实际上只有宾夕法尼亚大学建立的第一台计算机 ENIAC 使用了十进制进行了算术运算，他们使用 10 个电子管来表示每个数字。所以他们通过控制电子管的开关来表示 10 个数字中的其中一个。\n二进制 随着计算机的发展，十进制逐渐演化为二进制。在计算机中，我们使用电学层面上的电压高低来存储位数据，如图所示，高电压（0.9v-1.1v）记作逻辑 1，而低电压（0.0v-0.2v）记作逻辑 0。\n之所以这么做，是因为通过区分高低电压，可以有效地过滤噪声和杂讯。\n十六进制 二进制的成功运用也带来了一个问题，由于每一个位只能存储两种信号（即 0 和 1），对于人来说基本属于不可读的，所以我们将每四个二进制在位合并为一个十六进制位，这样大大缩减了数据的展示长度。例如\n具体数据类型实际所占空间 此处以 C 语言数据类型为例，因为在 32 位与 64 位机器上所占空间不尽相同，故列下表。\n   C Data Type Typical 32-bit Typical 64-bit x86-64     char 1 1 1   short 2 2 2   int 4 4 4   long 4 8 8   float 4 4 4   double 8 8 8   pointer 4 8 8    位操作 与、或、非、异或 通俗的解释如下：\n 与（\u0026amp;）：两者都为真时，结果为真，否则为假； 或（|）：任意一者为真时，结果为真，否则为假； 非（~）：对元素取反； 异或（^）：两者性质相同时，结果为假，否则为真。  详细示例见下图。\n与集合的关系 我们将二进制数据从右往左标记位置，红色数字位置代表该为值为 1，右侧集合中数据代表该二进制数据中所有位值为 1 的位置。例如第一个数据 01101001，从右往左计数，第 0、3、5、6 位对应值为 1。对第二个数进行同样的处理。\n此时我们对两个数据进行与、或、非、异或操作时，可以得出下述结论。\n   数据操作 对应集合操作 结果数据 结果集合     \u0026amp; 交集 1000001 {0, 6}   | 并集 1111101 {0, 2, 3, 4, 5, 6}   ^ 差集 111100 {2, 3, 4, 5}   ~ 补集 10101010 {1, 3, 5, 7}    移位 左移 x \u0026laquo; y 左移即将二进数据 x 整体向左移动 y 个位置，并在其右侧补 0。例如\n    结果     元素 x 01100010   \u0026laquo; 3 00010000    右移 x \u0026raquo; y 与左移一样，右移即将二进数据 x 整体向右移动 y 个位置，并在其空缺位填充相应数据。而右移又分为逻辑右移和算数右移，具体区别如下。\n逻辑右移 在逻辑右移过程中，需要在其左侧空缺位置补 0。例如\n    结果     元素 x 01100010   \u0026raquo; 2 00101000    算术右移 在算术右移过程中，需要在其左侧空缺位置补 1。例如\n    结果     元素 x 01100010   \u0026raquo; 2 11101000    无符号数与补码 无符号数的表达形式：\n$$ B2U(X) = \\sum_{i=0}^{w-1}x_{i} \\cdot 2^{i} $$\n补码的表达形式：\n$$ B2T(X) = -x_{w-1}\\cdot 2^{w-1}+\\sum_{i=0}^{w-2}x_{i}\\cdot 2^{i} $$\n在补码中，最高值为 1 时，始终代表 -1，例如：\n有了补码，计算机就可正常表示负数。例如：\n    十进制 十六进制 二进制     x 15213 3B 6D 00111011 01101101   y -15213 C4 93 11000100 10010011    数据范围 此处我们以 16 位二进制数（即 w=16）来探讨无符号数和补码的范围，如下表。 其中，UMax 代表无符号数最大值，TMax 代表补码最大值，TMin 代表补码最小值。\n    十进制 十六进制 二进制     UMax 65535 FF FF 11111111 11111111   TMax 32767 7F FF 01111111 11111111   TMin -32768 80 00 10000000 00000000   -1 -1 FF FF 11111111 11111111   0 0 00 00 00000000 00000000    当数据的位宽 w 发生变化时，代表的数据最值也会发生相应的变化，如下表。\n    8 位 16 位 32 位 64 位     UMax 255 65,535 4,294,967,295 18,446,744,073,709,551,615   TMax 127 32,767 2,147,483,647 9,223,372,036,854,775,807   TMin -128 -32,768 -2,147,483,648 -9,223,372,036,854,775,808    根据以上性质，我们可以得出以下结论：\n$$ |TMin| = TMax + 1 $$\n$$ UMax = 2 * TMax + 1 $$\n补码形式转换为无符号数 有符号数扩充 已知一个 w 位的有符号数 X，现在需要将其转换为 w+k 位相同值的有符号数，可以按照下述步骤进行操作。\n 将符号标识位（sign bit）拷贝 k 份，填充到扩充的 k 个位置上； 此时 X 就可以按位表示为  $$ X^{'} = \\underbrace{X_{w-1},\u0026hellip;, X_{w-1}}_{k 个符号位拷贝}, X_{w-1}, X_{w-2},\u0026hellip;, X_{0} $$\n详细信息如下图所示：\n示例 定义两个 short 变量 x 与 y，将其分别扩充为 int 变量，得到 ix 与 iy，详细结果如下。\n1short int x = 15213; 2int ix = (int) x; 3short int y = -15213; 4int iy = (int) y;     十进制 十六进制 二进制     x 15213 3B 6D 00111011 01101101   ix 15213 00 00 3B 6D 00000000 00000000 00111011 01101101   y -15213 C4 93 11000100 10010011   iy -15213 FF FF C4 93 11111111 11111111 11000100 10010011    移位实现 2 的次方倍算术操作 乘法 给定一个整数 u，其 2 的次方倍乘法操作相对简单，且对于无符号数和有符号数都是统一的操作，即将数据的二进制位向左移动，再将移动产生的多余位进行舍弃，剩余位即最终结果。也即\n$$ u \u0026laquo; k = u * 2^{k} $$\n除法 无符号数 给定一个无符号数 u，对其做 2 的次方倍除法，相当于将其二进制位向右进行逻辑移位，再将小数部分进行舍弃（向下取整），剩余位即最终结果。也即\n$$ u \u0026raquo; k = \\lfloor u / 2^{k} \\rfloor $$\n例如：\n    算术除法 计算结果 十六进制 二进制     x 15213 15213 3B 6D 00111011 01101101   x \u0026raquo; 1 7606.5 7606 1D B6 00011101 10110110   x \u0026raquo; 4 950.8125 950 03 B6 00000011 10110110   x \u0026raquo; 8 59.4257813 59 00 3B 00000000 00111011    有符号数 给定一个有符号数 x，对其做 2 的次方倍除法，相当于将其二进制位向右进行算术移位，再将小数部分进行舍弃（向下取整），剩余位即最终结果。也即\n$$ x \u0026raquo; k = \\lfloor x / 2^{k} \\rfloor $$\n例如：\n    算术除法 计算结果 十六进制 二进制     y -15213 -15213 C4 93 11000100 10010011   y \u0026raquo; 1 -7606.5 -7607 E2 49 11100010 01001001   y \u0026raquo; 4 -950.8125 -951 FC 49 11111100 01001001   y \u0026raquo; 8 -59.4257813 -60 FF C4 11111111 11000100    ","date":"2020-09-04T19:02:11+08:00","permalink":"https://sudrizzz.github.io/posts/cmu-15-213-lesson1/","title":"CMU 15-213 位、字节与整数"},{"content":"Docker 简介 简介来自于 Docker 入门教程 - 阮一峰的网络日志\n Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。\nDocker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。\n总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。\n 安装 Docker 在此部分，作者使用的是 Centos 8.2 进行的操作，下述的安装命令仅保证在该环境下运行。\n设置 Docker 仓库 根据官方教程，执行以下两条命令：\n1sudo yum install -y yum-utils 2 3sudo yum-config-manager \\ 4 --add-repo \\ 5 http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 由于国内直接连接 Docker 官方镜像源十分缓慢，所以在第二个命令中将官方镜像源替换为阿里云镜像源。\n安装 Docker 引擎 1sudo yum install docker-ce docker-ce-cli containerd.io 在执行这条命令时，极有可能会报错。比如作者遇到的报错如下：\nError: Problem: package docker-ce-3:19.03.8-3.el7.x86_64 requires containerd.io \u0026gt;= 1.2.2-3, but none of the providers can be installed - cannot install the best candidate for the job - package containerd.io-1.2.10-3.2.el7.x86_64 is excluded - package containerd.io-1.2.13-3.1.el7.x86_64 is excluded - package containerd.io-1.2.2-3.3.el7.x86_64 is excluded - package containerd.io-1.2.2-3.el7.x86_64 is excluded - package containerd.io-1.2.4-3.1.el7.x86_64 is excluded - package containerd.io-1.2.5-3.1.el7.x86_64 is excluded - package containerd.io-1.2.6-3.3.el7.x86_64 is excluded 为了解决这个报错，需要先执行下述命令安装好 containerd.io 组件。\n1sudo yum install -y \\ 2 https://mirrors.aliyun.com/docker-ce/linux/centos/7/x86_64/edge/Packages/containerd.io-1.2.13-3.2.el7.x86_64.rpm 3 4sudo yum -y install ./containerd.io-1.2.13-3.1.el7.x86_64.rpm 至于为什么安装的 containerd.io 组件是 centos 7 目录下的，有两个原因：\n 此版本在 centos 8 环境下也可以正常使用； 阿里云官方只提供了适配 centos 7 的 containerd.io 组件。  然后重新执行上述命令即可完成 Docker 的安装。\n1sudo yum install docker-ce docker-ce-cli 我们可以通过两个命令来验证 Docker 是否安装成功。\n1docker version 2# 或 3docker info 若输出类似于以下的内容，则配置正确。\n[root@localhost ~]# docker version Client: Docker Engine - Community Version: 19.03.12 API version: 1.40 Go version: go1.13.10 Git commit: 48a66213fe Built: Mon Jun 22 15:46:54 2020 OS/Arch: linux/amd64 Experimental: false Server: Docker Engine - Community Engine: Version: 19.03.12 API version: 1.40 (minimum version 1.12) Go version: go1.13.10 Git commit: 48a66213fe Built: Mon Jun 22 15:45:28 2020 OS/Arch: linux/amd64 Experimental: false containerd: Version: 1.2.6 GitCommit: 894b81a4b802e4eb2a91d1ce216b8817763c29fb runc: Version: 1.0.0-rc8 GitCommit: 425e105d5a03fabd737a126ad93d62a9eeede87f docker-init: Version: 0.18.0 GitCommit: fec3683 配置 Docker 仓库 由于在国内连接 Docker 官方仓库 https://hub.docker.com 十分缓慢，故我们可以将仓库地址更换为国内的各种源，详细步骤如下。\n 在 /etc/docker 目录中新增一个名为 daemon.json 的配置文件，如果已经存在这个文件，则只需要进行修改。 将该文件中的 registry-mirrors 项修改为如下形式。  1{ 2 \u0026#34;registry-mirrors\u0026#34;: [ 3 \u0026#34;https://kuamavit.mirror.aliyuncs.com\u0026#34;, 4 \u0026#34;https://docker.mirrors.ustc.edu.cn\u0026#34; 5 ] 6} 到此就配置完毕了。\n启动并运行 Docker 启动 1$ sudo service docker start 2# 或 3$ sudo systemctl start docker 运行 hello-world 1sudo docker run hello-world 此时，由于本地尚未安装 hello-world 实例，Docker 会自动从上文中配置的镜像中拉取 hello-world 实例，然后运行这个实例。具体输出如下。\n[root@localhost docker]# docker run hello-world # 这里提示未在本地找到 hello-world 实例，将从镜像中拉取最新版。 Unable to find image 'hello-world:latest' locally latest: Pulling from library/hello-world 0e03bdcc26d7: Pull complete Digest: sha256:7f0a9f93b4aa3022c3a4c147a449bf11e0941a1fd0bf4a8e6c9408b2600777c5 Status: Downloaded newer image for hello-world:latest # 开始运行 Hello from Docker! This message shows that your installation appears to be working correctly. To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the \u0026quot;hello-world\u0026quot; image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal. To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bash Share images, automate workflows, and more with a free Docker ID: https://hub.docker.com/ For more examples and ideas, visit: https://docs.docker.com/get-started/ 容器管理 当 image 文件开始运行之后，就会生成一个容器实例，容器实例实际上也是一个文件，故也称为实例文件。当容器实例停止运行时，容器文件并不会被删除。\n 列出本机正在运行的容器  1sudo docker container ls 列出本机所有容器（包括已停止运行的）  1sudo docker container ls -all 输出结果如下。\nCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES d3a382fde773 hello-world \u0026quot;/hello\u0026quot; 8 minutes ago Exited (0) 8 minutes ago romantic_proskuriakova 其中 CONTAINER ID 就是该容器的唯一标识符，在后续的终止容器运行时需要用到。\n终止容器运行  1sudo docker container kill d3a382fde773 当然本例中 hello-world 容器已经停止运行了，所以不能再次停止，此处仅做示例。 即使一个容器文件已经停止运行，但是其依然会占据磁盘空间，可以使用下述命令进行删除。\n1sudo docker container rm d3a382fde773 镜像管理 当我们拉取了多个镜像，其中某些又不需要使用了，则需要对镜像进行手动管理，详细操作如下。\n 罗列所有本地已经安装的镜像  1sudo docker image ls 输出如下\nREPOSITORY TAG IMAGE ID CREATED SIZE hello-world latest bf756fb1ae65 8 months ago 13.3kB 移除不需要的镜像  1sudo docker image rm hello-world 注意，如果 image 在运行，或者已经生成了实例文件，是不能直接删除的，需要先将实例容器停止并删除实例文件，才可以正常删除。执行结果如下。\nUntagged: hello-world:latest Untagged: hello-world@sha256:7f0a9f93b4aa3022c3a4c147a449bf11e0941a1fd0bf4a8e6c9408b2600777c5 Deleted: sha256:bf756fb1ae65adf866bd8c456593cd24beb6a0a061dedf42b26a993176745f6b Deleted: sha256:9c27e219663c25e0f28493790cc0b88bc973ba3b1686355f221c38a36978ac63 ","date":"2020-09-02T18:37:11+08:00","permalink":"https://sudrizzz.github.io/posts/getting-to-know-docker/","title":"初识 Docker"},{"content":"前情提要 在前文中我们实现了在 Github 中部署博客，此文将简化发文操作步骤，并实现文章图片管理。\n创建仓库  注意：\n由于 username 不方便叙述，故下文中均以 sudrizzz 为例替代 username，\n请读者根据实际情况进行更改。\n 在上文中我们已经创建了一个名为 \u0026lt;username\u0026gt;.github.io 的仓库，现在还需要创建另一个仓库来存放文章管理文件。仓库名任意，公有与私有均可。另外，还需要创建一个仓库来存储文章中涉及到的图片，仓库名任意，但必须是公有的。本例中，我们所用到的仓库名如下。\n   仓库名 用途 公有或私有     blog_workflow 存储博客中文章或者主题等原始文件 私有   sudrizzz.github.io 存储 Hugo 生成的静态文件 公有   blog_images 存储图片文件 公有    拆分文件 上文中我们只是将 /public 文件夹提交到了 sudrizzz.github.io 仓库，现在我们还需要将除了 /public 以外的文件全部提交到 blog_workflow，实现这一步可以再本地建立两个对应的文件夹，分别进行提交，操作步骤不再赘述。拆分后的目录结构如下。\nblog_workflow 仓库 ├─archetypes ├─content │ └─cn │ └─posts ├─layouts ├─resources │ └─_gen └─themes └─yinyang ├─... sudrizzz.github.io 仓库 ├─categories │ └─test ├─css │ └─highlight ├─fonts ├─images ├─js ├─posts │ └─test └─tags 配置公私密钥 生成密钥 打开 Git Bash，执行如下命令\n1ssh-keygen -t rsa -b 4096 -C \u0026#34;sudrizzz.github.io\u0026#34; 设置密钥存储位置，按照提示进行操作，不需要自定义一路回车即可。\nGenerating public/private rsa key pair. Enter file in which to save the key (/c/Users/.ssh/id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /c/Users/.ssh/deploy. Your public key has been saved in /c/Users/.ssh/deploy.pub. The key fingerprint is: SHA256:MpU2IEDuvNADO1AVWrQx/3HMAECYw+C3taw+5Fyy2F4 sudrizzz.github.io The key's randomart image is: +---[RSA 4096]----+ |.++B@oo.. | |.o=o * . = | |o.oo... * + | |.*. + .+ + | |+ =. oo S | | o =.. o | | B.+E | | ..*. | | .o. | +----[SHA256]-----+ 生成的密钥文件放置在 c/Users/\u0026lt;user\u0026gt;/.ssh/ 文件夹中，分别是\n id_rsa id_rsa.pub  其中后缀为 .pub 的文件为公钥，另一个则为私钥。\n配置密钥 配置私钥 打开 blog_workflow 仓库，进入 Settings -\u0026gt; Secrets，选择 New secret，名称填写为 ACTIONS_DEPLOY_KEY，后续需要用到该名称。\n打开 id_rsa，并复制其全部内容，粘贴到 Value 中，点击添加。\n配置公钥 打开 sudrizzz.github.io 仓库，进入 Settings -\u0026gt; Deploy keys，选择 Add deploy key，名字可以任意写。\n打开 id_rsa.pub，并复制其全部内容，粘贴到 Key 中，勾选 Allow write access，点击添加。 配置 Action 脚本 打开 blog_workflow 仓库，进入 Action，初始化左侧界面，选择 set up a workflow yourself，在编辑框中粘贴如下配置\n1name: CI 2 3# 持续发布的分支 4on: 5 push: 6 branches: master 7 8# 执行的 jobs 9jobs: 10 # 编译环境 11 build: 12 runs-on: ubuntu-latest 13 14 # 执行的步骤 15 steps: 16 # 检出 sudrizzz/blog_workflow 工程，固定写法 17 - uses: actions/checkout@v1 18 19 - name: Setup Hugo 20 uses: peaceiris/actions-hugo@v2 21 with: 22 hugo-version: latest 23 24 # 执行 hugo，编译出源文件 25 - name: Build 26 run: hugo --gc --minify --cleanDestinationDir 27 28 # 部署 29 - name: Deploy 30 uses: peaceiris/actions-gh-pages@v3 31 with: 32 deploy_key: ${{ secrets.ACTIONS_DEPLOY_KEY }} # 上面配置的私钥名称 33 external_repository: sudrizzz/sudrizzz.github.io # Pages 发布到远程仓库 34 publish_dir: ./public # hugo 编译生成的 public 目录下的文件 35 keep_files: false # 不保留 *.github.io 仓库中已有的文件 36 publish_branch: master # 远程仓库分支 37 commit_message: ${{ github.event.head_commit.message }} 注意修改第 33 行 external_repository 中的用户名。 该配置的文件名任意，例如 main.yml。保存后即可在 Actions 界面查看脚本执行情况。每当 blog_workflow 仓库有新的 push 操作时，就会自动执行该脚本，然后将执行后生成的文件自动提交到 sudrizzz.github.io。\n至此，利用 Github Actions 实现自动部署就已经完成了，写作步骤简化为：\n 在 content/posts/cn/ 目录中新增文章，修改相关头信息，完成内容创作并保存； 执行 hugo server 并访问 localhost:1313 查看文章显示效果； 提交新文章到 blog_workflow； 上述 Action 自动编译并将生成的静态文件部署到 sudrizzz.github.io。  创作流程得到了极大的简化。下面将介绍使用 Github 作为图床的相关配置。\n安装并配置 PicGo 本文使用的方案是 VSCode + PicGo 扩展，所以首先打开 VSCode 安装好 PicGo，此处不再赘述。\n如果需要使用 PicGo Windows 客户端，请点击 https://github.com/Molunerfinn/PicGo/releases 下载，并跳过本节配置说明。\n生成 Token 点击 Github 右上角个人头像，进入 Settings -\u0026gt; Developer settings -\u0026gt; Personal access tokens，点击 Generate new token。\nNote 中可以任意填写，勾选下方的 repo 复选框，点击页面最下方的 Generate token，复制生成的 token 字符串。 配置 PicGo 在 VSCode 中打开 PicGo 的设置界面，将复制的 token 字符串填到 picgo.picBed.github.token 中，具体配置见下图。  picgo.picBed.github.customUrl\n此项是利用 jsDelivr CDN 为图片进行加速服务，填写时只需将 sudrizzz/blog_images 更改为自己的用户名与仓库即可，具体如下。  https://cdn.jsdelivr.net/gh/sudrizzz/blog_images@main  picgo.picBed.github.path\n此项是配置图片的存储路径，根目录为 picgo.picBed.github.repo 中设置的仓库。  当然你可以新建一个仓库专门用来存储图片，只需要调整上述相关设置，使其保持一致即可。\n使用 PicGo 写作 在编写 markdown 文件需要插入图片时，只需要使用相应的快捷键即可完成上传图片操作，具体如下。\n从剪贴板上传图像 Windows / Unix：Ctrl + Alt + U OSX：Cmd + Opt + U 从资源管理器上传图像 Windows / Unix：Ctrl + Alt + E OSX：Cmd + Opt + E 结语 至此，搭建 Github Pages 系列文章就到此结束了，作者的需求基本得到了满足，感谢您的阅读。\n","date":"2020-08-09T15:00:00+08:00","permalink":"https://sudrizzz.github.io/posts/integrating-with-github-action/","title":"Github 自动部署与图床"},{"content":"创建仓库 首先需要在 Github 中创建一个名为 \u0026lt;username\u0026gt;.github.io 的仓库，其中 \u0026lt;username\u0026gt; 为你的 Github 用户名。\n 注意：\n由于 username 不方便叙述，故下文中均以 sudrizzz 为例替代 username，\n请根据实际情况进行更改。\n 例如我的 Github 用户名是 sudrizzz，于是创建的仓库名就是 sudrizzz.github.io。\n初始化 Hugo 安装 Hugo 应用 https://github.com/gohugoio/hugo/releases\n配置环境变量 将安装 Hugo 的目录路径配置到用户环境变量 PATH 中，如图 检验配置 在命令行窗口中输入以下内容\n1hugo version 如果得到类似以下的结果则说明配置正确。\nHugo Static Site Generator v0.74.3-DA0437B4 windows/amd64 BuildDate: 2020-07-23T16:23:30Z 创建博客 在命令行中输入以下命令\nhugo new site \u0026lt;blog_name\u0026gt; 上述命令将会创建一个名为 blog_name 的文件夹，请按照个人喜好取名。按照我的博客为例，取名为 sudrizzz.github.io，这样也方便后续进行代码提交\n添加主题 以 yinyang 主题为例，按照文档中的安装步骤，执行以下命令\n1cd sudrizzz.github.io 2git clone git@github.com:joway/hugo-theme-yinyang.git themes/yinyang 进入 sudrizzz.github.io/themes/yinyang/exampleSite 目录，将 content 文件夹和 config.toml 文件拷贝到 sudrizzz.github.io 目录。\n自定义主题 根据 yinyang 主题配置文档，我们可以按需修改其中的内容即可，以下贴出我自定义的配置内容。\n1baseURL = \u0026#34;https://sudrizzz.github.com\u0026#34; 2languageCode = \u0026#34;zh-cn\u0026#34; 3title = \u0026#34;Anthony\u0026#39;s Blog\u0026#34; 4theme = \u0026#34;yinyang\u0026#34; 5DefaultContentLanguage = \u0026#34;cn\u0026#34; 6 7[author] 8 name = \u0026#34;Anthony Qu\u0026#34; 9 homepage = \u0026#34;https://github.com/sudrizzz/\u0026#34; 10 11[languages] 12 # [languages.en] 13 # contentDir = \u0026#34;content/en\u0026#34; 14 # languageName = \u0026#34;English\u0026#34; 15 # weight = 1 16 [languages.cn] 17 contentDir = \u0026#34;content/cn\u0026#34; 18 languageName = \u0026#34;Chinese\u0026#34; 19 weight = 1 20 21[params] 22disqus = \u0026#34;sudri\u0026#34; # disqus account name 23extraHead = \u0026#39;\u0026#39; 24mainSections = [\u0026#34;posts\u0026#34;] 25# googleAnalytics = \u0026#34;\u0026#34; 26# description = \u0026#34;\u0026#34; 27 28[[params.socials]] 29name = \u0026#34;Github\u0026#34; 30link = \u0026#34;https://github.com/sudrizzz/\u0026#34; 31 32[[params.socials]] 33name = \u0026#34;RSS\u0026#34; 34link = \u0026#34;/index.xml\u0026#34; 添加文章 在 sudrizzz.github.io 文件夹中执行以下命令以新增文章\n1hugo new content/cn/posts/my-first-post.md 但是我个人不建议这么操作，原因有两点\n 此主题的 posts 目录分为 cn 和 en，也就是中文和英语目录，路径较长，敲命令不是很方便； md 文件中需要包含特定格式的头信息（如下），才能被正常渲染，而通过上述命令生成的 md 文件是空白文件，自己添加头信息也不太现实。  md 头信息 title: \u0026quot;从零搭建 Github Pages\u0026quot; date: 2020-08-09T00:00:00+08:00 draft: false categories: [\u0026quot;blog\u0026quot;] slug: \u0026quot;build-blog-from-scratch\u0026quot; 其中各项含义如下 title: 文章显示标题 date: 文章创建日期与时间 draft: 是否为草稿状态 categories: 分类信息，可添多个关键词，用半角逗号分隔 slug: 文章渲染后的 url 所以我更推荐直接拷贝已有的文章，然后修改其中的内容（包括头信息）即可。 在此我创建了名为 TestFile.md 的测试文件以作演示，完整内容如下。\n--- title: \u0026quot;这是一个测试文件\u0026quot; date: 2020-01-01T00:00:00+08:00 draft: false categories: [\u0026quot;test\u0026quot;] slug: \u0026quot;this-is-a-test-file\u0026quot; --- This is a test file. Nothing special here. 启动服务 在 sudrizzz.github.io 目录执行以下命令\nhugo server 会得到类似于如下的信息\nBuilding sites … | CN -------------------+----- Pages | 17 Paginator pages | 0 Non-page files | 0 Static files | 13 Processed images | 0 Aliases | 0 Sitemaps | 1 Cleaned | 0 Built in 28 ms Watching for changes in D:\\Blog\\sudrizzz.github.io\\{archetypes,content,layouts,themes} Watching for config changes in D:\\Blog\\sudrizzz.github.io\\config.toml Environment: \u0026quot;development\u0026quot; Serving pages from memory Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender Web Server is available at http://localhost:1313/ (bind address 127.0.0.1) Press Ctrl+C to stop 可以看到最后一行显示已经启动成功，页面地址是 http://localhost:1313/ ，访问这个地址即可看到如下效果。\n点击标题进入文章即可看到全部内容。\n编译文章  说明：\n下述命令中的参数可以根据 Hugo 官方文档按需添加\nhttps://gohugo.io/commands/hugo/#options\n hugo --minify --cleanDestinationDir 可以得到如下结果\nBuilding sites … | CN -------------------+----- Pages | 14 Paginator pages | 0 Non-page files | 0 Static files | 13 Processed images | 0 Aliases | 0 Sitemaps | 1 Cleaned | 0 Total in 29 ms 这样就编译完成了，编译后生成的静态文件放在 sudrizzz.github.io/public 目录下。结构如下：\n├─categories │ └─test ├─css │ └─highlight ├─fonts ├─images ├─js ├─posts │ └─this-is-a-test-file └─tags 至此博客就基本搭建完成了。接下来要做的就是与前文中提到的 Github Pages 仓库结合起来。\n推送到 Github  说明 1：\n此处涉及到 Git 的相关操作，请先根据其他教程配置好 Git 环境再执行命令；\n或者也可以安装一些 Git 可视化工具来简化操作，例如 TortoiseGit。\n  说明 2:\n我们只需要将 Hugo 生成的静态文件托管到 Github，\n所以请确保下述命令是在 /pulic 目录中执行的。\n 在 sudrizzz.github.io/pulic 目录中执行以下命令\n1git clone https://github.com/sudrizzz/sudrizzz.github.io.git 2git add . 3git commit -m \u0026#34;\u0026lt;commit_info\u0026gt;\u0026#34; 4git push origin master 这样博客的所有内容就都已经推送到了 Github，稍等片刻，即可访问 sudrizzz.github.io 查看部署结果。\n总结 前文搭建的博客是由 Github Pages + Hugo 实现的，具体的新增文章步骤可以总结为以下几点。\n 在 content/posts/cn/ 目录中新增文章，修改相关头信息，完成内容创作并保存； 执行 hugo server 并访问 localhost:1313 查看文章显示效果，酌情修改； 执行 hugo --minify --cleanDestinationDir； 进入 /public 目录，将新生成或编辑过的内容推送到 Github，此处不再赘述。  此时我们的博客就创建好了，但是创建文章内容的操作有一些复杂和繁琐，且本文中并未讲解关于 markdown 中插入图片的相关问题。所以在下文中，我们将简化操作步骤，并实现将图片也托管到 Github 的操作。\n","date":"2020-08-09T12:00:00+08:00","permalink":"https://sudrizzz.github.io/posts/build-blog-from-scratch/","title":"从零搭建 Github Pages"},{"content":" ……我细读来书，终觉得你不免作茧自缚。你自己去寻出一个本不成问题的问题，“人生有何意义？”其实这个问题是容易解答的。人生的意义全是各人自己寻出来、造出来的：高尚、卑劣、清贵、污浊、有用、无用，……全靠自己的作为。\n 生命本身不过是一件生物学的事实，有什么意义可说？一个人与一只猎，一只狗，有什么分别？人生的意义不在于何以有生，而在自己怎样生活。你若情愿把这六尺之躯葬送在白昼作梦之上二那就是你这一生的意义。你若发愤振作起来，决心去寻求生命的意义，去创造自己的生命的意义，那么，你活一日便有一日的意义，作一事便添一事的意义，生命无穷，生命的意义也无穷了。\n 总之，生命本没有意义，你要能给他什么意义，他就有什么意义。与其终日冥想人生有何意义，不如试用此生作点有意义的事……\n 节选自《答某君书》—— 胡适\n","date":"2019-06-21T00:00:00+08:00","permalink":"https://sudrizzz.github.io/posts/the-meaning-of-life/","title":"The meaning of life"}]